<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java面试知识点--基础篇</title>
    <url>/likemoves.github.io/2020/05/25/Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="java异常处理机制"><a href="#java异常处理机制" class="headerlink" title="java异常处理机制"></a>java异常处理机制</h2><p>异常处理机制主要回答了三个问题</p>
<blockquote>
<p>What：异常类型回答了什么被抛出<br>Where：异常堆栈跟踪回答了在哪抛出<br>Why：异常信息回答了为什么被抛出</p>
</blockquote>
<p><strong>抛出异常</strong>：创建异常对象，交由运行时系统处理<br><strong>捕获异常</strong>：寻找合适的异常处理器处理异常，否则终止运行</p>
<h2 id="Error和Exception的区别"><a href="#Error和Exception的区别" class="headerlink" title="Error和Exception的区别"></a>Error和Exception的区别</h2><p>从概念角度解析java的异常处理机制</p>
<p>Error：程序无法处理的系统错误，编译器不做检查<br>Exception：程序可以处理的异常，捕获后可能恢复<br>总结：前者是程序无法处理的错误，后者是可以处理的异常</p>
<p>◆RuntimeException：不可预知的，程序应当自行避免<br>◆非RuntimeException：可预知的，从编译器校验的异常</p>
<p>从责任角度看：<br>1.Error属于JVM需要负担的责任；<br>2.RuntimeException是程序应该负担的责任；<br>3.Checked Exception可检查异常是Java编译器应该负担的责任。</p>
<h3 id="常见Error以及Exception"><a href="#常见Error以及Exception" class="headerlink" title="常见Error以及Exception"></a>常见Error以及Exception</h3><h4 id="RuntimeException"><a href="#RuntimeException" class="headerlink" title="RuntimeException"></a>RuntimeException</h4><p>1.NullPointerException -空指针引用异常<br>2.ClassCastException -类型强制转换异常<br>3.llegalArgumentException -传递非法参数异常<br>4.IndexOutOfBoundsException -下标越界异常<br>5.NumberFormatException -数字格式异常</p>
<h4 id="非RuntimeException"><a href="#非RuntimeException" class="headerlink" title="非RuntimeException"></a>非RuntimeException</h4><p>1.ClassNotFoundException-找不到指定class的异常<br>2.IOException-IO操作异常</p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>1.NoClassDefFoundError-找不到class定义的异常<br>2.StackOverflowError-深递归导致栈被耗尽而抛出的异常<br>3.OutOfMemoryError-内存溢出异常</p>
<p><strong>NoClassDeffoundError的成因</strong><br>1.类依赖的class或者jar不存在</p>
<p>2.类文件存在，但是存在不同的域中</p>
<p>3.大小写问题，javac编译的时候是无视大小写的，很有可能编译出来的class文件就与想要的不一样</p>
<h2 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO/NIO/AIO"></a>BIO/NIO/AIO</h2><table>
<thead>
<tr>
<th align="left">属性/模型</th>
<th>阻塞BIO</th>
<th>非阻塞NIO</th>
<th>异步AIO</th>
</tr>
</thead>
<tbody><tr>
<td align="left">blocking</td>
<td>阻塞并同步</td>
<td>非阻塞同步</td>
<td>非阻塞异步</td>
</tr>
<tr>
<td align="left">线程数（server:client）</td>
<td>1:1</td>
<td>1：N</td>
<td>0：N</td>
</tr>
<tr>
<td align="left">复杂度</td>
<td>简单</td>
<td>较复杂</td>
<td>复杂</td>
</tr>
<tr>
<td align="left">吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<p>同步 ：  自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）；</p>
<p>异步 ：  委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）；</p>
<p>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；</p>
<p>非阻塞 ：  柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）</p>
<p> 之前看了很多关于同步、异步、阻塞、非阻塞的，今天看了感觉同步和异步的区别主要是否开启新线程。阻塞和非阻塞的区别主要是看主线程是否阻塞</p>
]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java集合</tag>
        <tag>java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/likemoves.github.io/2020/06/11/Java%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Java开发面试：高并发秒杀系统如何设计与优化"><a href="#Java开发面试：高并发秒杀系统如何设计与优化" class="headerlink" title="Java开发面试：高并发秒杀系统如何设计与优化"></a>Java开发面试：高并发秒杀系统如何设计与优化</h1><p> 转载：<a href="https://blog.csdn.net/CSDN_Terence/article/details/77744042" target="_blank" rel="noopener">https://blog.csdn.net/CSDN_Terence/article/details/77744042</a></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>简单说一下秒杀系统的设计思路?</p>
<p>你怎么实现秒杀业务的？</p>
<p>你怎么保证秒杀成功的？</p>
<p>秒杀操作的策略是什么？</p>
<p>你使用的Redis有什么用？</p>
<p>你为什么使用Redis中间件？</p>
<p>你测试过你这个系统的抗压能力么？</p>
<p>你使用过什么方法来测试你的系统并发量？</p>
<p>你觉得你这个系统还可以再优化么？</p>
<p>你觉得你这个系统的瓶颈在哪里？还可以在哪些方向做进一步优化?</p>
<h2 id="秒杀系统特点"><a href="#秒杀系统特点" class="headerlink" title="秒杀系统特点"></a>秒杀系统特点</h2><ol>
<li>秒杀业务简单，卖家查询，买家下订单减库存。</li>
<li>秒杀时网站访问流量激增，出现峰值；</li>
<li>访问请求数量远大于实际需求量。</li>
</ol>
<h2 id="架构设计优化方案"><a href="#架构设计优化方案" class="headerlink" title="架构设计优化方案"></a>架构设计优化方案</h2><h3 id="秒杀系统架构设计优化"><a href="#秒杀系统架构设计优化" class="headerlink" title="秒杀系统架构设计优化"></a>秒杀系统架构设计优化</h3><p> 一个常规的秒杀系统从前到后，依次有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端浏览器秒杀页面=》中间代理服务=》后端服务层=》数据库层</span><br></pre></td></tr></table></figure>

<p> 根据这个流程，一般优化设计思路：<strong>将请求拦截在系统上游，降低下游压力。</strong>在一个并发量大，实际需求小的系统中，应当尽量在前端拦截无效流量，降低下游服务器和数据库的压力，不然很可能造成数据库读写锁冲突，甚至导致死锁，最终请求超时。 </p>
<p>整体设计思路和优化点：</p>
<pre><code>限流：屏蔽掉无用的流量，允许少部分流量流向后端。

削峰：瞬时大流量峰值容易压垮系统，解决这个问题是重中之重。常用的消峰方法有异步处理、缓存和消息中间件等技术。

异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。

内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。

可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。

消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。

充分利用缓存：利用缓存可极大提高系统读写速度。 </code></pre><h3 id="详细方案"><a href="#详细方案" class="headerlink" title="详细方案"></a>详细方案</h3><h4 id="1-前端"><a href="#1-前端" class="headerlink" title="1.前端"></a>1.前端</h4><p><strong>静态资源缓存：</strong>将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过CDN缓存静态资源，来抗峰值。 </p>
<p><strong>禁止重复提交</strong>：用户提交之后按钮置灰，禁止重复提交 </p>
<p><strong>用户限流：</strong>在某一时间段内只允许用户提交一次请求，比如可以采取IP限流</p>
<h4 id="2-中间代理层"><a href="#2-中间代理层" class="headerlink" title="2.中间代理层"></a>2.中间代理层</h4><p>可利用<strong>负载均衡</strong>（例如反响代理Nginx等）使用多个服务器并发处理请求，减小服务器压力。</p>
<h4 id="3-后端方案"><a href="#3-后端方案" class="headerlink" title="3.后端方案"></a>3.后端方案</h4><p><strong>控制层(网关层)</strong></p>
<pre><code>限制同一UserID访问频率：尽量拦截浏览器请求，但针对某些恶意攻击或其它插件，在服务端控制层需要针对同一个访问uid，限制访问频率。</code></pre><p><strong>服务层</strong></p>
<pre><code>当用户量非常大的时候，拦截流量后的请求访问量还是非常大，此时仍需进一步优化。

1.业务分离:将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。

2.采用消息队列缓存请求：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。

3.利用缓存应对读请求：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力。

4.利用缓存应对写请求：缓存也是可以应对写请求的，可把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。</code></pre><h4 id="4-数据库层"><a href="#4-数据库层" class="headerlink" title="4.数据库层"></a>4.数据库层</h4><p>数据库层是最脆弱的一层，一般在应用设计时在上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。</p>
<p>如果不使用缓存来作为中间缓冲而是直接访问数据库的话，可以对数据库进行优化，减少数据库压力。</p>
<p>对于秒杀系统，直接访问数据库的话，存在一个【事务竞争优化】问题，可使用存储过程（或者触发器）等技术绑定操作，整个事务在MySQL端完成，把整个热点执行放在一个过程当中一次性完成，可以屏蔽掉网络延迟时间，减少行级锁持有时间，提高事务并发访问速度。</p>
<h4 id="5-其他策略"><a href="#5-其他策略" class="headerlink" title="5.其他策略"></a>5.其他策略</h4><p>减少硬件开销的策略 ：</p>
<pre><code>策略1：消息队列缓存请求，按照队列模型取任务执行，秒杀完毕即终止到秒杀结束页面。

策略2：使用数组为并发请求随机分配秒杀状态（成功和失败），然后将分配到失败状态的请求派发到秒杀失败的页面，分到成功状态的用户在慢慢的按顺序执行秒杀操作；（如果处理失败了可以利用日志来查找具体秒杀失败的商品和用户，执行补救措施或者从其他用户中拿取一个来执行秒杀操作）

策略3：类似于策略2，不过是用数组为用户分配秒杀资格，将大流量的用户限制为小流量的用户，得到秒杀资格的去执行秒杀，得不到秒杀资格的跳到秒杀失败页面。 </code></pre><p>（分配状态或分配秒杀资格的策略：（数组状态密度不同，由前到后逐渐稀疏，可以让先到的在前面随机分配，后到的在后面随机分配）根据先到的时间）</p>
]]></content>
  </entry>
  <entry>
    <title>Java面试知识点--集合篇</title>
    <url>/likemoves.github.io/2020/05/20/Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--%E9%9B%86%E5%90%88%E7%AF%87/</url>
    <content><![CDATA[<h2 id="哪些是线程安全的List？"><a href="#哪些是线程安全的List？" class="headerlink" title="哪些是线程安全的List？"></a>哪些是线程安全的List？</h2><p>1）Collections.synchronizedList()</p>
<p>Collections这样的一个类，使用它我们可以获取线程安全的List容器—Collections.synchronizedList(List<t> list)，但是无论是读取还是写入，它都会进行加锁，当我们并发级别特别高，线程之间在任何操作上都会进行等待，因此在某些场景中它不是最好的选择。</t></p>
<p>2）CopyOnWriteArrayList</p>
<p>该类在使用过程中，读读之间不互斥并且更厉害的是读写也不互斥。</p>
<h2 id="CopyOnWriteArrayList，如何实现线程安全的。"><a href="#CopyOnWriteArrayList，如何实现线程安全的。" class="headerlink" title="CopyOnWriteArrayList，如何实现线程安全的。"></a>CopyOnWriteArrayList，如何实现线程安全的。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到旧数组并获取旧数组的长度</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制旧数组的元素到新的数组中并且大小在原基础上加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//把值插入到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//使用新数组替换老数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中，我们可以看出<strong>add操作中使用了重入锁</strong>，但是此锁<strong>只针对写-写操作</strong>。为什么读写之间不用互斥，关键就在于<strong>添加值的操作并不是直接在原有数组中完成</strong>，而是使用原有数组复制一个新的数组，然后将值插入到新的数组中，最后使用新数组替换旧数组，这样插入就完成了。大家可以发现，使用这种方式，<strong>在add的过程中旧数组没有得到修改，因此写入操作不影响读取操</strong>，另外，数组定义<strong>private transient volatile Object[] array</strong>，其中采用<strong>volatile修饰，保证内存可见性</strong>，读取线程可以马上知道这个修改。下面我们来看看读取的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br></pre></td></tr></table></figure>

<p>读取操作完全没有使用任何的同步控制或者是加锁，这是因为array数组内部结构不会发生任何改变，只会被另外一个array所替换，因此读取是线程安全的。</p>
<h2 id="Collections-synchronizedList-和CopyOnWriteArrayList使用场景"><a href="#Collections-synchronizedList-和CopyOnWriteArrayList使用场景" class="headerlink" title="Collections.synchronizedList()和CopyOnWriteArrayList使用场景"></a>Collections.synchronizedList()和CopyOnWriteArrayList使用场景</h2><p>在真实环境中，使用它们可以根据我们的业务需要，在<strong>插入操作远远超过读取</strong>时，建议使用第一种方式，这是因为CopyOnWriteArrayList在插入的过程中会<strong>创建新的数组</strong>，这样在数据量特别大的情况下，对内存的消耗是很大的。当然，如果是读取操作远远大于插入时，第二种方式肯定更占优势，毕竟读取操作完全不需要加锁。</p>
<h2 id="HashMap和LinkedHashMap的区别"><a href="#HashMap和LinkedHashMap的区别" class="headerlink" title="HashMap和LinkedHashMap的区别"></a>HashMap和LinkedHashMap的区别</h2><p>LinkedHashMap<br>LinkedHashMap也是一个HashMap,但是内部维持了一个双向链表,可以保持顺序</p>
<p>hashMap键只能允许为一条为空，value可以允许为多条为空，键唯一，但值可以多个。                                  linkedMap键和值都不可以为空</p>
<h2 id="HashMap-与-HashTable-的区别是什么？"><a href="#HashMap-与-HashTable-的区别是什么？" class="headerlink" title="HashMap 与 HashTable 的区别是什么？"></a><strong>HashMap 与 HashTable 的区别是什么？</strong></h2><ol>
<li>HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary  是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。</li>
<li>HashMap 的 key 和 value 都允许为 null，而 Hashtable 的 key 和 value 都不允许为 null。HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理；Hashtable 遇到  null，直接返回 NullPointerException。</li>
<li>Hashtable 是线程安全的，而 HashMap 不是线程安全的，但是我们也可以通过 Collections.synchronizedMap(hashMap)，使其实现同步。</li>
</ol>
]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java集合</tag>
        <tag>java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot JPA</title>
    <url>/likemoves.github.io/2019/09/16/Spring%20Boot%20JPA/</url>
    <content><![CDATA[<h1 id="Spring-Boot-JPA"><a href="#Spring-Boot-JPA" class="headerlink" title="Spring Boot JPA"></a>Spring Boot JPA</h1><hr>
<p>##1.JPA概念<br>JPA(Java Persistence API)是Sun官方提出的Java持久化规范，用来方便大家操作数据库。<br>真正干活的可能是Hibernate,TopLink等等实现了JPA规范的不同厂商,默认是Hibernate。<br>本知识演示如何在Springboot中快捷方便地使用JPA。 </p>
<hr>
<p>##2. application.properties 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=admin</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br></pre></td></tr></table></figure>

<hr>
<p>##3.pom.xml配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- mysql--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- jpa--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>##4.Category 实体类<br>增加一个包：com.how2java.springboot.pojo，然后创建实体类Category。<br>@Entity 注解表示这是个实体类<br>@Table(name = “category_”) 表示这个类对应的表名是 category_ ，注意有下划线哦<br>@Id 表明主键<br>@GeneratedValue(strategy = GenerationType.IDENTITY) 表明自增长方式<br>@Column(name = “id”) 表明对应的数据库字段名 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;category_&quot;)</span><br><span class="line">public class Category &#123;</span><br><span class="line"> </span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;id&quot;)</span><br><span class="line">    private int id;</span><br><span class="line">     </span><br><span class="line">    @Column(name = &quot;name&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>##5. CategoryDAO<br>增加一个包：com.how2java.springboot.dao，然后创建dao接口CategoryDAO，继承了JpaRepository，并且提供泛型&lt;Category,Integer&gt; 表示这个是针对Category类的DAO,Integer表示主键是Integer类型。<br>JpaRepository 这个父接口，就提供了CRUD, 分页等等一系列的查询了，直接拿来用，都不需要二次开发的了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.how2java.springboot.dao;</span><br><span class="line"> </span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"> </span><br><span class="line">import com.how2java.springboot.pojo.Category;</span><br><span class="line"> </span><br><span class="line">public interface CategoryDAO extends JpaRepository&lt;Category,Integer&gt;&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>##6.CategoryController<br>增加一个包：com.how2java.springboot.web，然后创建CategoryController 类。</p>
<ol>
<li>接受listCategory映射</li>
<li>然后获取所有的分类数据</li>
<li>接着放入Model中</li>
<li>跳转到listCategory.jsp中 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class CategoryController &#123;</span><br><span class="line">    @Autowired CategoryDAO categoryDAO;</span><br><span class="line">     </span><br><span class="line">    @RequestMapping(&quot;/listCategory&quot;)</span><br><span class="line">    public String listCategory(Model m) throws Exception &#123;</span><br><span class="line">        List&lt;Category&gt; cs=categoryDAO.findAll();</span><br><span class="line">         </span><br><span class="line">        m.addAttribute(&quot;cs&quot;, cs);</span><br><span class="line">         </span><br><span class="line">        return &quot;listCategory&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>##7.增删查改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/addCategory&quot;)</span><br><span class="line">public String addCategory(Category c) throws Exception &#123;</span><br><span class="line">	categoryDAO.save(c);</span><br><span class="line">	return &quot;redirect:listCategory&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/deleteCategory&quot;)</span><br><span class="line">public String deleteCategory(Category c) throws Exception &#123;</span><br><span class="line">	categoryDAO.delete(c);</span><br><span class="line">	return &quot;redirect:listCategory&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/updateCategory&quot;)</span><br><span class="line">public String updateCategory(Category c) throws Exception &#123;</span><br><span class="line">	categoryDAO.save(c);</span><br><span class="line">	return &quot;redirect:listCategory&quot;;</span><br><span class="line">&#125;</span><br><span class="line">@RequestMapping(&quot;/editCategory&quot;)</span><br><span class="line">public String editCategory(int id,Model m) throws Exception &#123;</span><br><span class="line">	Category c= categoryDAO.getOne(id);</span><br><span class="line">	m.addAttribute(&quot;c&quot;, c);</span><br><span class="line">	return &quot;editCategory&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>##8.分页查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/listCategory&quot;)</span><br><span class="line">public String listCategory(Model m,@RequestParam(value = &quot;start&quot;, defaultValue = &quot;0&quot;) int start,@RequestParam(value = &quot;size&quot;, defaultValue = &quot;5&quot;) int size) throws Exception &#123;</span><br><span class="line">	start = start&lt;0?0:start;</span><br><span class="line">	Sort sort = new Sort(Sort.Direction.DESC, &quot;id&quot;);</span><br><span class="line">	Pageable pageable = new PageRequest(start, size, sort);</span><br><span class="line">	Page&lt;Category&gt; page =categoryDAO.findAll(pageable);</span><br><span class="line">	m.addAttribute(&quot;page&quot;, page);</span><br><span class="line">    return &quot;listCategory&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在参数里接受当前是第几页 start ，以及每页显示多少条数据 size。 默认值分别是0和5。<br>(Model m,@RequestParam(value = “start”, defaultValue = “0”) int start,@RequestParam(value = “size”, defaultValue = “5”) int size)</p>
</li>
<li><p>如果 start 为负，那么修改为0. 这个事情会发生在当前是首页，并点击了上一页的时候<br>start = start&lt;0?0:start;</p>
</li>
<li><p>设置倒排序<br>Sort sort = new Sort(Sort.Direction.DESC, “id”);</p>
</li>
<li><p>根据start,size和sort创建分页对象<br>Pageable pageable = new PageRequest(start, size, sort);</p>
</li>
<li><p>CategoryDAO根据这个分页对象获取结果page.<br>Page<category> page =categoryDAO.findAll(pageable);<br>在这个page对象里，不仅包含了分页信息，还包含了数据信息，即有哪些分类数据。 这个可以通过getContent()获取出来。</category></p>
</li>
<li><p>把page放在”page”属性里，跳转到listCategory.jsp<br>m.addAttribute(“page”, page);<br>return “listCategory”;</p>
</li>
</ol>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/likemoves.github.io/2019/09/17/%E5%85%B3%E4%BA%8Erequest.getServletPath()%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="关于request-getServletPath-，request-getContextPath-的总结"><a href="#关于request-getServletPath-，request-getContextPath-的总结" class="headerlink" title="关于request.getServletPath()，request.getContextPath()的总结"></a>关于request.getServletPath()，request.getContextPath()的总结</h1><hr>
<p>转载链接：<a href="https://blog.csdn.net/qq_27770257/article/details/79438987" target="_blank" rel="noopener">https://blog.csdn.net/qq_27770257/article/details/79438987</a></p>
<p>本文章主要讨论以下几种request获取路径的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.getServletPath()</span><br><span class="line">request.getPathInfo()</span><br><span class="line">request.getContextPath()</span><br><span class="line">request.getRequestURI()</span><br><span class="line">request.getRequestURL()</span><br><span class="line">request.getServletContext().getRealPath()</span><br></pre></td></tr></table></figure>

<p>TestServlet.java文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.java.test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public class TestServlet extends HttpServlet&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        this.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;servletPath:&quot;+req.getServletPath());</span><br><span class="line">        System.out.println(&quot;contextPath:&quot;+req.getContextPath());</span><br><span class="line">        System.out.println(&quot;contextPath2:&quot;+req.getServletContext().getContextPath());</span><br><span class="line">        System.out.println(&quot;pageInfo:&quot;+req.getPathInfo());</span><br><span class="line">        System.out.println(&quot;uri:&quot;+req.getRequestURI());</span><br><span class="line">        System.out.println(&quot;url:&quot;+req.getRequestURL());</span><br><span class="line">        System.out.println(&quot;realPath:&quot;+req.getServletContext().getRealPath(&quot;/&quot;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求<a href="http://localhost:8080/testweb/abc/def/ghi/test.html" target="_blank" rel="noopener">http://localhost:8080/testweb/abc/def/ghi/test.html</a> (url-pattern=/abc/def/*)<br>打印的值为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">servletPath:/abc/def</span><br><span class="line">contextPath:/testweb</span><br><span class="line">contextPath2:/testweb</span><br><span class="line">pageInfo:/ghi/test.html</span><br><span class="line">uri:/testweb/abc/def/ghi/test.html</span><br><span class="line">url:http://localhost:8080/testweb/abc/def/ghi/test.html</span><br><span class="line">realPath:G:\java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\testweb\</span><br></pre></td></tr></table></figure>

<p>通过观察打印结果，我们可以总结：</p>
<ol>
<li>getServletPath():获取能够与“url-pattern”中匹配的路径，注意是完全匹配的部分，*的部分不包括。</li>
<li>getPageInfo():与getServletPath()获取的路径互补，能够得到的是“url-pattern”中*d的路径部分</li>
<li>getContextPath():获取项目的根路径</li>
<li>getRequestURI:获取根路径到地址结尾</li>
<li>getRequestURL:获取请求的地址链接（浏览器中输入的地址）</li>
<li>getServletContext().getRealPath(“/”):获取“/”在机器中的实际地址</li>
<li>getScheme():获取的是使用的协议(http 或https)</li>
<li>getProtocol():获取的是协议的名称(HTTP/1.11)</li>
<li>getServerName():获取的是域名(xxx.com)</li>
<li>getLocalName:获取到的是IP </li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>剑指offer面试题12--矩阵中的路径</title>
    <url>/likemoves.github.io/2020/04/27/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9812--%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下面矩阵</span><br><span class="line"></span><br><span class="line">a b t g </span><br><span class="line">c f c s </span><br><span class="line">j d e h</span><br><span class="line"></span><br><span class="line">包含一条字符串&quot;bfce&quot;的路径，但是矩阵中不包含&quot;abfb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</span><br></pre></td></tr></table></figure>

<p> 二维数组用一维数组的方式表示:  a[i*M+j] i是行下标，M是一列的元素个数，j是列下标</p>
<p>这有点像图的深度优先搜索。除了矩阵边界，每个点都可以在4个方向上选择任意一个前进。当某一条路径失败后，需要回溯到上一次选择处，选择另一个方向再尝试。如果该处的方向都被尝试过了，继续回溯到上次选择处…每一次选择都会来到一个新的格子，在这个格子处又有若干个方向可选择，就这样不断前进、回溯、再前进，直到找到一条满足要求的路径为止；如果所有点都作为起点搜索一遍后还是没有找到满足要求的路径，说明在这个矩阵中不存在该条路径。</p>
<p>上面的描述，使用递归比较好理解。还有一点需要注意，由于路径上访问过的点不能进入第二次，所以需要一个<code>boolean[] marked</code>标记那些<strong>当前路径上被访问过的点</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathIn2Darray</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>||str==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="comment">//对所有的点都进行一次搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows;row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;cols;col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasPathTo(matrix,rows,cols,row,col,str,<span class="number">0</span>,marked))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 整个数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rows   总行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cols   总列数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row    当前行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col    当前列数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str    字符数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len    字符数组长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> marked 标记被访问过的点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span>[] matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">char</span>[]str,<span class="keyword">int</span> len,<span class="keyword">boolean</span>[] marked)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 二维数组用一维数组的方式表示:  a[i*M+j] i是行下标，M是一行的元素个数，j是列下标</span></span><br><span class="line">        <span class="keyword">int</span> index=row*cols+col;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span>||row&gt;=rows||col&lt;<span class="number">0</span>||col&gt;=cols||matrix[index]!=str[len]||marked[index])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归深度能到字符串末尾，说明有这条路径</span></span><br><span class="line">        <span class="keyword">if</span> (len == str.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        marked[index]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 四个方向上有没有可以到达下一个字符的路径，有任意一个方向可以就继续下一个字符的搜索</span></span><br><span class="line">        <span class="keyword">if</span>(hasPathTo(matrix,rows,cols,row,col-<span class="number">1</span>,str,len+<span class="number">1</span>,marked)||</span><br><span class="line">          hasPathTo(matrix,rows,cols,row,col+<span class="number">1</span>,str,len+<span class="number">1</span>,marked)||</span><br><span class="line">          hasPathTo(matrix,rows,cols,row-<span class="number">1</span>,col,str,len+<span class="number">1</span>,marked)||</span><br><span class="line">          hasPathTo(matrix,rows,cols,row+<span class="number">1</span>,col,str,len+<span class="number">1</span>,marked))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 对于搜索失败需要回溯的路径上的点，则要重新标记为“未访问”，方便另辟蹊径时能访问到</span></span><br><span class="line">        marked[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题11--旋转数组中的最小数字</title>
    <url>/likemoves.github.io/2020/04/26/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9811--%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组&#123;3,4,5,1,2&#125;为&#123;1,2,3,4,5&#125;的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</span><br></pre></td></tr></table></figure>

<h2 id="解法一：顺序遍历"><a href="#解法一：顺序遍历" class="headerlink" title="解法一：顺序遍历"></a>解法一：顺序遍历</h2><p>两个子数组都是递增的，只有在两个子数组的分界线处，才会有前一个字符大于后一个字符。时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (array[i] &gt; array[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      		<span class="keyword">return</span> array[i + <span class="number">1</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题14--剪绳子</title>
    <url>/likemoves.github.io/2020/04/28/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9814--%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给你一根长度为n的绳子，把绳子剪成m段（m、n都是整数且m &gt; 1, n &gt; 1）,m段绳子的长度依然是整数，求m段绳子的长度乘积最大为多少？比如绳子长度为8，我们可以分成2段、3段、4段...8段，只有分成3段且长度分别是2、3、3时能得到最大乘积18</span><br></pre></td></tr></table></figure>

<h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>要求大问题的最优解，可以将大问题分解成小问题，分解的小问题也有最优解，因此将小问题的最优解组合起来就能得到大问题的最优解。若将f(n)定义为将长度为n的绳子分成若干段后的各段长度的最大乘积（最优解），在剪第一刀时有n-1种剪法，可选择在<code>0 &lt; i &lt; n</code>处下刀；如在i处下刀，分成长度为i的左半绳子和长度为n - i的右半绳子，对于这两根绳子，定义最优解为f(i)和f(n-i)，于是<code>f(n) = max(f(i) * f(n-i))</code>，即求出各种相乘可能中的最大值就是f(n)的最优解。这两根绳子又可以继续分下去，就这样从上到下的分下去，但是问题的解决得从下到上来。因为f(2)、f(3)的很好求：</p>
<ul>
<li>f(2) = 1，因为只能分成两半</li>
<li>f(3) = 2，因为分成两段<code>2*1</code> 大于分成三段的<code>1*1*1</code></li>
<li>然后根据这两个最优解求出f(4)、f(5)…直到f(n)，每个f(i)的确定是<strong>通过遍历所有可能的相乘情况，从中选出乘积最大者。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="comment">//长度不唯一是不满足题意返回0</span></span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)&#123;</span><br><span class="line">        reutrn <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] products=<span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 从products[4]到products[length]放的是f(4)~f(n)的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 对所有相乘情况进行遍历求出f(i)的最优解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> product=products[j]*products[i-j];</span><br><span class="line">            <span class="keyword">if</span>(product&gt;max)</span><br><span class="line">                max=product;</span><br><span class="line">        &#125;</span><br><span class="line">        products[i]=max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> products[length];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于长度为2或者3的绳子，可以直接返回答案。之后f(4)<del>f(n)的值存放在了products[4]</del>products[n]中，注意product[1]<del>products[3]中存放的不是f(1)</del>f(3)，它们单纯地表示长度而已，作为求出<code>f(i)，4 &lt;= i &lt;= n</code>的辅助。最后得到的f(n)存放在products[n]中，直接返回即可。第二层中的for循环为了得到f(i)，遍历了所有可能的乘积情况，将最大乘积赋予max。<code>j &lt;= i / 2</code>是为了避免重复的相乘情况，比如i = 4时，只有<code>2*2</code>和<code>1*3</code>两种，<code>3*1</code>和<code>1*3</code>是同一种相乘情况，所以j只到i / 2 = 2即可枚举所有相乘情况。</p>
<h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><p>  我们应用贪婪算法解决问题时，每一步都可以做出一个贪婪的选择。基于这个选择，我们确定能得到问题的最优解。为什么能得到最优解，还需要数学证明来保证。</p>
<p>这道题我们按照下面的做法就能得到最优解：如果绳子长度n &gt;= 5，就不断分出长度为3的绳子，如果最后只剩下长度为1的绳子，退一步，将得到长度为4的绳子，然后将这长度为4的绳子分成<code>2*2</code>(这样分是因为<code>2*2</code>大于原来的<code>3*1</code>)；因此n = 4时不能分出长度为3的绳子,而n = 2，n = 3的最优解可直接返回。</p>
<p>当<code>n &gt;=5</code>时，满足该不等式的满足<code>i*(n-i) &gt; n</code>的只有<code>2*(n-2) &gt; n</code>以及<code>3*(n-3) &gt; n</code>，注意i+n-2  = n，也就是说分出的两个相乘的数要满足和为n，且给定同样的n，<code>3*(n-3)</code>的值更大，这就是为什么要不断分出长度为3的绳子的原因。</p>
<p>基于此写出代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting2</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 长度为1时不满足题意，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// f(2)</span></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// f(3)</span></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计能分出多少段长度为3的绳子</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 如果最有只剩下长度为1的绳子，需要退一步，得到长度为4的绳子，重新分成2*2的</span></span><br><span class="line">    <span class="keyword">if</span> (length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        timesOf3--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计能分出多少段长度为2的绳子</span></span><br><span class="line">    <span class="comment">// 到这步length - timesOf3 * 3的值只可能是0,2,4，所以timesOf2只可能是0, 1, 2</span></span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, timesOf3) * (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, timesOf2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题13--机器人的运动范围</title>
    <url>/likemoves.github.io/2020/04/28/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9813--%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">地上有一个m行和n列的方格。一个机器人从坐标<span class="number">0</span>,<span class="number">0</span>的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为<span class="number">18</span>时，机器人能够进入方格（<span class="number">35</span>,<span class="number">37</span>），因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">7</span> = <span class="number">18</span>。但是，它不能进入方格（<span class="number">35</span>,<span class="number">38</span>），因为<span class="number">3</span>+<span class="number">5</span>+<span class="number">3</span>+<span class="number">8</span> = <span class="number">19</span>。请问该机器人能够达到多少个格子？</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>此题和<em>面试题12——矩阵中的路径</em>有相似之处，依然是回溯法。每来到一个新的且满足条件的格子时，计数加1。除矩形的边界外，任意一个方格都有四个方向可以选择，选择任一方向后来到新的格子又可以选择四个方向，但是一个到达过的格子不能进入两次，因为这将导致对同一个格子的重复计数。也就是说，<strong>一个格子一旦满足条件进入后，就被永久标记为“访问过”，一个满足条件的格子只能使计数值加1。</strong>这是和面试题12有区别的地方（那个例子中是搜索路径，失败路径上的点要重新标记为“未访问”，因为另开辟的新路径需要探索这些点）。</p>
<p>这道题用通俗的话来讲就是：m行n列的所有方格中，有多少个满足<strong>行坐标和列坐标的数位之和小于等于门限值k</strong>的格子？</p>
<p>代码和面试题12长得有点像，但是两个问题是有明显区别的！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobotMove</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rows&lt;=;||cols&lt;=||threshold&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] marked=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> move(<span class="number">0</span>,<span class="number">0</span>,threshold,rows,cols,marked);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法，每到一个格子就四个方向搜索</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 当前列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threshold 门限值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rows 总行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cols 总列数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> marked 是否访问过</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前格子数(等于1)加上4个方向能访问到的格子数的总和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[] marked)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (checked(row, col, threshold, rows, cols, marked)) &#123;</span><br><span class="line">            marked[row * cols + col] = <span class="keyword">true</span>;</span><br><span class="line">		   <span class="comment">// 递归对四个方向计数，注意四个方向的搜索不是同时发生，</span></span><br><span class="line">            count = move(row - <span class="number">1</span>, col, threshold, rows, cols, marked) +</span><br><span class="line">                    move(row + <span class="number">1</span>, col, threshold, rows, cols, marked) +</span><br><span class="line">                    move(row, col - <span class="number">1</span>, threshold, rows, cols, marked) +</span><br><span class="line">                    move(row, col + <span class="number">1</span>, threshold, rows, cols, marked) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前格子是否超过门限值，以及边界值的判断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true如果当前格子满足条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checked</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">boolean</span>[] marked)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; !marked[row * cols + col] &amp;&amp; digitSum(row) + digitSum(col) &lt;= threshold;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比如数字1234,每位数相加的和将返回10</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 某数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该数字的数位之和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += number % <span class="number">10</span>;</span><br><span class="line">            number /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>checked</code>方法用于判断当前坐标是否满足边界条件，是否超过门限值。</p>
<p>递归方法<code>move</code>是核心，注意递归对四个方向计数时，四个方向的搜索不是同时发生的，一个方向搜索失败（遇到边界或超过门限值）后，退回来进行下一个方向的搜索，回溯法就体现在此。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题18——删除链表的结点</title>
    <url>/likemoves.github.io/2020/04/30/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9818%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目一-O-1-删除链表结点"><a href="#题目一-O-1-删除链表结点" class="headerlink" title="题目一 O(1)删除链表结点"></a>题目一 O(1)删除链表结点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定单向链表的头指针和一个结点指针，定义一个函数在O(<span class="number">1</span>)时间内删除该结点。假设要删除的结点确实在链表中。</span><br></pre></td></tr></table></figure>

<p>常规思路：删除某个结点需要找到该结点的前一个结点，由于单向链表没有指向前一个结点的指针，所以不得不从头指针开始遍历链表。显然时间复杂度为O(n)。实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常规方法，从first开始找到要删除结点的前一个结点，时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode_2</span><span class="params">(Node first, Node toBeDel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(toBeDel==<span class="keyword">null</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(first==toBeDel)&#123;</span><br><span class="line">            first=first.next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node cur=first;</span><br><span class="line">            <span class="keyword">while</span>(cur.next!=toBeDel)&#123;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next=cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试想一个简单例子，下面是一个链表，假设要删除的结点是C。按照上面的思路是从A开始遍历，找到D的前一个结点B后，然后令B.next = D。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D</span><br></pre></td></tr></table></figure>

<p>现在要实现O(1)的复杂度，肯定不能从头结点开始，试试直接从要删除的那个结点入手，因此A、B应该都不会被访问到。如果将D结点中的值(value)覆盖C中的值，就变成了下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; D(new) -&gt; D(original)</span><br></pre></td></tr></table></figure>

<p>此时再讲原来的D删除掉，就变成了下面这样，D(new)其实就是原来的C结点，只是值被替换了而已。这样我们<strong>只需用到被删除结点及其下一个结点就能实现O(1)时间删除</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; B -&gt; D(new)</span><br></pre></td></tr></table></figure>

<p>有一种特殊情况是：<strong>如果被删除结点是链表的最后一个结点</strong>，比如此时要删除D，就不能按照上面的方法来了，因为D的后面没有结点，其值不能被覆盖；此时还得从头结点开始找到D的前一个结点。</p>
<p>更特殊的情况：如果删除的结点既是最后一个结点又是头结点（只有一个结点的链表），那么直接将头结点置空即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleNode</span><span class="params">(Node first,Node toBeDel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first==<span class="keyword">null</span>||toBeDel==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">//要删除的不是最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(toBeDel.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node p=toBeDel.next;</span><br><span class="line">        toBeDel.val=p.val;</span><br><span class="line">        toBeDel.next=p.next;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(first=toBeDel)&#123;</span><br><span class="line">        first=first.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Node cur=first;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=toBeDel)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目二——删除链表中的重复结点"><a href="#题目二——删除链表中的重复结点" class="headerlink" title="题目二——删除链表中的重复结点"></a>题目二——删除链表中的重复结点</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span> 处理后为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>注意重复的结点不保留：并不是将重复结点删除到只剩一个，而是重复结点的全部会被删除。所以链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后不是1-&gt;2-&gt;3-&gt;4-&gt;5。</p>
<p>思路：从头结点开始遍历链表，因为是删除结点，所以需要知道被删除结点的前一个结点，设为pre；只要当前结点和下一结点不为空，就比较它俩，如果相同，删除当前结点及其后所有值和它相同的结点（由于链表有序，所以值相同的结点必然连续）——只需将pre和第一个不和当前结点值相同的结点相连；<strong>特殊情况是头结点就是重复结点，此时头结点也会被删除，因此需要重新定义头结点。</strong>如果当前结点和下一个结点值不同，就更新当前结点和前一个结点pre，继续上述比较….</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeleteDuplicationNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication_2</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前结点的前一个结点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 当前结点</span></span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前节点和下一节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val==cur.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> val=cur.val;</span><br><span class="line">                <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;(cur.val==val))&#123;</span><br><span class="line">                    cur=cur.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//跳出循环得到的是第一个和cur.val不同的节点</span></span><br><span class="line">                <span class="comment">//pre为空说明头结点就是重复结点，因此需要重新设置头结点</span></span><br><span class="line">                 <span class="keyword">if</span> (pre == <span class="keyword">null</span>) pHead = cur;</span><br><span class="line">                    <span class="comment">// 否则cur之前的pre的下一个结点何cur连接</span></span><br><span class="line">                <span class="keyword">else</span> pre.next = cur;</span><br><span class="line">                <span class="comment">// 不相等就像前推进，更新cur和pre</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  pre = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> pHead;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题15--二进制中1的个数</title>
    <url>/likemoves.github.io/2020/04/29/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9815--%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入一个整数，输出该数二进制表示中<span class="number">1</span>的个数。其中负数用补码表示。</span><br></pre></td></tr></table></figure>

<p>容易想到的思路：该数的各位不断和1相与，然后将该数右移1位，直到所有位都比较过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOf1_2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">      	count++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意！上面的代码是错误的！对于非负数来说没有问题，但是当传入负数的时候，由于<code>&gt;&gt;</code>是带符号的右移，对于负数来说高位会以1补位，n永远也不会等于9，因此会出现无限循环。</strong></p>
<p>在Java中右移分两种，一种是上面那样带符号的右移，用<code>&gt;&gt;</code>表示，如果数是正数高位以0补位，如果是负数高位以1补位；还有就是无符号的右移，用<code>&gt;&gt;&gt;</code>表示，不论正负数，统统高位以0补位。因此只需改动将上述程序的<code>&gt;&gt;</code>改成<code>&gt;&gt;&gt;</code>即可通过。</p>
<p>## </p>
<h2 id="右移版本"><a href="#右移版本" class="headerlink" title="右移版本"></a>右移版本</h2><p>下面的程序才是正确的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOf1_2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">      	count++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>## </p>
<h2 id="左移版本"><a href="#左移版本" class="headerlink" title="左移版本"></a>左移版本</h2><p>上面的第一个程序之所以会出现无限循环，是因为我们改变了被输入的数本身。换个角度，我们不改变输入的数，而是通过改变一个变量，那么不管是输入正负数都能得到正确答案。</p>
<p>所以用一个1和输入数的每一位相与，然后将这个1不断<strong>左移</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOf1_1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">  	<span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> ((n &amp; flag)!= <span class="number">0</span>) &#123;</span><br><span class="line">      	count++;</span><br><span class="line">    	&#125;</span><br><span class="line">      	<span class="comment">// 每次改变的只是这个变量，输入的数始终没有被改变过</span></span><br><span class="line">    	flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题10-斐波那契数列</title>
    <url>/likemoves.github.io/2020/04/26/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9810-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现在要求输入一个整数n，请你输出斐波那契数列的第n项。</span><br></pre></td></tr></table></figure>

<h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p>使用递归法  f(n)=f(n-1)+f(n-2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n&lt;=<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>使用迭代法，从底向上的方法：先得到f(0)、f(1)的值，然后根据这两个值计算序列后面的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            b=a+b;</span><br><span class="line">            a=b-a;<span class="comment">// a + b -a -&gt; a = b也就是原来的b赋值给a</span></span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题19--正则表达式匹配</title>
    <url>/likemoves.github.io/2020/05/01/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9819--%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请实现一个函数用来匹配包括<span class="string">'.'</span>和<span class="string">'*'</span>的正则表达式。模式中的字符<span class="string">'.'</span>表示任意一个字符，而<span class="string">'*'</span>表示它前面的字符可以出现任意次（包含<span class="number">0</span>次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串<span class="string">"aaa"</span>与模式<span class="string">"a.a"</span>和<span class="string">"ab*ac*a"</span>匹配，但是与<span class="string">"aa.a"</span>和<span class="string">"ab*a"</span>均不匹配</span><br></pre></td></tr></table></figure>

<p>注意<code>.</code>就是一个字符，而<code>*</code>前面必须有一个字符（可以是<code>.</code>）才有意义，所以可以将<code>x*</code>看成一个整体，其中x表示任意字符。<code>*</code>在匹配时有两种情况，第二个字符是<code>*</code>或者不是。</p>
<ul>
<li><p>第二个字符不是<code>*</code>号。这种情况很简单，第二个字符要么是<code>.</code>要么是一个具体的字符。此时如果第一个字符匹配成功了，只需将模式和文本指针都前进一位。比如<code>ab</code>和<code>ac</code>以及<code>ab</code>和<code>.b</code>，分别对应着字符一样、模式字符为<code>.</code>的情况。<strong>第一个字符匹配失败了，直接就可以得出结论——匹配失败。</strong></p>
</li>
<li><p>第二个字符是<code>*</code>。有几种情况：</p>
<p>1、<code>*</code>匹配0次，比如<code>a*ab</code>和<code>ab</code>匹配，此时需要将模式指针前移2位，文本指针保持不动；</p>
<p>2、<code>*</code>匹配了1次，比如<code>a*b</code>和<code>ab</code>匹配，此时需要将模式指针前移2位，文本指针前移1位；</p>
<p>3、<code>*</code>匹配了多次，比如<code>a*b</code>和<code>aaab</code>匹配，此时需要将模式保持不动，文本指针前移1位；</p>
<p><strong>同样的比较第二个字符的前提是第一个字符已经匹配成功。</strong></p>
</li>
</ul>
<p>我们将长度任意的模式和文本分解成一个或者两个字符，可以用递归地方法写出如下程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReMatch</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">char</span>[] pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||pattern==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matchRecur(str,pattern,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchRecur</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">char</span>[] pattern,<span class="keyword">int</span> s,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == str.length &amp;&amp; p == pattern.length) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">// 模式串比文本串先到末尾，肯定没有匹配成功</span></span><br><span class="line">          <span class="keyword">if</span> (p == pattern.length &amp;&amp; s &lt; str.length) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 第二个字符不是*</span></span><br><span class="line">          <span class="keyword">if</span> ((s &lt; str.length &amp;&amp; str[s] == pattern[p]) || (pattern[p]== <span class="string">'.'</span> &amp;&amp; s &lt; str.length)) &#123;</span><br><span class="line">              <span class="keyword">return</span> matchRecur(str, pattern, s + <span class="number">1</span>, p + <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 第二个字符是*</span></span><br><span class="line">          <span class="comment">// 两种情况，</span></span><br><span class="line">          <span class="comment">// 1、模式和文本都没有到结尾</span></span><br><span class="line">          <span class="comment">// 2、或者文本到了结尾而模式还没有到结尾，此时肯定会调用else分支</span></span><br><span class="line">        <span class="keyword">if</span>(p&lt;pattern.length-<span class="number">1</span>&amp;&amp;pattern[p+<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((s&lt;str.length&amp;&amp;str[s]==pattern[p])||(pattern[p]==<span class="string">'.'</span>&amp;&amp;s&lt;str.length))&#123;</span><br><span class="line">                <span class="keyword">return</span> matchRecur(str,pattern,s,p+<span class="number">2</span>)|| <span class="comment">//*前面的字符出现0次   </span></span><br><span class="line">                    matchRecur(str, pattern, s + <span class="number">1</span>, p+<span class="number">2</span>) ||<span class="comment">//*前面的字符出现1次 </span></span><br><span class="line">                    matchRecur(str,pattern,s + <span class="number">1</span>, p);<span class="comment">//*前面的字符出现多次 </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> matchRecur(str,pattern,s,p+<span class="number">2</span>); <span class="comment">//当前对比的两个字符不同，因此*前出现的字符出现了0次，所以pattern后移两位，str不变</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果匹配的最后两个指针都到达末尾，说明完全匹配上了，返回true。如果模式指针先于文本到达末尾，一定是匹配失败了，举个例子，<code>a*bcd</code>和<code>abcdefg</code>。</p>
<p>接下来的两个if分别是第二个字符为<code>*</code>和不为<code>*</code>的情况。</p>
<ul>
<li>第二个字符为<code>*</code>。在保证第一个字符已经匹配上的情况下，<code>*</code>可以有三种匹配方式，有任一种方式匹配成功即可，所以return语句中用的是<code>||</code>。</li>
<li>第二个字符不为<code>*</code>。当第一个字符已经匹配上的情况下，直接将模式和文本的指针前移一位，即比较下一个字符。</li>
</ul>
<p>如果不是上面的情况（比如第一个字符就匹配失败了），返回false。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题16--数值的整数次方</title>
    <url>/likemoves.github.io/2020/04/29/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9816--%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个<span class="keyword">double</span>类型的浮点数base和<span class="keyword">int</span>类型的整数exponent。求base的exponent次方。不得使用库函数直接实现，无需考虑大数问题。</span><br></pre></td></tr></table></figure>

<h2 id="解法-连乘"><a href="#解法-连乘" class="headerlink" title="解法 连乘"></a>解法 连乘</h2><p>注意要考虑次幂为负数的情况。由于负次幂等于base的正次幂的倒数，所以取绝对值直接计算正次幂的情况就行，最后再根据exponent是否为负决定取不取倒数。当base为0时候，结果和次幂无关（都为0，假设0的非正数次幂都为0，因为它们在数学中并没有定义），所以把base == 0的情况单独抽出来直接返回。算法采用了连乘，时间复杂度是O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base     基数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exponent 次幂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> base^exponent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">power_2</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> positiveExponent=Math.abs(exponent);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;positiveExponent;i++)&#123;</span><br><span class="line">            result*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent&lt;<span class="number">0</span>?<span class="number">1</span>/result:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法-快速幂"><a href="#解法-快速幂" class="headerlink" title="解法 快速幂"></a>解法 快速幂</h2><p>我们已知 2^3  求 2^6,不就是 2^3 * 2^3嘛。快速幂就是这个原理。</p>
<p>遇到奇数怎么办？2 ^ 5??  就是 2 * 2 ^ 4 。</p>
<p>所以这就是快速幂的基本思路求a ^ b</p>
<p>1）当b是奇数时，那么有 a^b = a * a^*(b-1)</p>
<p>2）当b是偶数时，那么有 a^b = a^(b/2) * a^(b/2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Power</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非递归。推荐的做法，复杂度O(lg n)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base,<span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(base==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> positiveExponent=Math.abs(exponent);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// positiveExponent &amp; 1这句是判断奇数的</span></span><br><span class="line">            <span class="keyword">if</span>((positiveExponent&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                result*=base;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            base*=base;</span><br><span class="line">            <span class="comment">//右移1位等于除以2</span></span><br><span class="line">            positiveExponent=positiveExponent&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent&lt;<span class="number">0</span>?<span class="number">1</span>/result:result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题22--链表中倒数第k个结点</title>
    <url>/likemoves.github.io/2020/05/03/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9822--%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入一个链表，输出该链表中倒数第k个结点。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>链表长度为n，倒数第k个结点，即为正数第n-k个结点</p>
<p>采用双指针方法，第一个指针先走k步，之后两个指针同时移动，只要第一个指针为空，第二个指针为k个结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindKthToTailInLinkedList</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(k&lt;=<span class="number">0</span>||head==<span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         </span><br><span class="line">         ListNode a=head;</span><br><span class="line">         ListNode b=head;</span><br><span class="line">         <span class="comment">//第一个指针先移动k步</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(a.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             a=a.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//然后两个指针同时移动到末尾</span></span><br><span class="line">         <span class="keyword">while</span>(a.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             a=a.next;</span><br><span class="line">             b=b.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> b;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题2--单例模式</title>
    <url>/likemoves.github.io/2020/04/22/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%982--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式需要满足如下规则："><a href="#单例模式需要满足如下规则：" class="headerlink" title="单例模式需要满足如下规则："></a>单例模式需要满足如下规则：</h1><ul>
<li>构造函数私有化（private），使得不能直接通过new的方式创建实例对象；</li>
<li>通过new在代码内部创建一个（唯一）的实例对象；</li>
<li>定义一个public static的公有静态方法，返回上一步中创建的实例对象；由于在静态方法中，所以上一步的对象也应该是static的。</li>
</ul>
<p>根据这个规则，我们可以写出如下模式，这种模式又被称为<strong>饿汉模式</strong>。不管用不用得到，先new出来再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap2;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式，饿汉模式，不管为不为空，先直接new一个出来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 饿汉模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonImp singletonImp = <span class="keyword">new</span> SingletonImp();</span><br><span class="line">    <span class="comment">// 私有化（private）该类的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonImp <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonImp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SingletonImp.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和饿汉模式对应的称为<strong>懒汉模式</strong>，实例为空时才new出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式，懒汉模式，为空才new</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonImp2 singletonImp2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 懒汉模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonImp2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonImp2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            singletonImp2 = <span class="keyword">new</span> SingletonImp2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonImp2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SingletonImp2.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码有很多待改进的地方。下面一步步来优化。</p>
<p>## </p>
<h2 id="能在多线程下工作，但效率不高"><a href="#能在多线程下工作，但效率不高" class="headerlink" title="能在多线程下工作，但效率不高"></a>能在多线程下工作，但效率不高</h2><p>懒汉模式在单线程下可以很好地工作，但是如果多个线程同时执行到<code>if (singletonImp2 == null)</code>这句判空操作，那么将会同时创建多个实例对象，所以为了保证在多线程下实例只被创建一次，需要加同步锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SingletonImp2在多线程中，如果多个线程同时运行到if (singletonImp2 == null) 就会创建多个对象</span></span><br><span class="line"><span class="comment"> * 所以加上同步锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonImp3 singletonImp3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 懒汉模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonImp3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同步锁的加入</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SingletonImp3.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (singletonImp3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                singletonImp3 = <span class="keyword">new</span> SingletonImp3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonImp3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步锁只在实例第一次被创建时候才加上"><a href="#同步锁只在实例第一次被创建时候才加上" class="headerlink" title="同步锁只在实例第一次被创建时候才加上"></a>同步锁只在实例第一次被创建时候才加上</h2><p>上面的代码在每次调用方法时候都会加锁（即使实例早已被创建），我们知道加锁是很耗时的，实际上我们主要是为了保证在对象为null时，只new出一个实例，只在这个时候加锁就够了。基于这点，改进如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SingletonImp3中每次调用getInstance都会加同步锁，而加锁是一个很耗时的过程</span></span><br><span class="line"><span class="comment"> * 实际上加锁只需要在第一次创建对象时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonImp4 singletonImp4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonImp4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次创建时才加锁</span></span><br><span class="line">        <span class="keyword">if</span> (singletonImp4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonImp4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonImp4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonImp4 = <span class="keyword">new</span> SingletonImp4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonImp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>上述的SingletonImp4类变量是没有用volatile关键字修饰的，会导致这样一个问题：<br> <strong>在线程执行，代码读取到singletonImp4不为null时，singletonImp4引用的对象有可能还没有完成初始化。</strong><br> 主要的原因是重排序。<strong>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</strong><br> 第7行的代码创建了一个对象，这一行代码可以分解成3个操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory = allocate();　　// 1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory);　// 2：初始化对象</span><br><span class="line">instance = memory;　　// 3：设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure>

<p>根源在于代码中的2和3之间，可能会被重排序。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory = allocate();　　// 1：分配对象的内存空间</span><br><span class="line">instance = memory;　　// 3：设置instance指向刚分配的内存地址</span><br><span class="line">// 注意，此时对象还没有被初始化！</span><br><span class="line">ctorInstance(memory);　// 2：初始化对象</span><br></pre></td></tr></table></figure>

<p>这在单线程环境下是没有问题的，但在多线程环境下会出现问题：<br> B线程会看到一个还没有被初始化的对象。<br> A2和A3的重排序不影响线程A的最终结果，但会导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象。<br> <strong>所以只需要做一点小的修改（把singletonImp4声明为volatile型），就可以实现线程安全的延迟初始化。</strong>因为被volatile关键字修饰的变量是被禁止重排序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SingletonImp3中每次调用getInstance都会加同步锁，而加锁是一个很耗时的过程</span></span><br><span class="line"><span class="comment"> * 实际上加锁只需要在第一次创建对象时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonImp4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonImp4 singletonImp4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonImp4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  SingletonImp4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次创建时才加锁</span></span><br><span class="line">        <span class="keyword">if</span> (singletonImp4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonImp4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonImp4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonImp4 = <span class="keyword">new</span> SingletonImp4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> singletonImp4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题21--调整数组的顺序使奇数位于偶数前面</title>
    <url>/likemoves.github.io/2020/05/02/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9821--%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span><br></pre></td></tr></table></figure>

<p>如果可以使用额外的空间，这道题不难。O(n)的空间和O(n)的时间复杂度。思路很简单：</p>
<ul>
<li>第一次遍历，将奇数存入辅助数组中；</li>
<li>第二次遍历，将偶数存入数组中；</li>
<li>辅助数组的元素覆盖原数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReOrderArray</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> len=array.length;</span><br><span class="line">         <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(isOdd(array[i]))</span><br><span class="line">                 temp[p++]=array[i];</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(!isOdd(array[i]))</span><br><span class="line">                 temp[p++]=array[i];</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">             array[i]=temp[i];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isOdd</code>方法判断一个数是不是奇数，用了“与”运算，<strong>任何奇数的二进制表示的最低位必然是1</strong>。通常“与”运算的效率比<code>val % 2</code>要高。</p>
<h2 id="拓展-相对位置可以改变的情况"><a href="#拓展-相对位置可以改变的情况" class="headerlink" title="拓展 相对位置可以改变的情况"></a>拓展 相对位置可以改变的情况</h2><p>如果将题目条件放宽，所有奇数在偶数之前就可以了，不要求保持原来的相对位置。则本题可以用一次遍历完成。思路如下：</p>
<ul>
<li>设置两个指针，一个指针pBegin指向数组第一个元素，一个指针pEnd指向数组的最后一个元素；</li>
<li>当pBegin &lt; pEnd时：pBegin指针不断右移，直到遇到某个偶数为止；同样的，pEnd不断左移，直到遇到某个奇数为止。</li>
<li>若此时pBegin &lt; pEnd：交换两个元素，因此排在前面的奇数被交换到了后面。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pBegin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pEnd=array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(pBegin&lt;pEnd)&#123;</span><br><span class="line">        <span class="keyword">while</span>(isOdd(array[pBegin]))&#123;</span><br><span class="line">            pBegin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!isOdd(array[pEnd]))&#123;</span><br><span class="line">            pEnd--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pBegin&lt;pEnd)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=array[pBegin];</span><br><span class="line">            array[pBegin]=array[pEnd];</span><br><span class="line">            array[pEnd]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题27--对称的二叉树</title>
    <url>/likemoves.github.io/2020/05/04/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9827--%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</span><br></pre></td></tr></table></figure>

<p>对称的二叉树，结点数必然是奇数，特别地定义空树也是对称的。当对称树的结点值不是完全相同时比较好处理，但是当结点值全部一样时候可能会有些麻烦。我们要实现一个通用的算法，使得对于这种特殊情况也能正确处理。</p>
<p>要保证树是对称的，左子树最左边的结点要和右子树最右边的结点值相同…左子树的右子结点要和右子树的左子结点值相同，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root1.left == root2.right;</span><br><span class="line">root1.right == root2.left;</span><br></pre></td></tr></table></figure>

<p>这是关键，理解了上面说的，可以很轻松地写出下面的代码。</p>
<h2 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricalTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *递归实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricalRecur</span><span class="params">(TreeNode pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot.left,pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">if</span>(root1.val!=root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> isSymmetrical(root1.left,root2.right)&amp;&amp;</span><br><span class="line">          isSymmetrical(root1.right,root2.left)</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h2><p>思路和上面一样，非递归实现需要用到两个队列。<strong>队列A专门存入左子树，队列B专门存入右子树。</strong></p>
<p>入列时，<strong>将左子树的左子结点和右子树的右子结点分别存入队列A和队列B，紧接着还要将左子树的右子结点和右子树的左子结点分别存入队列A和队列B。</strong></p>
<p>出列时，两个队列同时出列一个元素，根据存入的顺序，这两个出列元素就是左子树的左子结点和右子树的右子结点，或者左子树的右子结点和右子树的左子结点。之后对这两个元素进行比较，比较操作和上面递归版本的一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricalTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非递归，队列实现(栈也可以实现)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queueA=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queueB=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queueA.offer(pRoot.left);</span><br><span class="line">        queueB.offer(pRoot.right);</span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queueA.isEmpty() &amp;&amp; !queueB.isEmpty())&#123;</span><br><span class="line">            left = queueA.poll();</span><br><span class="line">            right = queueB.poll();</span><br><span class="line">              <span class="comment">// 两个都空跳过</span></span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 只有一个空，不对称</span></span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 两个都不空，比较值</span></span><br><span class="line">            <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 两两对称的加入</span></span><br><span class="line">            <span class="comment">// 左孩子的左孩子，右孩子的右孩子</span></span><br><span class="line">            queueA.offer(left.left);</span><br><span class="line">            queueB.offer(right.right);</span><br><span class="line">            <span class="comment">// 左孩子的右孩子，右孩子的左孩子</span></span><br><span class="line">            queueA.offer(left.right);</span><br><span class="line">            queueB.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题26--树的子结构</title>
    <url>/likemoves.github.io/2020/05/04/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9826-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br></pre></td></tr></table></figure>

<p>首先我们要在二树A中找到和树B根结点值一样的结点R，结点R可能有多个，因为树A中的结点值可能不止一个与树B的根结点值相同。对于每个结点R，其子树都有可能是树A的子结构，因此<strong>只要还未在树A中找到一个子结构，就要继续遍历树A判断其他R结点。</strong></p>
<p>对于某一个R结点，我们要求根结点R的左子结点、右子结点和树B根结点的左子结点、右子结点分别相等（值相等），而且R的子结点的左右子结点也要和B的子结点值相等……直到和树B的叶子结点也相等才说树A包含树B。这是个递归的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSubTree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="keyword">null</span>&amp;&amp;root2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="comment">// 根结点相同，紧接着判断子树结构一样不</span></span><br><span class="line">            <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">                <span class="comment">// 如果子树结构一样，返回true，也不用再对树A遍历了</span></span><br><span class="line">                result=doesTree1HaveTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 当前根结点不同，或者即使根结点相同子树结构不同，还需继续遍历，递归判断左右子树</span></span><br><span class="line">            <span class="keyword">if</span>(！result)&#123;</span><br><span class="line">                result=hasSubTree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(！result)&#123;</span><br><span class="line">                result=hasSubTree(root1.right,root2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doesTree1HaveTree2</span><span class="params">(TreeNode node1,TreeNode node2)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// node2到达叶子结点的左右子结点了都还相等，说明是树1的子结构</span></span><br><span class="line">        <span class="keyword">if</span>(node2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node1==<span class="keyword">null</span>&amp;&amp;node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node1.val==node2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> doesTree1HaveTree2(node1.left,node2.left)</span><br><span class="line">                &amp;&amp;doesTree1HaveTree2(node1.right,node2.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点要注意，下面<strong>两个if的判断顺序不可颠倒</strong>。如果node2没有左右子结点了，说明叶子结点也和树B比较过了且相等，说明树A包含树B，因此返回true。如果第一个if没通过，到第二个if，说明node2还没到叶子结点，但现在node1却先于树B到达了叶子结点，说明树A该处的子树不包含树B，需要继续遍历树A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ node2到达叶子结点的左右子结点了都还相等，说明是树<span class="number">1</span>的子结构</span><br><span class="line"><span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果node2没有到叶子结点的左右子结点，而node1先到了说明树2比树1还大，返回false</span></span><br><span class="line"><span class="keyword">if</span> (node1 == <span class="keyword">null</span>&amp;&amp;node2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题25--合并两个有序链表</title>
    <url>/likemoves.github.io/2020/05/03/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9825--%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</span><br></pre></td></tr></table></figure>

<h2 id="解法一：非递归排序"><a href="#解法一：非递归排序" class="headerlink" title="解法一：非递归排序"></a>解法一：非递归排序</h2><p>设置两个指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoOrderedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非递归实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list1 有序链表1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list2 有序链表2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 合并后的有序链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        ListNode p1=list1;</span><br><span class="line">        ListNode p2=list2;</span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 两个链表中哪个头结点的值小，就以此作为新链表的头结点</span></span><br><span class="line">        <span class="keyword">if</span> (p1.val &lt;= p2.val) &#123;</span><br><span class="line">            head = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="keyword">null</span>||p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">// list1取完了，直接将p2全部插入到新链表后面，p2 =null表示添加完毕后立即终止</span></span><br><span class="line">            <span class="keyword">if</span>(p1==<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next=p2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2==<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next=p1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p1.val&lt;p2.val)&#123;</span><br><span class="line">                cur.next=p1;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">                p1=p1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next=p2;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">                p2=p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：递归版本"><a href="#解法二：递归版本" class="headerlink" title="解法二：递归版本"></a>解法二：递归版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeTwoOrderedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeRecur</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode mergedHead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">            mergeHead=list1;</span><br><span class="line">            mergehead.next=mergeRecur(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mergedHead = list2;</span><br><span class="line">            mergedHead.next = mergeRecur(list1, list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> mergedHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题23--链表中环的入口结点</title>
    <url>/likemoves.github.io/2020/05/03/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9823--%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一个链表中包含环，请找出该链表的环的入口结点。</span><br></pre></td></tr></table></figure>

<h2 id="解法一：利用set或者map"><a href="#解法一：利用set或者map" class="headerlink" title="解法一：利用set或者map"></a>解法一：利用set或者map</h2><p>我们知道Set中不能存放相同的元素。当在遍历链表的过程中，不断将当前结点放入Set中，当<strong>第一次add失败</strong>时，说明这个结点之前已经访问过了，这个结点刚好就是环的入口结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryNodeOfLoop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用Set不可添加重复元素的性质</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">entryNodeOfLoop_set</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ListNode&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode a=pHead;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(a))&#123;</span><br><span class="line">              <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            a=a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Map，思路同Set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">entryNodeOfLoop_map</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;ListNode, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ListNode cur = pHead;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(cur)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(cur, <span class="keyword">true</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>参考：<a href="https://www.cnblogs.com/darlinFly/p/9335380.html" target="_blank" rel="noopener">https://www.cnblogs.com/darlinFly/p/9335380.html</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题3--数组中的重复数字</title>
    <url>/likemoves.github.io/2020/04/22/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%983--%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2或者3。</p>
<h2 id="解法一：排序后相邻元素两两比较"><a href="#解法一：排序后相邻元素两两比较" class="headerlink" title="解法一：排序后相邻元素两两比较"></a>解法一：排序后相邻元素两两比较</h2><p>先对数组排序，如果有重复元素排序后将会相邻。然后相邻元素两两比较，有相等的情况就找到了重复数字。排序一个长度为n的数组时间复杂度为O(nlg n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate2</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Arrays.sort(numbers);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] == numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：利用set集合判定重复数组"><a href="#解法二：利用set集合判定重复数组" class="headerlink" title="解法二：利用set集合判定重复数组"></a>解法二：利用set集合判定重复数组</h2><p>1.初始化集合为空集合，重复的数字 repeat = -1</p>
<p>2.遍历数组中的每个元素：</p>
<p>​     2.1将该元素加入集合中，判断是否添加成功<br>​     2.2如果添加失败，说明该元素已经在集合中，因此该元素是重复元素，将该元素的值赋给 repeat，并结束遍历</p>
<p>3.返回 repeat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> repeat = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂性分析</strong></p>
<p>时间复杂度：O(n)。</p>
<p>​        遍历数组一遍。使用哈希集合（HashSet），添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)。</p>
<p>空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题30--包含min方法的栈</title>
    <url>/likemoves.github.io/2020/05/05/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9830--%E5%8C%85%E5%90%ABmin%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。要求push、pop、min方法的时间复杂度都为O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>考虑到要求我们用O(1)的时间复杂度。可以<strong>考虑用空间换时间</strong>，试试使用辅助空间。</p>
<p><strong>定义一个栈stackMin，专门用于存放当前最小值。</strong></p>
<ul>
<li>存放数据的stack存入当前元素，如果即将要存入的元素比当前最小元素还小，stackMin存入这个新的最小元素；否则，stackMin将当前最小元素再次存入。</li>
<li>stack出栈时，stackMin也出栈。</li>
</ul>
<p>反正就是入栈时，两个栈都有元素入栈；出栈时，两个栈都弹出一个元素。这两个栈总是同步进出栈的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackIncludeFuncMin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     <span class="comment">// 辅助栈，用于存储当前最小值</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; stackMin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(stackMin.isEmpty()||node&lt;stackMin.peel())&#123;</span><br><span class="line">            stackMin.push(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stackMin.push(stackMin.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">publick <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stackMin.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stack is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题28--二叉树的镜像</title>
    <url>/likemoves.github.io/2020/05/04/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9828--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">操作给定的二叉树，将其变换为原二叉树的镜像。</span><br></pre></td></tr></table></figure>

<p>思路很简单：从根结点开始，先交换根结点的左右子结点（子树），之后再对子结点进行同样的操作，一直往下直到树的叶子结点。叶子结点没有左右子结点，所以到这里停止交换。</p>
<h2 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MirrorTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirrorRecur</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        exchangeChildren(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchangeChildren</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span>&amp;&amp;node.right==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//交换两个子节点</span></span><br><span class="line">        TreeNode temp=node.left;</span><br><span class="line">        node.left=node.right;</span><br><span class="line">        node.right=temp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) exchangeChildren(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) exchangeChildren(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个if如果根结点为空，就直接返回；第二个if是说如果遇到了叶子结点，无需操作直接返回。</p>
<h2 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h2><p>我们发现要保证以<strong>从上到下</strong>的顺序交换左右子树，即先交换树的父结点，再交换父结点的两个子结点。<strong>除了前序遍历，层序遍历也可以实现。</strong>下面来实现两种遍历的非递归版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MirrorTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非递归版本,层序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="comment">// 交换两个子结点</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span> || node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                TreeNode temp = node.left;</span><br><span class="line">                node.left = node.right;</span><br><span class="line">                node.right = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非递归，前序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirror_preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">           LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">          <span class="comment">// 当前结点不为空，或者为空但有可以返回的父结点（可以进行pop操作）都可以进入循环</span></span><br><span class="line">         <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">              <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                <span class="comment">// 交换两个子结点</span></span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span> || root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TreeNode temp = root.left;</span><br><span class="line">                    root.left = root.right;</span><br><span class="line">                    root.right = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>前序遍历是深度优先搜索，所以用到了栈；而层序遍历是广度优先搜索，用到队列。</strong></p>
<p>前序遍历是只要某结点还有左子结点，就不断压入栈中，直到没有左子结点时弹栈，接着将根结点指向右子树重复上述过程。</p>
<p>层序遍历很简单，先将根结点入列，然后弹出根结点将根结点子结点入列，不断重复上述过程直到队列为空。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题31--栈的压入、弹出序列</title>
    <url>/likemoves.github.io/2020/05/06/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9831--%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列</span><br></pre></td></tr></table></figure>

<p>题目只是给出了两个序列，并没有栈，所有我们需要自己定义<strong>一个辅助栈</strong>帮助我们模拟入栈出栈过程。</p>
<p>需要用到一个指针表示在出栈序列中的当前出栈元素。每次入栈一个元素，之后立刻和出栈序列中当前出栈元素对比，若相同就弹出刚压入的元素、同时当前弹出元素指针前移。之后还要继续比较，如果栈顶还和当前弹出元素相同则需要接着弹出。否则压入入栈序列中的下一个元素。</p>
<p>正常情况下，如果出栈顺序正确，当入栈序列中的元素都被压入后，辅助栈能按照出栈序列全部弹出。<strong>如果当元素都被压入后，辅助栈没能弹出所有元素（不为空），说明出栈顺序是错误的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackPopOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 辅助栈</span></span><br><span class="line">        LinkedList&lt;Integer&gt; stackAux = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pushA.length;i++) &#123;</span><br><span class="line">            <span class="comment">// 按照入栈序列依次压入辅助栈中</span></span><br><span class="line">            stackAux.push(pushA[i]);</span><br><span class="line">            <span class="comment">// 每入栈一次和出栈序列比较，如果栈顶和当前出栈元素相同，则弹出同时当前弹出元素指针前移；</span></span><br><span class="line">            <span class="comment">// 如果下一个栈顶元素还和当前弹出元素相同，继续弹出</span></span><br><span class="line">            <span class="keyword">while</span> (!stackAux.isEmpty() &amp;&amp; stackAux.peek() == popA[popIndex]) &#123;</span><br><span class="line">                stackAux.pop();</span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果出栈顺序正确，模拟一次进出栈后，辅助栈应该为空。不为空说明序列不正确</span></span><br><span class="line">        <span class="keyword">return</span> stackAux.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如入栈顺序是<code>[1, 2, 3, 4, 5]</code>举个出栈顺序正确的例子<code>[4, 5, 3, 2, 1]</code>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>辅助栈</th>
<th>出栈</th>
</tr>
</thead>
<tbody><tr>
<td>压入1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>压入2</td>
<td>1, 2</td>
<td></td>
</tr>
<tr>
<td>压入3</td>
<td>1, 2, 3</td>
<td></td>
</tr>
<tr>
<td>压入4</td>
<td>1, 2 ,3 ,4</td>
<td></td>
</tr>
<tr>
<td>弹出4</td>
<td>1,2 ,3</td>
<td>4</td>
</tr>
<tr>
<td>压入5</td>
<td>1,2, 3 ,5</td>
<td></td>
</tr>
<tr>
<td>弹出5</td>
<td>1, 2, 3</td>
<td>5</td>
</tr>
<tr>
<td>弹出3</td>
<td>1,2</td>
<td>3</td>
</tr>
<tr>
<td>弹出2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>弹出1</td>
<td></td>
<td>1</td>
</tr>
</tbody></table>
<p>再举个错误的出栈顺序的例子<code>[4,3,5,1,2]</code></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>辅助栈</th>
<th>出栈</th>
</tr>
</thead>
<tbody><tr>
<td>压入1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>压入2</td>
<td>1, 2</td>
<td></td>
</tr>
<tr>
<td>压入3</td>
<td>1, 2, 3</td>
<td></td>
</tr>
<tr>
<td>压入4</td>
<td>1, 2 ,3 ,4</td>
<td></td>
</tr>
<tr>
<td>弹出4</td>
<td>1,2 ,3</td>
<td>4</td>
</tr>
<tr>
<td>弹出3</td>
<td>1, 2</td>
<td>3</td>
</tr>
<tr>
<td>压入5</td>
<td>1, 2, 5</td>
<td></td>
</tr>
<tr>
<td>弹出5</td>
<td>1, 2</td>
<td>5</td>
</tr>
<tr>
<td>弹出2</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>弹出1</td>
<td></td>
<td>1</td>
</tr>
</tbody></table>
<p>最后只剩两个元素1, 2时，由于2在栈顶1在栈底，不能先弹出1在弹出2，所以这个出栈顺序是错误的。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题33--二叉搜索树的后序遍历序列</title>
    <url>/likemoves.github.io/2020/05/06/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9833--%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</span><br></pre></td></tr></table></figure>

<p>注意是二叉搜索（查找）树，特点是父结点的左子树都比父结点小，父结点的右子树都比父结点大。因此其后序遍历的序列有一定的规律：</p>
<ul>
<li>序列最后一位必然是树的根结点；</li>
<li>序列前部分是根结点的左子树，后部分是根结点的右子树；具体来说：将序列各个元素和和序列最后一位的根结点比较，序列前部分都小于根结点的值，这部分子序列是左子树；序列后部分的值都大于根结点，这部分子序列是右子树；</li>
</ul>
<p><strong>根据二叉树的递归结构，可以将树分成左子树、根结点、右子树，对于每棵子树可以继续按照上面的方式分下去。于是原序列可被划分为若干个子序列，每个子序列表示一棵子树。</strong></p>
<p>比如对于一个序列{5, 7, 6, 9, 11, 10, 8}，根结点为8，{5, 7, 6}因为都小于8所以是8的左子树，而{9,  11, 10}都大于8所以是8的右子树，而对于子树{5, 7, 6}，最后一个元素6是根结点…..以此类推。</p>
<p>因此解决本题：首先要从序列中获得根结点，然后找到序列中左右子树的分界线，由此将序列分成三部分：左子树、根结点、右子树。再对左右子树进行递归操作。递归终止的条件是：上层结点只有左子树或只有右子树，或者当前结点是叶子结点，即没有子结点。这两种情况都应该返回true（可以画图举几个例子模拟下，理解为什么）</p>
<p>思路清晰后，程序就好写了，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VeritySeqOfSearchBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSearchBST(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSearchBST</span><span class="params">(<span class="keyword">int</span>[] seq, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// begin比end大说明上层结点没有左子树或者右子树，begin == end说明该本层结点没有子树，无需比较了</span></span><br><span class="line">        <span class="comment">// 这两种情况都应该返回true</span></span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> rootVal=seq[end];</span><br><span class="line">        <span class="comment">//左子树都比root小</span></span><br><span class="line">        <span class="keyword">int</span> i=begin;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;end&amp;&amp;seq[i]&lt;rootVal)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了左右子树的分界，[begin, i-1]为左子树，[i, end -1]是右子树</span></span><br><span class="line">         <span class="keyword">int</span> boundary = i;</span><br><span class="line">         <span class="keyword">while</span> (i &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 右子树中还存在比root小的说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (seq[i] &lt; rootVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左右子树必须同时都是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> isSearchBST(seq, begin, boundary - <span class="number">1</span>) &amp;&amp; isSearchBST(seq, boundary, end - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>递归中主要判断某个序列或者子序列构成的树是不是二叉搜索树，在定下来左右子树的分界线后，如果右子树中还存在比root小的说明该子树不是二叉搜索树，直接返回false；注意必须满足<strong>左右子树都是二叉搜索树</strong>。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题32--从上到下打印二叉树</title>
    <url>/likemoves.github.io/2020/05/06/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9832--%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不分行，从上往下打印出二叉树的每个节点，同层节点从左至右打印。即层序遍历</span><br></pre></td></tr></table></figure>

<h2 id="不分行，层序遍历"><a href="#不分行，层序遍历" class="headerlink" title="不分行，层序遍历"></a>不分行，层序遍历</h2><p>二叉树的层序遍历其实就是广度优先搜索的简单版。使用队列实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将根结点入列，出列并打印然后按照从左到右的顺序依次将该结点的子结点入列….不断重复这个过程直到队列为空。</p>
<h2 id="分行打印"><a href="#分行打印" class="headerlink" title="分行打印"></a>分行打印</h2><p>  和上面类似，现在要求每打印完树的一层需要换行。核心代码其实和上面一样。只是为了确定在何时需要换行操作，<strong>需要用两个变量记录当前层还没有被打印的结点数、下层总结点数。每打印完一行后需要换行，接下来要打印下一层了，所以用下层总结点数更新当前层未被打印的结点数，同时下层总结点数重置为0，准备进行下一层的计数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTreeEveryLayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEveryLayer</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// 下一层的结点数</span></span><br><span class="line">        <span class="keyword">int</span> nextLevel = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 本层还有多少结点未打印,因为目前只有根结点没被打印所以初始化为1</span></span><br><span class="line">        <span class="keyword">int</span> toBePrinted = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 每打印一个，减1</span></span><br><span class="line">            toBePrinted--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">              	<span class="comment">// 每一个元素加入队列，加1</span></span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">                nextLevel++;</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">// 本层打印完毕</span></span><br><span class="line">            <span class="keyword">if</span> (toBePrinted == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println();</span><br><span class="line">                toBePrinted = nextLevel;</span><br><span class="line">                nextLevel = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Z字形打印二叉树"><a href="#Z字形打印二叉树" class="headerlink" title="Z字形打印二叉树"></a>Z字形打印二叉树</h2><p>举个例子，下面的二叉树，打印顺序是1 3 2 4 5 6 7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 	   1</span><br><span class="line">	 /   \</span><br><span class="line">  2      3</span><br><span class="line"> / \    / \</span><br><span class="line">4   5  6   7</span><br></pre></td></tr></table></figure>

<p>先搞清楚要求：根结点先被打印，然后从右往左打印第二行，接着从左往右打印第三行…以此类推，<strong>总之偶数层就从右往左打印，奇数行就从左到右打印</strong>。依然需要某种数据结构来存放结点，栈可以满足我们的打印顺序：当前层为奇数层时，按照<strong>从左到右</strong>的顺序将下层结点（偶数层）压入栈中，出栈的时候就是从右往左打印偶数层了；当前层是偶数层时，按照<strong>从右到左</strong>的顺序将下层结点（奇数层）压入栈中，由于此时先出栈的是偶数层最右边的结点，所以可以保证下层最右边的结点被压到了栈底，而最左边的结点位于栈顶，出栈的时候就是从左往右打印奇数层了…如此反复交替。</p>
<p>为了达到上述的交替效果，需要用到<strong>两个栈，一个栈stackOdd存奇数层的结点，另一个栈stackEven存偶数层的结点。</strong></p>
<ul>
<li>奇数层，其下层的结点按左到右的顺序入栈</li>
<li>偶数层，其下层的结点按右到左的顺序入栈</li>
</ul>
<p>奇偶层顺序是固定的，即根结点是奇数层，则奇偶顺序是“奇偶奇偶….“</p>
<p>stackOdd存放的是某一奇数层的全部结点，<strong>stackOdd不为空说明当前层是奇数层，全部弹出后为空，该处理下一层了;因此当stackOdd为空时当前层必然是偶数层</strong>，stackOdd就这样不断为空，不为空…交替，正好反映了当前层是奇数层还是偶数层，进而采取不同的结点存入顺序即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTreeZ</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeZ</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stackOdd = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stackEven = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stackOdd.push(root);</span><br><span class="line">        <span class="comment">// 只要还有一个栈不为空就继续</span></span><br><span class="line">        <span class="keyword">while</span> (!stackOdd.isEmpty() || !stackEven.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stackOdd.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//当前层是奇数层  </span></span><br><span class="line">                <span class="keyword">while</span> (!stackOdd.isEmpty()) &#123;</span><br><span class="line">                    TreeNode node = stackOdd.pop();</span><br><span class="line">                    System.out.println((node.val + <span class="string">" "</span>));</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stackEven.push(node.left);</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stackEven.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stackEven.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//当前层是偶数层</span></span><br><span class="line">                    TreeNode node = stackEven.pop();</span><br><span class="line">                    System.out.println((node.val + <span class="string">" "</span>));</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) stackOdd.push(node.right);</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) stackOdd.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题35--复杂链表的复制</title>
    <url>/likemoves.github.io/2020/05/06/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9835--%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span><br></pre></td></tr></table></figure>

<p>复杂链表的定义如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> label;</span><br><span class="line">   RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">   RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">     <span class="keyword">this</span>.label = label;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法是，插入、连接、拆分三步法。</p>
<ul>
<li>插入：在原始链表的每个结点后插入一个值和它一样的新结点；则有<code>oriNode.next == cloneNode</code>这样的关系；</li>
<li>连接随机结点：遍历插入新结点后的链表，在访问原始链表中的那些结点时，判断其是否有随机结点，有的话<code>cloneNode.random = oriNode.random.next</code>这里<code>oriNode.random.next</code>表示原始链表随机结点的下一个结点，其实就是复制链表的随机结点。</li>
<li>拆分原始链表和复制链表：将奇数结点相连就是原始链表，将偶数结点相连就是我们想要的复制链表。返回复制链表的头结点即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head</span></span><br><span class="line"><span class="comment"> * （注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> label;</span><br><span class="line">        RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">        RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、为每个结点的next插入一个和该结点的值一样的结点</span></span><br><span class="line"><span class="comment">     * 2、设置每个复制结点的random结点</span></span><br><span class="line"><span class="comment">     * 3、将链表拆分，返回复制链表的头结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pHead 原链表头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 复制链表的头结点，不可直接返回原链接结点的引用，必须使用new出来的RandomListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        copyNode(pHead);</span><br><span class="line">        setCloneRandomNode(pHead);</span><br><span class="line">        <span class="keyword">return</span> splitList(pHead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 为每个结点的next插入一个和该结点的值一样的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copyNode</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        RandomListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">            cloneNode.next = cur.next;</span><br><span class="line">            cur.next = cloneNode;</span><br><span class="line"></span><br><span class="line">            cur = cloneNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置每个复制结点的random</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCloneRandomNode</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        RandomListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cloneNode.random = cur.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cloneNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 拆分链表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RandomListNode <span class="title">splitList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        RandomListNode cur = head;</span><br><span class="line">        RandomListNode cloneHead = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloneNode = cur.next;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cloneNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cloneNode.next = cloneNode.next.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题37--序列化二叉树</title>
    <url>/likemoves.github.io/2020/05/08/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9837--%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请实现两个函数，分别用来序列化和反序列化二叉树。</span><br></pre></td></tr></table></figure>

<p>遇到空指针可以也用一个特殊的字符表示，比如“#”，<strong>这样前序遍历序列就可以表示唯一的一棵二叉树了。\</strong>对于空指针也用一个字符表示，可称这样的序列为*<em>扩展序列*</em>。而二叉树的建立，必须先要建立根结点再建立左右子树（root为空怎么调用root.left是吧），所以必须前序建立二叉树，那么序列化时也应该用前序遍历，保证了根结点在序列前面。</p>
<p>不能使用中序遍历，因为<strong>中序扩展序列</strong>是一个无效的序列，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  A      B</span><br><span class="line"> / \      \</span><br><span class="line">B   C  和  A  中序扩展序列都是 #B#A#C#</span><br><span class="line">            \</span><br><span class="line">             C</span><br></pre></td></tr></table></figure>

<p>先来看序列化的代码，其实就是在前序遍历的基础上，如果遇到空指针就用“#”表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeBT</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结点值用String[] seq保存，index是seq的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        preOrder(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"# "</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(node.val).append(<span class="string">" "</span>);</span><br><span class="line">        preOrder(node.left, sb);</span><br><span class="line">        preOrder(node.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看反序列化，通过前序遍历得到的字符串，重建二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeBT</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结点值用String[] seq保存，index是seq的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] seq = str.split(<span class="string">"\\s"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reconstructBST(seq);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reconstructBST</span><span class="params">(String[] seq)</span> </span>&#123;</span><br><span class="line">        ++index;</span><br><span class="line">        <span class="keyword">if</span> (seq[index].equals(<span class="string">"#"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(seq[index]));</span><br><span class="line">        root.left = reconstructBST(seq);</span><br><span class="line">        root.right = reconstructBST(seq);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于前序遍历时每存入一个结点值或者存入“#”后面都紧跟着一个空格。所以最后得到的序列时这样的格式<code>A B # # C # #</code>，可以根据空格将其分割成<code>[A, B, #, #, C, #, #]</code>这样就还原了各个结点的值，根据这些值重建二叉树。由于得到的是二叉树的前序序列，因此也要以前序重建二叉树，当遇到结点值是“#”时说明这是一个空指针，那么返回null给上层的父结点。如果不为“#”就递归地重建该结点的左右子树。注意这里使用了一个int型的index，用于表示当前结点在String[] seq中的索引，无需担心index在seq中会造成数组下标越界，因为最后一个结点的左右子树肯定是null，必然会终止递归。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题39--数组中出现次数超过一半的数字</title>
    <url>/likemoves.github.io/2020/05/10/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9839--%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组&#123;1,2,3,2,2,2,5,4,2&#125;。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</span><br></pre></td></tr></table></figure>

<p>可以先将数组排序，然后统计数字出现的次数，先将第一个数字出现次数初始化为1，如果遇到同样的数字，就加1，遇到不一样的就重新初始化为1重新开始计数，知道某个数字计数值大于n / 2（n是数组的长度），终止循环，返回当前数字就是我们要的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution2</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length&lt;=<span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> num=array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(count==<span class="number">0</span>) &#123;</span><br><span class="line">               num=array[i];</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(array[i]==num)</span><br><span class="line">               count++;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               count--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> times=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(array[i]==num)&#123;</span><br><span class="line">                   times++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(times*<span class="number">2</span>&gt;array.length)&#123;</span><br><span class="line">               isInputInvalid=<span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">return</span> num;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>但是排序算法的时间复杂度为O(nlgn)，有没有更快的方法呢。</p>
<h2 id="切分法，时间复杂度O-n"><a href="#切分法，时间复杂度O-n" class="headerlink" title="切分法，时间复杂度O(n)"></a>切分法，时间复杂度O(n)</h2><p>注<strong>意到排序之后，如果数组中存在某个数字超过数组长度的一半，那么数组中间的数字必然就是那个出现次数超过一半的数字。</strong>这就将问题转化成了求数组的中位数，快速排序使用的切分算法可以方便地找出中位数，且时间复杂度为O(n)，找出中位数后还需要再遍历一边数组，检查该中位数是否出现次数超过数组长度的一半。总结一下，基于切分法有如下两个步骤：</p>
<ul>
<li>切分法找出中位数</li>
<li>检查中位数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreThanHalf</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid=select(array,array.length/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> checkMoreThanHalf(array,mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计中位数是否超过数组元素个数的一半，若没有默认返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a:array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a==number) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&gt;array.length/<span class="number">2</span> ? number:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排名为k的元素,只是部分排序，时间复杂度为O(N)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// high==low时只有一个元素，不切分</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = partition(array, low, high);</span><br><span class="line">            <span class="keyword">if</span> (j == k) <span class="keyword">return</span> array[k];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) high = j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) low = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> array[k];</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序的切分方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> v = array[low];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (array[++i] &lt; v) <span class="keyword">if</span> (i == high) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (array[--j] &gt; v) <span class="keyword">if</span> (j == low) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, low, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select方法是通用的选择排名为k的元素，只要参数传入n / 2即可求得中位数。partition方法会返回一个索引<code>j</code>，该索引的左半部分全小于索引出的值，右半部分全大于索引处的值，如果指定的排名k == j，那么问题就解决了；如果k &lt; j，则需要在左半数组中继续查找；如果k &gt;  j，则需要在右半数组继续查找。循环中保证了low左边的值都小于arr[low, high]，而high右边的值都大于arr[low,  high]，通过不断切分和k比较，直到子数组中只含有第k个元素，此时arr[0]~arr[k -  1]都小于a[k]而arr[k+1]即其后的所有都大于a[k]，a[k]刚好是排名第k的元素。</p>
<p>另外while循环外还有一个<code>return a[k]</code>，保证了当数组长度为1，即high == low时不能进入while循环，应该直接返回a[k].</p>
<p>找到中位数之后遍历一边数组，检查中位数出现次数是否超过数组长度一半即可。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题4--二维数组中的查找</title>
    <url>/likemoves.github.io/2020/04/23/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%984--%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>根据题目，一个满足要求的二维数组长下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	2	8	9</span><br><span class="line">2	4	9	12</span><br><span class="line">4	7	10	13</span><br><span class="line">6	8	11	15</span><br></pre></td></tr></table></figure>

<h3 id="解法一：对每一行进行二分查找"><a href="#解法一：对每一行进行二分查找" class="headerlink" title="解法一：对每一行进行二分查找"></a>解法一：对每一行进行二分查找</h3><p>每一行的一维数组已经有序，所以使用<strong>二分查找</strong>在每一行中查找，一旦找到立即返回。对于一个M*N的二维数组，一次二分查找的时间复杂度为O(lg N), M行就是O(Mlg N)。根据上面的表述已经可以很轻松地写出代码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array!=<span class="keyword">null</span>&amp;&amp;array.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high=array[i].length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low&lt;=high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (target&gt;array[i][mid])&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (target&lt;array[i][mid])&#123;</span><br><span class="line">                    high=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：和右上角-左下角元素比较不断缩小范围"><a href="#解法二：和右上角-左下角元素比较不断缩小范围" class="headerlink" title="解法二：和右上角/左下角元素比较不断缩小范围"></a>解法二：和右上角/左下角元素比较不断缩小范围</h3><p>上面二分查找对high的优化是个很好的启发，如果我们将target和矩阵中的某一个数比较，如果<code>target &gt; arr[i][j]</code>，那么<code>array[i][j]</code>的右边列所有元素、下边行的所有元素都有可能含有与target相等的数；同理如果<code>target &lt; arr[i][j]</code>，那么<code>array[i][j]</code>的左边列所有元素、上边行的所有元素都有可能含有与target相等的数。这样问题就复杂了，编写代码时可能无从下手（到底选择往哪个方向移动？），和矩阵的左上角、右下角也是一个道理。</p>
<p>我们来看右上角/左下角，由于这两个位置对称，现只看右上角。<strong>这个位置在一行中是最大的元素，在一列中是最小的元素</strong>。根据这个特点，当右上角的值大于target，右上角元素那一列都是大于target的，所以可以直接剔除这一列；当右上角的值小于target，右上角元素那一行都是小于target的，所以可以直接剔除这一行；当右上角的值等于target说明找到，立即返回。就这样不断将范围一行一列地缩小…</p>
<p>根据描述可写出如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find1</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array!=<span class="keyword">null</span>&amp;&amp;array.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> N=array.length;</span><br><span class="line">        <span class="keyword">int</span> col=array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (row&lt;N&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target&lt;array[row][col])&#123;</span><br><span class="line">                col = col-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (target&gt;array[row][col])&#123;</span><br><span class="line">                row=row+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题36--二叉搜索树与双向链表</title>
    <url>/likemoves.github.io/2020/05/07/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9836--%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</span><br></pre></td></tr></table></figure>

<p>递归版<br>解题思路：<br>1.将左子树构造成双链表，并返回链表头节点。<br>2.定位至左子树双链表最后一个节点。<br>3.如果左子树链表不为空的话，将当前pRootOfTree追加到左子树链表。<br>4.将右子树构造成双链表，并返回链表头节点。<br>5.如果右子树链表不为空的话，将该链表追加到pRootOfTree节点之后。<br>6.根据左子树链表是否为空确定返回的节点。</p>
<p><img src="https://img-blog.csdn.net/20180610102210993" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree.left==<span class="keyword">null</span>&amp;&amp;pRootOfTree.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        <span class="comment">// 1.将左子树构造成双链表，并返回链表头节点</span></span><br><span class="line">        TreeNode left = Convert(pRootOfTree.left);</span><br><span class="line">        TreeNode p = left;</span><br><span class="line">        <span class="comment">// 2.定位至左子树双链表最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.如果左子树链表不为空的话，将当前pRootOfTree追加到左子树链表</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p.right = pRootOfTree;</span><br><span class="line">            pRootOfTree.left = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.将右子树构造成双链表，并返回链表头节点</span></span><br><span class="line">        TreeNode right = Convert(pRootOfTree.right);</span><br><span class="line">        <span class="comment">// 5.如果右子树链表不为空的话，将该链表追加到pRootOfTree节点之后</span></span><br><span class="line">        <span class="keyword">if</span>(right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            right.left = pRootOfTree;</span><br><span class="line">            pRootOfTree.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left!=<span class="keyword">null</span>?left:pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">参考链接：https:<span class="comment">//blog.csdn.net/weixin_40928253/article/details/85373191</span></span><br><span class="line">https:<span class="comment">//blog.csdn.net/u013132035/article/details/80638812</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题42--连续子数组的最大和</title>
    <url>/likemoves.github.io/2020/05/11/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9842--%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整型数组，数组里正负数都可能有，数组中的一个或者连续的多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为O(n)</span><br></pre></td></tr></table></figure>

<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>还可以用动态规划的思想，用$f(i)$表示以第i个数字结尾的子数组，其中0 &lt; i &lt; n ，那么我们要求的就是max[f(i)]。</p>
<p>f(i) = array[i], i=0 或者f(i-1) &lt; 0</p>
<p>f(i) = f(i -1) + array[i], i \neq 0 且f(i -1) &lt;0</p>
<p><strong>动态规划最重要的就是要保存中间计算结果</strong>，这里f(i)其实就是上面的curSum，max[f(i)]的计算变成了两两比较，其实就是上面的maxSum。可以看到和上面的方法是异曲同工的。这里保存的中间计算结果就是curSum和maxSum，当f(i-1) &lt; 0时对应着上面curSum &lt; 0.  否则就累加，然后求max[f(i)]可以通过两两比较得到最终的最大和，也就是f(i)和当前的max比较选择较大的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">FindGreatestSumOfSubArray</span> <span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>（array==<span class="keyword">null</span>||array.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> maxSum=array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> curSum=array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        curSum=Math.max(curSum+array[i],array[i]);</span><br><span class="line">        maxSum=Math.max(curSum,maxSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题29--顺时针打印矩阵</title>
    <url>/likemoves.github.io/2020/05/05/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9829--%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> </span><br><span class="line">则依次打印出数字</span><br><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>.</span><br></pre></td></tr></table></figure>

<p>顺时针打印一个矩阵需要按照如下顺序：</p>
<ol>
<li>从左往右遍历每个数字，矩阵只需保证至少有一行即可。</li>
<li>从上往下遍历每个数字，矩阵保证至少有两行。</li>
<li>从右往左遍历每个数字，矩阵除了保证至少有两行，还要保证至少两列。</li>
<li>从下往上遍历每个数字，矩阵保证至少有三行两列。</li>
</ol>
<p>每打印完一圈，矩形区域缩小，对内层的矩形再次执行上述操作（按顺序）….到最后一个矩形时，矩形区域很小，上述操作可能不会全部执行，那也没有关系，只要限制了条件，后续的遍历是不会得到执行的。</p>
<p>关键是如何控制矩形的边界，正确地缩小矩形的边界。为此设置了4个变量</p>
<ul>
<li>left表示矩形的左边界</li>
<li>right表示矩形的右边界</li>
<li>top表示矩形的上边界</li>
<li>bottom表示矩形的下边界</li>
</ul>
<p>一开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left = top = 0;</span><br><span class="line">right = 列数</span><br><span class="line">bottom = 行数</span><br></pre></td></tr></table></figure>

<p>每次打印完一圈后，缩小矩形区域，于是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left++;right--;</span><br><span class="line">top++;bottom--;</span><br></pre></td></tr></table></figure>

<p>搞清楚上面打印顺序和相应的条件后，可写出如下程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintMatrix</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="comment">// 从左往右，有一行即可</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=left;col&lt;=right;col++) </span><br><span class="line">                list.add(matrix[top][col]);</span><br><span class="line">              <span class="comment">// 从上往下,保证至少有两行</span></span><br><span class="line">            <span class="keyword">if</span>(top&lt;bottom)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> row=top+<span class="number">1</span>;row&lt;=bottom;row++) </span><br><span class="line">                    list.add(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">// 从右往左，至少两行两列</span></span><br><span class="line">            <span class="keyword">if</span>(top&lt;bottom&amp;&amp;left&lt;right)&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> col=right-<span class="number">1</span>;col&gt;=left;col--) </span><br><span class="line">                    list.add(matrix[bottom][col]);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 从下往上，保证至少三行两列</span></span><br><span class="line">             <span class="keyword">if</span>(bottom-top&gt;<span class="number">1</span>&amp;&amp;left&lt;right)&#123;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> row=bottom-<span class="number">1</span>;row&gt;top;row--) </span><br><span class="line">                    list.add(matrix[row][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缩小矩形</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom++;</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题44--数字序列中的某一位数字</title>
    <url>/likemoves.github.io/2020/05/14/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9844--%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 数字以0123456789101112131415....的格式序列化得到一个字符序列中，在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="逐个举例"><a href="#逐个举例" class="headerlink" title="逐个举例"></a>逐个举例</h2><p>有一种方法，每列举一个数字就记录当前序列长度和，比如列举到3，序列的长度和为4，列举到10，长度和为12…以此类推。当某次列举使得当前长度和大于给定的n时，停止列举，<strong>第n位数一定在在刚列举的数中</strong>，接下里只需从这个数中找出是哪一位即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADigitInNumberSeq</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：逐个列举</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numAtSeq</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            sum+=countDigits(i);</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;index) <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digitAt(i,sum-index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *计算某数有多少位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countDigits</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回某数的第d位, 第0位是个位，第1位是十位，以此类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">digitAt</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (value / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, d)) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前长度和sum &gt; index时候退出循环，此时第index位一定在数字i中，那到底是数字i的第几位呢？举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">012345678910111213...</span><br></pre></td></tr></table></figure>

<p>找index = 16的数，当列举到13时候，当前长度和sum = 18 &gt; 16，此时i = 13，容易得知index位是1，即13的第0位。多举几个例子就容易发现只要取数字<code>i</code>的第<code>sum - index -1</code>位就是我们要找的数字。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题43--1~n整数中1出现的次数</title>
    <url>/likemoves.github.io/2020/05/13/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9843--1n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数，例如输入12, 1~12中出现1的有1、10、11、12共5次</span><br></pre></td></tr></table></figure>

<h2 id="计算每个数字出现1的次数"><a href="#计算每个数字出现1的次数" class="headerlink" title="计算每个数字出现1的次数"></a>计算每个数字出现1的次数</h2><p>比较直接的思路就是写一个方法可以统计任意整数1的个数，然后用一个循环得到对1~n每一个数调用该方法统计总的1的出现次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumOf1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1，计算每个数字中1的个数，复杂度O(nlgn)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1From1To</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 正负数不影响1的个数，统一变成非负数</span></span><br><span class="line">          <span class="keyword">if</span> (n &lt; <span class="number">0</span>) n = Math.abs(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环求n个数字，共O(nlgn)的时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            count += numOf1(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numOf1</span><span class="params">(<span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">10</span>==<span class="number">1</span>) count++;</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>numOf1</code>方法中，n % 10可以得到个位，n = n / 10表示丢弃最低位。该方法的复杂度为O(lgn)，对于1~n中n个数字都要调用一遍该方法，总的时间复杂度是O(nlgn)。</p>
<h2 id="更暴力的解法–StringBuilder拼接"><a href="#更暴力的解法–StringBuilder拼接" class="headerlink" title="更暴力的解法–StringBuilder拼接"></a>更暴力的解法–StringBuilder拼接</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumOf1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：使用StringBuilder将所有数字拼接，无脑数数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOf1Between1AndN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 正负数不影响1的个数，统一变成非负数</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) n = Math.abs(n);</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sb.append(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sb.charAt(i) == <span class="string">'1'</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题40--最小的k个数</title>
    <url>/likemoves.github.io/2020/05/10/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9840--%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</span><br></pre></td></tr></table></figure>

<h2 id="基于最大堆的优先队列"><a href="#基于最大堆的优先队列" class="headerlink" title="基于最大堆的优先队列"></a>基于最大堆的优先队列</h2><p>有一个很简单的想法：设想有一个容器，其大小不超过k时，就不断存入元素，只要容量超过k，就剔除其中最大的元素，重复该过程，当遍历所有元素后，该容器中剩下的刚好就是最小的k个元素。</p>
<p>哪种容器能快速得到最大元素，可能第一想到的就是<strong>最大堆</strong>。</p>
<p>上面的两个方法还是太麻烦了，面试了哪有那么多时间让你手写一个堆和一大堆代码的切分方法。而且上述两种方法都改变了原数组。Java内置了优先队列，就是基于堆实现的，默认是最小堆，可以传入Comparator改变堆的形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.compareTo(a));</span><br><span class="line"><span class="comment">// 注意参数a、b的顺序和compareTo方法中a、b的位置</span></span><br><span class="line"><span class="comment">// 或者直观的写法</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reversOrder());</span><br></pre></td></tr></table></figure>

<p>基于以上思路，实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastKNums</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上面两个方法都改变了输入数组</span></span><br><span class="line"><span class="comment">     * 直接使用Java内置的优先队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getLeastK</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length || k == <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : input) &#123;</span><br><span class="line">            maxHeap.offer(a);</span><br><span class="line">            <span class="comment">// 只要size大于k，不断剔除最大值，最后优先队列里只剩最小的k个</span></span><br><span class="line">            <span class="keyword">if</span> (maxHeap.size() &gt; k) maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        list.addAll(maxHeap);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先队列可以以O(1)的时间删除堆顶元素，但是由于删除后还要恢复堆有序状态，而优先队列的大小不会超过k + 1，因此时间复杂度为O(lg k)。又由于输入中有n个数，故总的时间复杂度为O(nlgk)。</p>
<p>优先队列中的元素从来不会超过k + 1，因此即使有海量的数据不用担心，因为无需将海量数据一次性加载进内存，只需要每次读取一个值，然后剔除一个最大值，优先队列的大小将长期稳定在k。</p>
<p>比较一下这几个方法，切分法是最快的，但是不适合用于处理海量数据；基于优先队列的实现虽然速度满了点但是可以进行海量数据处理，看具体应用场景了。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题46--把数字翻译成字符串</title>
    <url>/likemoves.github.io/2020/05/16/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9846--%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个数字，我们按照如下的规则把它翻译成字符串</span><br><span class="line"><span class="number">0</span> -&gt; a</span><br><span class="line"><span class="number">1</span> -&gt; b</span><br><span class="line"><span class="number">2</span> -&gt; c</span><br><span class="line">...</span><br><span class="line"><span class="number">25</span> -&gt; z</span><br><span class="line"></span><br><span class="line">一个数字可能有多种翻译，比如<span class="number">12258</span>有五种，分别是<span class="string">"bccfi"</span>, <span class="string">"bwfi"</span>,<span class="string">"bczi"</span>,<span class="string">"mcfi"</span>, <span class="string">"mzi"</span>.请实现一个函数，用来计算一个数字有多少种不同的翻译方法。</span><br></pre></td></tr></table></figure>

<p>举个简单的例子，比如258，我们可以先翻译第一个数字，得到c，也可以翻译前两个数字，得到z；如果先翻译了一个数，对于剩下的58，和上面一样可以选择只翻译一位，得到f，也可以翻译两位（在这个例子中是不合法的，58没有与之映射的字符），如果先翻译了两位，对于剩下的8，只能有一种翻译方法了，得到i。所以最后得到两种翻译方法，cfi和zi。</p>
<p>从这个简单的例子可以得到一般性的结论，令f(i)为从第i位开始的不同翻译的数目，因为每次可以选择值翻译一个数字，也可一次翻译两个数字，而对于剩下的数字也可以采用同样的方法，这是一个递归问题。</p>
<h2 id="从左到右翻译的递归"><a href="#从左到右翻译的递归" class="headerlink" title="从左到右翻译的递归"></a>从左到右翻译的递归</h2><p>根据上面的思路，可写出从左到右翻译的递归解法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TranaLateNumToString</span></span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：从左到右的递归，重复计算较多，但是可以保存编码的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> List;</span><br><span class="line">        </span><br><span class="line">        String number=String.valueOf(n);</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        translate(sb,number,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">translate</span><span class="params">(StringBuilder sb, String str, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(str.equals(<span class="string">""</span>))&#123;</span><br><span class="line">             list.add(sb.toString());</span><br><span class="line">             <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 一次只翻译一个数</span></span><br><span class="line">         String s1=str.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">char</span> letter1=numToLetter(s1);</span><br><span class="line">         sb.append(letter1);</span><br><span class="line">         translate(sb,str.substring(<span class="number">1</span>),list);</span><br><span class="line">         sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">          <span class="comment">// 一次翻译二个数</span></span><br><span class="line">         <span class="keyword">if</span>(str.length()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">             String s2=str.substring(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">             <span class="keyword">if</span>(check(s2))&#123;</span><br><span class="line">                 <span class="keyword">char</span> letter2=numToLetter(s2);</span><br><span class="line">                 sb.append(letter2);</span><br><span class="line">                 translate(sb,str.substring(<span class="number">2</span>),list);</span><br><span class="line">                 sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当一次翻译两位数时，检查是否范围在10-25之间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = Integer.parseInt(num);</span><br><span class="line">        <span class="keyword">return</span> val &gt;= <span class="number">10</span> &amp;&amp; val &lt;= <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数字 -&gt; 字母的映射，a的ASCII码是97，所以0-25的数字加上97就得到了题      * 目中的映射</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">numToLetter</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>) (Integer.parseInt(num) + <span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用StringBuilder拼接每次翻译的结果，到字符串的结尾说明翻译完毕，将该翻译结果存到一个list中，StringBuilder每次append一个翻译字符然后递归地对其后的字符进行同样的操作，但是递归结束后，StringBuilder需要删除掉这个刚添加了翻译字符，实际上就是模拟了进出栈的过程，这保证了StringBuilder在其他递归调用中表示的翻译字符结果正确。注意只有当当前字符串长度大于等于2才能一次翻译两个数字，因此在翻译两个数字时别忘了判断下。</p>
<p>这种方法，调用了很多次substring，空间上很浪费，而且自上而下的递归中有很多重复计算，效率并不高。但是该方法可以保存每种翻译的结果。</p>
<h2 id="从右往左翻译的循环-动态规划"><a href="#从右往左翻译的循环-动态规划" class="headerlink" title="从右往左翻译的循环(动态规划)"></a>从右往左翻译的循环(动态规划)</h2><p>如果自下而上，从小的结果出发，保存每一步计算的结果，以供下一步使用，也就是我们按照从右到左的顺序翻译。</p>
<p>f(i) = f(i+1) + f(i+2)</p>
<p>对于上面的公式，也就是先求出f(n -1)，然后求出f(n -2)，之后根据这两个值求出f(n -3)，然后根据f(n-2)和f(n -3)求出f(n -4)一直往左知道求出$f(0)$，这就是我们要的结果！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransLateNumToString</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：从右到左的循环，效率高，单纯的计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTranslateCount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> count(String.valueOf(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = num.length();</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">      	<span class="comment">// f(n -1)必然为1</span></span><br><span class="line">        counts[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> high = num.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> low = num.charAt(i + <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> combineNum = high * <span class="number">10</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (combineNum &gt;= <span class="number">10</span> &amp;&amp; combineNum &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">                <span class="comment">// f(i) = f(i+1) +f(i+2),if中因为f(i+2)不存在，但是该值肯定为1</span></span><br><span class="line">                <span class="keyword">if</span> (i == len -<span class="number">2</span>) counts[i] = counts[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> counts[i] = counts[i+<span class="number">1</span>]+counts[i+<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// f(i) = f(i+1)</span></span><br><span class="line">                counts[i] = counts[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第一个数字开始的不同翻译数目</span></span><br><span class="line">        <span class="keyword">return</span> counts[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是把公式翻译了一遍，其中counts数组存放每一步计算的结果，即保存f(0)~f(n -1)的值。f(n  -1)说明只有一位数，必然只有一种翻译方法；同样注意，当i = n  -2时候，f(i+2)将超出范围，需要特别处理，这种情况就是说，对于两位数比如18，肯定有两种翻译方法，即f(n -1) + 1 =  2种。</p>
<p>最后一步得到counts[0]即f(0)返回即为答案。</p>
<p>这种方法只需遍历数字的每一位即可，实现了题目的要求计算出了翻译数目，但是没有办法表示出翻译结果。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题47--礼物的最大价值</title>
    <url>/likemoves.github.io/2020/05/17/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9847--%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在一个mxn的棋盘的每一格斗放油一个礼物，每个礼物都有一定的价值（大于<span class="number">0</span>）从棋盘的左上角开始，每次可以往右边或者下边移动一格，知道到达棋盘的右下角。给定一个棋盘和上面的礼物，计算我们最多可以拿到多少价值的礼物</span><br></pre></td></tr></table></figure>

<h2 id="递归–两个方向的深度优先搜索"><a href="#递归–两个方向的深度优先搜索" class="headerlink" title="递归–两个方向的深度优先搜索"></a>递归–两个方向的深度优先搜索</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxGiftVal</span></span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：递归，两个方向的深度优先搜索，用一个对象数组保存最大值（只需一个长度）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] gifts,<span class="keyword">int</span> row,<span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gifts==<span class="keyword">null</span>||gifts.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] max=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        select(gifts,<span class="number">0</span>,<span class="number">0</span>,rows,cols,<span class="number">0</span>,max);</span><br><span class="line">        <span class="keyword">return</span> max[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] gifts,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> val,<span class="keyword">int</span>[] max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=rows||col&gt;=cols) <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">// 一维数组表示，对应着二维数组中的array[row][col]</span></span><br><span class="line">        val=val+gifts[row*cols+col];</span><br><span class="line">        <span class="keyword">if</span> (row == rows - <span class="number">1</span> &amp;&amp; col == cols - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; max[<span class="number">0</span>]) max[<span class="number">0</span>] = val;</span><br><span class="line">        &#125;</span><br><span class="line">        select(gifts, row + <span class="number">1</span>, col, rows, cols, val, max);</span><br><span class="line">        select(gifts, row, col + <span class="number">1</span>, rows, cols, val, max);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划–要到达当前格子有两个方向"><a href="#动态规划–要到达当前格子有两个方向" class="headerlink" title="动态规划–要到达当前格子有两个方向"></a>动态规划–要到达当前格子有两个方向</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方法2：动态规划，到达f(i,j)处拥有的礼物价值和有两种情况：</span></span><br><span class="line"><span class="comment">    * 1、从左边来，即f(i, j) = f(i, j -1) + gift(i, j)</span></span><br><span class="line"><span class="comment">    * 2、从上边来，即f(i, j) = f(i -1, j) + gift(i, j)</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 保证到达每一个格子得到的礼物价值之和都是最大的，也就是取max[f(i, j-1), f(i-1, j)] +gift(i, j)</span></span><br><span class="line"><span class="comment">    * 可以发现，要知道当前格子能获得最大礼物价值，需要用到当前格子左边一个和上面一个格子的最大礼物价值和</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxVal</span><span class="params">(<span class="keyword">int</span>[] gifts, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[][] maxVal=<span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows;row++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;cols;col++)&#123;</span><br><span class="line">               <span class="keyword">if</span> (row &gt; <span class="number">0</span>) up = maxVal[row -<span class="number">1</span>][col];</span><br><span class="line">               <span class="keyword">if</span> (col &gt; <span class="number">0</span>) left = maxVal[row][col -<span class="number">1</span>];</span><br><span class="line">               maxVal[row][col] = Math.max(up, left) + gifts[row *cols+col];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal[rows-<span class="number">1</span>][cols-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题48--最长不含重复字符串的子字符串</title>
    <url>/likemoves.github.io/2020/05/17/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9848--%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含<span class="string">'a'</span>~<span class="string">'z'</span>之间的字符，例如在字符串<span class="string">"arabcacfr"</span>中，最长的不含重复字符的子字符串是<span class="string">"acfr"</span>，长度为<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>动态规划，<strong>定义f(i)表示以第i个字符为结尾的不含重复字符的子字符串长度。</strong></p>
<p>如果第i个字符之前没有出现过，则f(i) = f(i -1) +1，比如‘abc’,f(0) =  1是必然的，然后字符’b‘之前没有出现过，则f(1) = f(0)+1, 字符’c’之前没有出现过，那么f(2) = f(1)  +1,每次计算都会用到上一次计算的结果。</p>
<p>如果第i个字符之前出现过呢？找到该字符上次出现的位置preIndex，当前位置i - preIndex就得到这两个重复字符之间的距离，设为d。此时有两种情况</p>
<ul>
<li>如果<code>d &lt;= f(i-1)</code>,说明当前重复字符必然在f(i-1)所对应的字符串中，比如’bdcefgc‘，当前字符c前面出现过了，preIndex为2，此时<code>d = 6 -2 = 4</code> ,小于<code>f(i -1) = 7 (bdcefg)</code>我们只好丢弃前一次出现的字符c及其前面的所有字符，得到当前最长不含重复字符的子字符串为’efgc‘，即<code>f(i) = 4</code>, 多举几个例子就知道，应该让<code>f(i) = d</code>；</li>
<li>如果<code>d &gt; f(i-1)</code>, 这说明当前重复字符必然在f(i-1)所对应的字符串<strong>之前</strong>，比如<code>erabcdabr</code>当前字符r和索引1处的r重复，<code>preIndex =1, i = 8,d = 7</code>。而<code>f(i -1) = 4 (cdab)</code>,此时直接加1即可，即<code>f(i) = f(i-1) +1</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestSubstring</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curLen=<span class="number">0</span>;<span class="comment">//表示f(i)</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">// 0~25表示a~z，position[0] = index,表明a上次出现在index处</span></span><br><span class="line">        <span class="keyword">int</span>[] position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            position[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex = position[str.charAt(i) - <span class="string">'a'</span>];</span><br><span class="line">              <span class="comment">// 字符第一次出现，或者d &gt; f(i -1) 继续标记</span></span><br><span class="line">            <span class="keyword">if</span> (preIndex == -<span class="number">1</span> || i - preIndex &gt; curLen) curLen++;</span><br><span class="line">             <span class="comment">// d &lt;= f(i -1) 重新开始标记 curlen==d;</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (curLen &gt; maxLen) maxLen = curLen;</span><br><span class="line">                curLen = i - preIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录当前字符出现的位置</span></span><br><span class="line">            position[str.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curLen &gt; maxLen) maxLen = curLen;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用了一个数组position代替哈希表，记录’a’~’z’每个字符上次出现的位置，能以O(1)的时间完成，先要将position中的值全初始化为-1，因为上次出现的位置可能含有索引0。 curLen就是上面说到的f(i -1)</p>
<p>如果某个字符第一次出现，那么它上次出现的位置preIndex为-1。当前最长不重复子字符串直接加1。</p>
<p>只有else语句中curLen才可能变小，因此要即使保存到maxLen，因为这个curLen可能就是最长的。而且if语句中curLen++并没有和maxLen比较，所以除了循环后还要再和maxLen比较一次。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题5--替换空格</title>
    <url>/likemoves.github.io/2020/04/23/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%985--%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h2 id="解法一：使用java内置方法"><a href="#解法一：使用java内置方法" class="headerlink" title="解法一：使用java内置方法"></a>解法一：使用java内置方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace2</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (str==<span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">       <span class="keyword">if</span> (str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">           str.replace(i,i+<span class="number">1</span>,<span class="string">"%20"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> str.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：从后往前扫描"><a href="#解法二：从后往前扫描" class="headerlink" title="解法二：从后往前扫描"></a>解法二：从后往前扫描</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace3</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统计空格个数</span></span><br><span class="line">    <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">           number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原来字符串的末尾指针</span></span><br><span class="line">    <span class="keyword">int</span> oldNum=str.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置新长度</span></span><br><span class="line">    str.setLength(str.length() + <span class="number">2</span>*number);</span><br><span class="line">    <span class="comment">// 新的字符串的末尾指针</span></span><br><span class="line">    <span class="keyword">int</span> newNum=str.length()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldNum&gt;=<span class="number">0</span>&amp;&amp;newNum&gt;oldNum)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(oldNum)==<span class="string">' '</span>)&#123;</span><br><span class="line">            str.setCharAt(newNum--,<span class="string">'0'</span>);  </span><br><span class="line">            str.setCharAt(newNum--,<span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(newNum--,<span class="string">'%'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(newNum--,str.charAt(oldNum));</span><br><span class="line">        &#125;</span><br><span class="line">        oldNum--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题51--在排序数组中查找数字</title>
    <url>/likemoves.github.io/2020/05/19/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9851--%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">统计一个数字在排序数组中出现的次数。</span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>这是很容易想到的方法了，但时间复杂度O(n)，不推荐。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法一：遍历，O(n)复杂度，不推荐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==k) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>既然是排序数组，自然容易想到二分法查找。假设要查找的数字为k，只需找到第一个k的下标、最后一个k的下标，就达到了计数的目的。</p>
<p>先来找第一个k的下标：由于有多个k，因此当在mid处找到k时，不要急于返回。如果k之前的数还是k，那么我们还要继续在左子数组中查找，直到某个mid处的值为k但是它前面的值不是k、或者mid都等于0了（即第一个k出现在下标0处）；</p>
<p>然后找最后一个k的下标：同样地，如果mid处是k，且它的后面还是k，需要在右子数组中继续查找，直到mid处为k但它后面不是k、或者mid都等于array.length -1(即最后一个k出现在数组的最后一个位置)；</p>
<p>得到第一个k和最后一个k的下标后，只需将两个索引相减再加上1即可。</p>
<p>根据上面的描述，可写出如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumOfK</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法二：二分法找到第一个k和最后一个k，时间复杂度O(nlgn)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfk</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> from=getFirstOfK(array,k,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> to=getLastOfk(array,k,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(from==-<span class="number">1</span>&amp;&amp;to==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> to-from+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到第一个k的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstOfK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;array[mid]) high=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>(k&gt;array[mid]) low=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid&gt;<span class="number">0</span>&amp;&amp;array[mid-<span class="number">1</span>]==k) high=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 找到最后一个K 的下标</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastOfk</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;array[mid]) high=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>(k&gt;array[mid]) low=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid&gt;<span class="number">0</span>&amp;&amp;array[mid+<span class="number">1</span>]==k) low=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0~n-1中缺失的数</span><br><span class="line">一个长度为n -1的递增排序数组中的所有数字都是唯一的，并且每个数字的都在范围0~n-1之内。在范围内0~n-1内的n个数字中有且只有一个数字不在该数组中，找出这个数字</span><br></pre></td></tr></table></figure>

<p>举个简单的例子来找到规律。比如数组长度为8，那么该数组中的数字都是0-8之间的，但是缺了一个数字，比如缺了4，则该数组为{0, 1, 2, 3, 5, 6, 7,8}</p>
<p>可以发现，缺失数字还没出现时，始终有<strong>该数字在数组中的下标等于该数，即array[i] == i</strong>,但是从5开始不再有这样的关系。对于5及其之后的元素有array[i] == i+1，但是5之前的3仍然有array[3] == 3, 可以看到这是一个分界线。此时返回5所在的下标4就是我们要的答案。</p>
<p>如果找到这个分界线呢？数组是有序的，仍然采用二分查找。当mid处满足array[mid] ==  mid，说明mid处及其之前的数都没有缺失，因此可以直接在mid右边数组查找；当array[mid] !=  mid说明mid处之前有元素丢失，此时再判断一下mid前的一个元素是否也有元素丢失，如果没有说明mid处是第一个值和下标不相等的元素，返回下标mid就是答案；如果mid处的前一个元素也有元素丢失，就继续缩小查找范围，在mid的左边数组继续查找即可。</p>
<p>根据上面的描述，写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLoss</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high=array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len=array.length;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid!=array[mid])&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid==<span class="number">0</span>||mid-<span class="number">1</span>==array[mid-<span class="number">1</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> high=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low=len) <span class="keyword">return</span> len;</span><br><span class="line">     <span class="comment">//  无效的输入数组，如不是递增排序，或者有的数字超出了0~n-1的范围</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题50--第一个只出现一次的字符</title>
    <url>/likemoves.github.io/2020/05/19/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9850--%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找出字符串中找出第一个只出现一次的字符，比如输入“abacceff&quot;,则输出&apos;b&apos;</span><br></pre></td></tr></table></figure>

<p>要想知道某个字符是不是只出现了一次，必须遍历字符串的每个字符。<strong>因此可以先遍历一次，统计每个字符出现次数。再遍历一次，遇到某个字符出现字符为1就立即返回。</strong>统计每个字符出现次数，可以用哈希表，不过如果输入中都是ASCII码，那么使用0-255表示即可。这样使用一个<code>int[] count = new int[256]</code>就能代替哈希表了，以<code>count[someChar] = times</code>这种方式表示某个字符出现的次数。比如‘a’的ASCII码是97，那么count[97]就表示了字符’a’的出现次数，以此类推。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstAppearOnceChar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个不重复字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">         <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">             count[str.charAt(i)]++;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(count[str.charAt(i)]==<span class="number">1</span>) <span class="keyword">return</span> str.charAt(i);</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回第一个不重复字符在字符串中的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstAppearOnceChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            count[str.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[str.charAt(i)] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个方法，一个是返回第一个只出现一次的字符，一个返回第一个只出现一个的字符的索引，思路都一样。根据<code>count[someChar]</code>获取某个字符的出现次数时间复杂度为O(1),对于长度为n的字符串，总的复杂度为O(n).</p>
<p>不过如果输入中含有特殊符号或者中文等，256位的ASCII表就不够用了，需要上Unicode了，总之看题目要求吧，要想通用就哈希表。</p>
<h2 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h2><h3 id="扩展一"><a href="#扩展一" class="headerlink" title="扩展一"></a>扩展一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。比如第一个字符串&quot;google&quot;，第二个字符串为&quot;aeiou&quot;，删除后得到&quot;ggl&quot;.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从第一个字符串中删除第二个字符串中出现过的所有字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteFromAnother</span><span class="params">(String str, String another)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span> || another == <span class="keyword">null</span> || another.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">boolean</span>[] occur=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">256</span>];</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuiler();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;another.length();i++)&#123;</span><br><span class="line">        occur[another.charAt(i)]=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(occur[str.charAt(i)]=<span class="keyword">false</span>) sb=sb.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个<code>boolean occur[] = new int[256]</code>布尔型数组，对于第二个字符串中的每个字符，标记为true表示出现过。遍历第一个字符串，判断每个字符在occur中是不是fale，为false说明该字符没有在第二个字符串中出现过，保留。</p>
<h3 id="扩展二"><a href="#扩展二" class="headerlink" title="扩展二"></a>扩展二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义一个函数，删除一个字符串中所有重复出现的字符，比如输入&quot;google&quot;返回&quot;gole&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除字符串中所有的重复字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteRepeating</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">boolean</span>[] occur = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">256</span>];</span><br><span class="line">  	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">    	<span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">    	<span class="keyword">if</span> (!occur[ch]) sb.append(ch);</span><br><span class="line">    	occur[ch] = <span class="keyword">true</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一个<code>boolean occur[] = new int[256]</code>布尔型数组，记录某个字符是否出现过。刚开始都初始化false，每添加一个字符就标记为true，这样下次遇到重复字符就不会再添加了。</p>
<h3 id="扩展三"><a href="#扩展三" class="headerlink" title="扩展三"></a>扩展三</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">变位词，如果两个单词含有相同的字母且每个字母出现的次数还一样，那么这两个单词互为变位词。定义一个函数判断两个字符串是不是互为变位词。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 变位词</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSameChar</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 ==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">  	<span class="comment">// 统计第一个字符串</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">    	count[s1.charAt(i)]++;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">// 第二个字符串中如果有该字符，就减去</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s2.length(); i++) &#123;</span><br><span class="line">    	count[s2.charAt(i)]--;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">// 如果是变位词，最后count数组每个位置都是0</span></span><br><span class="line">  	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (count[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展四"><a href="#扩展四" class="headerlink" title="扩展四"></a>扩展四</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符流中第一个只出现一次的字符。</span><br><span class="line">这次字符串是动态变化的了，比如现在只从字符流中读取了两个字符为&quot;go&quot;那么字符流中第一个只出现一次的字符是&apos;g&apos;，等到从字符流中读取了前6个字符&quot;google&quot;时，第一个只出现一次的字符变成了&apos;l&apos;.</span><br></pre></td></tr></table></figure>

<p>使用一个insert函数模拟从字符流中读到一个字符。这次统计表<code>int[] occur = new int[256]</code>记录的是字符出现的索引.</p>
<ul>
<li>如果某个字符出现过，那么<code>occur[someChar] &gt;= 0</code>;</li>
<li>对于没有出现过的字符，令<code>occur[someChar] = -1</code>;</li>
<li>如果某个字符第二次出现，令<code>occur[someChar] = -2</code>。</li>
</ul>
<p>要获得当前字符串中第一个只出现一次的，只需从所有<code>occur[someChar] &gt;= 0</code>中结果中找出出现索引最小的那个字符即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppearOnceInStream</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 记录某个字符出现的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] count;</span><br><span class="line">    <span class="comment">// 当前读取到的字符在字符串中的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppearOnceInStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count =  <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">            count[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 模拟读取字符流中的下一个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count[c] == -<span class="number">1</span>) count[c] = index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count[c] &gt;= <span class="number">0</span>) count[c] = -<span class="number">2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstAppearOnceChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">          	<span class="comment">// 从所有count[i] &gt;= 0的结果中找出最小的索引就是第一个只出现一次的字符</span></span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt;= <span class="number">0</span> &amp;&amp; count[i] &lt; minIndex) &#123;</span><br><span class="line">                minIndex = count[i];</span><br><span class="line">                c = (<span class="keyword">char</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AppearOnceInStream a = <span class="keyword">new</span> AppearOnceInStream();</span><br><span class="line">        a.insert(<span class="string">'g'</span>);</span><br><span class="line">        a.insert(<span class="string">'o'</span>);</span><br><span class="line">        System.out.println(a.firstAppearOnceChar());</span><br><span class="line">        a.insert(<span class="string">'o'</span>);</span><br><span class="line">        a.insert(<span class="string">'g'</span>);</span><br><span class="line">        a.insert(<span class="string">'l'</span>);</span><br><span class="line">        a.insert(<span class="string">'e'</span>);</span><br><span class="line">        System.out.println(a.firstAppearOnceChar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题49--丑数</title>
    <url>/likemoves.github.io/2020/05/18/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9849--%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</span><br></pre></td></tr></table></figure>

<p>设定三个数t2、t3、t5专门用于分别和2、3、5相乘，某次选择中选走了ti，那么ti从丑数集合中选择下一个数，下次再和i相乘生成一个新的候选丑数，本次没有被选中的，下次继续参与比较。这样能保证下一个丑数一定在三个候选项中，且是三个候选项中最小的那个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UglyNumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uglyNumber</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] res=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        <span class="comment">// 第一个丑数为1</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> m2 = res[t2] * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> m3 = res[t3] * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> m5 = res[t5] * <span class="number">5</span>;</span><br><span class="line">            <span class="comment">// 三个候选中最小的就是下一个丑数</span></span><br><span class="line">             res[i] = Math.min(m2, Math.min(m3, m5));</span><br><span class="line">            <span class="comment">// 选择某个丑数后ti * i，指针右移从丑数集合中选择下一个丑数和i相乘，注意是三个连续的if，也就是三个if都有可能执行。这种情况发生在三个候选中有多个最小值，指针都要右移，不然会存入重复的丑数</span></span><br><span class="line">            <span class="keyword">if</span> (res[i] == m2) t2++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == m3) t3++;</span><br><span class="line">            <span class="keyword">if</span> (res[i] == m5) t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题54--二叉搜索树中排名为k的结点</title>
    <url>/likemoves.github.io/2020/05/20/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9854--%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%8E%92%E5%90%8D%E4%B8%BAk%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一颗二叉搜索树，请找出排名第k的结点。</span><br></pre></td></tr></table></figure>

<p>注意是二叉搜索树，这说明对于任何结点，有父结点大于其左子结点且小于右子结点。<strong>如果中序遍历这棵树，就能得到递增排序的序列。</strong></p>
<p>接下来就很简单了，只需中序遍历到第k个结点，然后立即返回就行了。感觉对于这道题，非递归的中序遍历更好写一点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthNode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">findKthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>||k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkListed&lt;Tree&gt; stack=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pRoot!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pRoot!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(pRoot);</span><br><span class="line">                pRoot=pRoot.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty)&#123;</span><br><span class="line">                pRoot=stack.pop();</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(count==k) <span class="keyword">return</span> pRoot;</span><br><span class="line">                pRoot=pRoot.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题55--二叉树的深度</title>
    <url>/likemoves.github.io/2020/05/20/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9855--%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</span><br></pre></td></tr></table></figure>

<h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><p>很容易想到使用递归，根结点处的深度为1，既然要求树的最长路径，必然从根结点的左右子树中选出深度更大的那棵子树，也就是整棵树的深度为</p>
<p>depth(root) = max[depth(root.left), depth(root.right)] + 1</p>
<p>加1是因为要加上树的根结点。那么对于每棵子树，也要按照这样的规则——挑选出深度更大的子树并加上1，也就得到了以当前结点为根结点的二叉树的深度。这是个递归结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=TreeDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right=TreeDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当递归自上而下深入到叶子结点的孩子结点（null）时，返回0，从而会得到叶子结点的深度为1，就这样自底向上返回，每次回到上一层都是下一层的最大深度加上1，直到根结点……</p>
<p>这个代码也可以看成是后序遍历，先访问了父结点的左右子结点，从中选出深度更大着，然后回到父结点时加1（也就是算上父结点后深度会增加1）。</p>
<h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root=<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty)&#123;</span><br><span class="line">        <span class="keyword">int</span> layerSize=queue.size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;layerSize;i++)&#123;</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">        	<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">        	<span class="keyword">if</span> ((node.right) != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</span><br></pre></td></tr></table></figure>

<p>先从根结点开始求得其左右子树的深度，然后做差，如果深度差超过1，那这不是棵平衡二叉树；切不可以为根结点的左右子树深度差不超过1，下面的子树深度差就不会超过1了，画几幅反例就知道了。所以递归地对左右子树也做同样的判断是必须的，以确保每个以结点为根结点其左右子树的深度差不超过1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：递归地求每个结点的左右子树深度差，有重复计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBanlancedTree</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left=depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=depth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left,right)&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalancedTree(root.left) &amp;&amp; isBalancedTree(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法有个缺点，多个结点会被重复访问。</p>
<h2 id="书上的方法–后序遍历"><a href="#书上的方法–后序遍历" class="headerlink" title="书上的方法–后序遍历"></a>书上的方法–后序遍历</h2><p>之所以使用后续遍历，是因为后续遍历先访问父结点的左右子结点后，再访问父结点的，因此这种遍历顺序可以先得到左右子结点深度之差，然后再回到当前父结点求得父结点的深度…就这样自底向上判断每个结点的左右子树深度差，有某一个结点不平衡都将导致不断返回false。</p>
<p>需要一个指针记录当前结点的深度，而int型不是对象只能传值，为了传引用那就建立一个长度为1的对象数组吧，和前面说过的一样，当到达叶子结点的做右子结点（null）时深度为0，那么返回到叶子结点深度为1 …</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法3：后序遍历，为了传引用使用了对象数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBalance(root, <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            depth[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">boolean</span> left = isBalance(root.left, depth);</span><br><span class="line">        <span class="comment">// 左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> leftDepth = depth[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 右子树的深度</span></span><br><span class="line">        <span class="keyword">boolean</span> right = isBalance(root.right, depth);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = depth[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 当前结点的深度</span></span><br><span class="line">        depth[<span class="number">0</span>] = Math.max(leftDepth + <span class="number">1</span>, rightDepth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right &amp;&amp; Math.abs(leftDepth - rightDepth) &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题56--数组中数字出现的次数</title>
    <url>/likemoves.github.io/2020/05/22/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9856--%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</span><br><span class="line">要求时间复杂度为O(n)，空间复杂度为O(1).</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>哈希表不可行，因为要求不开辟新空间。</p>
<p>排序也不可取，最快排序也要O(nlogn)</p>
<p>这方法很有趣，首先看如何在一个数组中找出一个只出现一次的数字，其他数字都是出现两次的。</p>
<p>例如，｛1 3 3 2 2｝</p>
<p>用异或操作，可以使相同数字变为0</p>
<p>01、11、11、10、10依次异或最后得到01。</p>
<p>记两个出现一次的数字为num1,num2</p>
<p>我们对数组先进行依次异或得到结果num，num = num1^num2 != 0，<strong>从右往左找到第一个1，在这一位上，num1和num2肯定不同，根据这个将数组分为两个子数组，然后就在单个数组中找出只出现一次的即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNumsAppearOnce</span> </span>&#123;</span><br><span class="line">    <span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line">    <span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这步得到两个只出现一次的数的异或值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            res ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// res肯定不为0，那么res必然有某一位是1，找到第一个1的索引，假设为n;</span></span><br><span class="line">        <span class="comment">// 第n位的异或值为1，也说明了这两个数的第n位不相同</span></span><br><span class="line">        <span class="keyword">int</span> indexOfFirstOne=firstBitOfOne(res);</span><br><span class="line">         <span class="comment">// 以第n位是不是1为标准，将数组拆分成两个</span></span><br><span class="line">        <span class="comment">// 相同数字一定会被分到同一个子数组，因为相同的数字第n位也是相同的；只出现一次的那两个数字肯定不会分到一个数组中，因为他们的第n位异或值为1，说明他们第n位不相同</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (isBitOfOne(array[i], indexOfFirstOne))</span><br><span class="line">                  num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                  num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到从右往左数的第一个1的索引，如0110的第一个1索引为1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">firstBitOfOne</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (val != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((val &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> index;</span><br><span class="line">            val = val &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断从右往左数的第index位是不是1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBitOfOne</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        val = val &gt;&gt; index;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题57--和为s的数字</title>
    <url>/likemoves.github.io/2020/05/22/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9857--%E5%92%8C%E4%B8%BAs%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S；如果有多对数字的和等于S，输出两个数的乘积最小的。</span><br></pre></td></tr></table></figure>

<p>先看这个条件：和一样，要求乘积最小。由于数组递增排序，那么这两个数与其他和为s的两个数比，相隔的距离更远。这里就不证明了，<strong>试想周长一样的两个图形，又扁又长的矩形和正方形比哪个面积大吧….</strong></p>
<p>要从数组中找两个数相加，如果和刚好为s，这样就找到了一组候选值；如果和小于s呢，可以把两个数中较小者丢弃，换一个比它稍大的继续求和与s比较;如果和大于s就丢弃较大值换一个比该值稍小的，继续求和与s比较。由于数组已经排序，要换比较小值稍大的，或者换比较大值稍小的都不是难事。</p>
<p><strong>设置两个指针，一个指向数组的第一个元素，另一个指向数组的最后一个元素。即一开始将较小值设为数组的最小值，较大值设置为数组的最大值。</strong></p>
<p>接下来求按照上面的方法不断与s比较，找到第一组和为s的两个数就是乘积最小的。</p>
<p>举个例子{1, 2, 4, 7, 11,  15}和数字15，刚开始1+15大于15，所以丢弃15；将1和11求和，小于15，所以丢弃1；将2和11求和，小于15，丢弃2；将4和11求和，刚好等于15，找到第一组和为15的两个数是4和11，它们乘积就是最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;=<span class="number">1</span>) <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[low]+array[high]==sum)&#123;</span><br><span class="line">                list.add(array[low]);</span><br><span class="line">                list.add(array[high]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[low]+array[high]&gt;sum)&#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">和为s的连续正数序列。</span><br><span class="line">输入一个正数s，打印出所有何为s的连续正数序列（至少含有两个数）。</span><br><span class="line">例如输入15，由于1+2+3+4+5 = 4+5+6 = 7+8,所有打印出三个连续的序列1~5,4~6,7~8</span><br></pre></td></tr></table></figure>

<p>注意因为是连续的正数序列，所以序列至少是从1开始的。题目要求至少含有两个数，不妨假设一开始序列中是两个最小的值，即1和2。</p>
<p>举个例子假设s等于9。对初始序列求和得到3，如果小于9，说明需要扩大序列使它包含更多数字，那就增加一个数字，现在序列变成{1,2,  3}，对序列求和继续和9比较，还小了，那就再增加一个数字序列变成{1, 2, 3  ,4}，这次序列和比9大了，丢弃序列中的最小值，现在序列变成{2, 3, 4}，序列求和刚好等于9！因此{2, 3,  4}是一个满足条件的序列，继续找。满足条件的其他序列肯定在后面，所以此时需要扩大序列，因此增加一个数字序列变成{2,3,4,5},  序列和比9大，<strong>不断丢弃最小值直到序列和小于等于9</strong>，因此丢弃2、丢弃3，现在剩下{4,  5}，序列和和9相等，又找到一个！后面还有没有满足条件的序列呢？<strong>注意到序列是递增的，而且满足条件的序列至少有两个数。</strong>那么满足条件的序列中最大的数不会⌈s / 2⌉了，因为5之后是6，加起来超过9了，所以从5开始其后的序列都不可能满足条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContinuousSeq</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= <span class="number">2</span>) <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> small=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> big=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum=small+big;</span><br><span class="line">        <span class="keyword">int</span> mid=(sum+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(small&lt;mid)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curSum&gt;sum&amp;&amp;small)&#123;</span><br><span class="line">                curSum-=small;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curSum==sum)</span><br><span class="line">                list.add(addFromSmallToBig(small, big));</span><br><span class="line">             big++;</span><br><span class="line">            curSum += big;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个连续区间内的数字求和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">addFromSmallToBig</span><span class="params">(<span class="keyword">int</span> small, <span class="keyword">int</span> big)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = small; i&lt;= big; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ContinuousSeq continuousSeq = <span class="keyword">new</span> ContinuousSeq();</span><br><span class="line">        System.out.println(continuousSeq.FindContinuousSequence(<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为每次只是在序列尾部增加一个数字或者在序列头部丢弃一个数字，所以使用了一个curSum可以很方便地保存当前序列的和。</p>
<p>当序列和小于s，或者序列和等于s两种情况下都需要扩大序列使其包含更多的数。所以先用while循环判断序列和大于s的情况（此时small在自增所以还要保证small要小于mid），直到序列和小于或者等于s才退出循环；接在再判断序列和是否等于s，不管等不等于s，扩大序列的代码都会得到执行，这就很好地综合了两种情况，节省了代码量。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题58--反转字符串</title>
    <url>/likemoves.github.io/2020/05/23/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9858--%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个英文句子，翻转句子中单词的顺序，但单词内的顺序不变。为简单起见，标点符号和普通字母一样处理。</span><br><span class="line">例如输入&quot;I am a student.&quot;则输出&quot;student. a am I&quot;</span><br></pre></td></tr></table></figure>

<h3 id="方法1：以空格为分隔符split"><a href="#方法1：以空格为分隔符split" class="headerlink" title="方法1：以空格为分隔符split"></a>方法1：以空格为分隔符split</h3><p>以空格为分隔符使用split，这就将字符串变成了单词数组。然后逆序遍历字单词数组，在除了最后一个单词外的其他每个单词后添加一个空格即可。</p>
<p>这道题需要考虑字符串中的字符全是空格的特殊情况，这种情况下没有任何单词，所以直接返回空字符串即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseWords</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用split,不能处理单词之间有多个空格的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.trim().equals(<span class="string">""</span>)) <span class="keyword">return</span> str;</span><br><span class="line">         </span><br><span class="line">         String[] words =str.split(<span class="string">" "</span>);</span><br><span class="line">         StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=words.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">             sb.append(words[i]);</span><br><span class="line">             <span class="keyword">if</span>(i&gt;<span class="number">0</span>) sb.append(<span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> sb.toString();</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法2：先整体反转再局部反转"><a href="#方法2：先整体反转再局部反转" class="headerlink" title="方法2：先整体反转再局部反转"></a>方法2：先整体反转再局部反转</h3><p>比如字符串”I am a student.”，整个翻转后得到”.tneduts a ma I”，然后翻转每个单词即可，将单词分隔开的依然是空格。该字符串有4个单词，做四次局部反转后就得到了结果”student. a am I”。</p>
<p>关键是要如何反转字符串的局部。可以设置两个指针，一个low指向局部字符串的头部，一个high指向局部字符串的尾部，一开始low和high都位于字符串的头部。当<strong>low指向的不是空格且high指向的字符是空格</strong>，此时就可以开始反转[low,high]内的字符串了….然后low和high继续向右移动，直到四个单词都被翻转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseWords</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：先整体反转，再局部反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars=str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=chars.length;</span><br><span class="line">        reverse(chars,<span class="number">0</span>,len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[low]==<span class="string">' '</span>)&#123;</span><br><span class="line">                low++;</span><br><span class="line">                high++; </span><br><span class="line">                <span class="comment">// chars[low]不为空格</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(high==len||chars[high]==<span class="string">' '</span>)&#123;</span><br><span class="line">                reverse(chars,low,--high);</span><br><span class="line">                low=++high;</span><br><span class="line">                 <span class="comment">// chars[low]和chars[high]都不为空格</span></span><br><span class="line">            &#125;<span class="keyword">else</span> high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = chars[high];</span><br><span class="line">            chars[high] = chars[low];</span><br><span class="line">            chars[low] = c;</span><br><span class="line">            low++;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到最后一个单词后面没有空格，但仍然需要翻转，所以<strong>翻转一个单词的条件是单词后面有空格或者单词的字符到达整个字符串的末尾。</strong>代码中先是–high使得子字符串中不含空格，之后后将++high赋值给low，那么下次判断low处必然是空格，此时<code>low == high == &#39; &#39;</code>，因此两个指针都要右移一位，以跳过空格。</p>
<p>如果low和high处的字符都不是空格，说明还没有到单词的末尾，因此直接将high右移即可。</p>
<p>这种方法对于单词之间有多个空格的情况也能正确处理。</p>
<h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符串的左旋操作是把字符串前面的若干个字符转移到字符串的尾部。</span><br><span class="line">比如输入字符串&quot;abcdefg&quot;和一个数字2，则左旋转后得到字符串&quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<h3 id="方法1：使用StringBuilder"><a href="#方法1：使用StringBuilder" class="headerlink" title="方法1：使用StringBuilder"></a>方法1：使用StringBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateString</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用StringBuilder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">leftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || n &lt; <span class="number">0</span> || n &gt; str.length()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        sb.append(sb.substring(<span class="number">0</span>, n));</span><br><span class="line">        <span class="keyword">return</span> sb.substring(n, sb.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法2：三次翻转——先局部翻转再整体翻转"><a href="#方法2：三次翻转——先局部翻转再整体翻转" class="headerlink" title="方法2：三次翻转——先局部翻转再整体翻转"></a>方法2：三次翻转——先局部翻转再整体翻转</h3><p>举个简单的例子”hello world”，按照上题的要求，会得到”world hello”. 而在此题中，假如要求将前五个字符左旋转，会得到” worldhello”(注意w前哟一个空格)，是不是接近了。</p>
<p>所以本题可以延续上题的思路，不过这次先局部翻转再整体反转。如字符串”abcdefg”要求左旋转前两个字符，先反转ab和cdefg得到bagfedc，然后反转这个字符串得到cdefgab即是正确答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateString</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 三次反转：索引n将字符串分成两个子字符串，分别反转这两个子字符串，然后反转整个字符串。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">leftRotateString2</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || n &lt; <span class="number">0</span> || n &gt; str.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        reverse(chars, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        reverse(chars, n, str.length() - <span class="number">1</span>);</span><br><span class="line">        reverse(chars, <span class="number">0</span>, str.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = chars[high];</span><br><span class="line">            chars[high] = chars[low];</span><br><span class="line">            chars[low] = c;</span><br><span class="line">            low++;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题59--队列的最大值</title>
    <url>/likemoves.github.io/2020/05/24/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9859--%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目1：滑动窗口的最大值。</span><br><span class="line">给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如，如果输入数组&#123;2, 3, 4, 2, 6, 2, 5&#125;以及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为&#123;4,4,6,6,6,5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法1：基于最大堆的优先队列"><a href="#方法1：基于最大堆的优先队列" class="headerlink" title="方法1：基于最大堆的优先队列"></a>方法1：基于最大堆的优先队列</h3><p>就以题目中的例子来模拟找出窗口中的最大值的过程。先存入3个元素，于是优先队列中有{2, 3,  4}，使用peek方法可以以O(1)的时间得到最大值，之后删除队列头的元素2，同时入列下一个元素，此时队列中有{3, 4,  2}，再调用peek方法得到最大值，然后删除队列头的3，下一个元素入列……不断重复进行此操作，直到最后队列中只有两个元素为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxInWindow</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：使用优先队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="keyword">null</span>||num.length&lt;size||size&lt;<span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            maxHeap.offer(num[i]);</span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size()&gt;=size)&#123;</span><br><span class="line">                list.add(maxHeap.peek());</span><br><span class="line">                maxHeap.remove(num[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目2-队列最大值"><a href="#题目2-队列最大值" class="headerlink" title="题目2 队列最大值"></a>题目2 队列最大值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义一个队列，实现max方法得到队列中的最大值。要求入列、出列以及邱最大值的方法时间复杂度都是O(1)</span><br></pre></td></tr></table></figure>

<p>一个dataQueue正常入列、出列元素，为了以O(1)的时间获取当前队列的最大值，需要使用一个maxQueue存放当前队列中最大值。具体来说就是，<strong>如果即将要存入的元素比当前最大值还大，那么存入这个元素；否则再次存入当前最大值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; maxDeque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; dataDeque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        dataDeque.offerLast(number);</span><br><span class="line">        <span class="keyword">if</span>(maxDeque.isEmpty()||number&gt;dataDeque.peekFirst())</span><br><span class="line">            maxDeque.offerFirst(number);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            maxDeque.offerFirst(dataDeque.peekFirst());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataDeque.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列已空"</span>);</span><br><span class="line">        dataDeque.pollFirst();</span><br><span class="line">        maxDeque.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxDeque.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列已空"</span>);</span><br><span class="line">        <span class="keyword">return</span> maxDeque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题45--把数组排成最小的数</title>
    <url>/likemoves.github.io/2020/05/15/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9845--%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这道题可以对数组排序，比如对于普通的数组{23, 12, 32}，可能会想到按照自然序排序后，得到{12, 23,  32}然后直接拼接起来就得到了最小的数字122332，但是像题中的例子按照自然序排好后就是{3, 32,  321}，如果直接拼接得到332321，是不是最小呢？可以发现排好后是{321, 32, 3}，才能得到最小数321323。<strong>可见这已经不是自然序了，所以想到需要自定义一种比较方法，得到一种新的排序方式。</strong></p>
<p>既然是要拼接数组中所有的数，保证拼接后的数最小，我们从最小的问题出发，当数组中只有两个数时，情况很简单，比如{3, 32}，有用两种方式拼接他们<code>&quot;3&quot;+&quot;32&quot;</code>和<code>&quot;32&quot;+&quot;3&quot;</code>，分别为332和323，因为323 &lt; 332，所以将32排在3的前面，也就是对于数组中的任意两个数m和n，如果mn &lt;  nm，则应该将m排在n的前面。在Java中很好实现，只需重写一个Comparator即可。使用Java 8的lambda表达式可以简化这一过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">printMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="keyword">null</span>||numbers.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a:Integer)&#123;</span><br><span class="line">        list.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    list.sort((a,b)-&gt;(a+<span class="string">""</span>+b).compareTo(b+<span class="string">""</span>+a));</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> a : list) &#123;</span><br><span class="line">          sb.append(a);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sb.toString();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题60--n个骰子的点数</title>
    <url>/likemoves.github.io/2020/05/25/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9860--n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把n个骰子扔在地上，所有骰子朝上的一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>n个骰子，我们可以投掷n次，累加每次掷出的点数即可。因此要求出n个骰子的点数和，可以从n个骰子先取出一个投掷，这一个骰子只可能出现1-6中的某一个数，我们需要计算的是1-6每个点数与剩下n -1个骰子的点数和；接下来进行第二次投掷，现在骰子堆中还有n - 1个骰子，对于这n  -1个骰子，继续从中选一个出来投掷，并在上次掷出的点数上累加…这显然是个递归过程。<strong>不断投掷，直到最后一个骰子也被投掷并累加点数，之后骰子数为0，也达到了递归终止的条件。</strong></p>
<p>一个骰子可能出现的点数和是1-6，两个骰子可能出现的点数和为2-12,三个骰子可能出现的点数和为3-18，因此n个骰子可能出现的点数为n-6n。可以用一个大小为6n - n + 1的数组存放每个可能的点数和出现的频率，比如该数组下标0处存放的是点数和为n的出现次数；而下标6n  -n处存放的是点数和6n的出现次数。n个骰子，每次投掷都有6种情况，因此总的点数和情况为6 ^  n种。要求某个点数和出现的概率，用该点数和出现的频次除以6 ^ n即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintProbability</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sideNum = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printProbability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal=n*sideNum;</span><br><span class="line">        <span class="keyword">int</span>[] pro=<span class="keyword">new</span> <span class="keyword">int</span>[maxVal-n+<span class="number">1</span>];</span><br><span class="line">        getProbabilities(n, n, <span class="number">0</span>, pro);</span><br><span class="line">        <span class="keyword">int</span> total=(<span class="keyword">int</span>)Math.pow(sideNum,n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= maxVal; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s="</span> + i + <span class="string">": "</span> + probabilities[i - n] + <span class="string">"/"</span> + total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *递归过程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getProbabilities</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> cur, <span class="keyword">int</span> sum, <span class="keyword">int</span>[] p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="number">0</span>) p[sum-n]++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=sideNum;i++)&#123;</span><br><span class="line">                getProbabilities(n,n-<span class="number">1</span>,sum+i,p)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>1.现在变量有：骰子个数，点数和。当有<strong>c</strong>个骰子，点数和为<strong>k</strong>时，出现次数记为<strong>dp(c,k)</strong>。那与c-1个骰子阶段之间的关系是怎样的？<br>2.当我有c-1个骰子时，再增加一个骰子，这个骰子的点数只可能为1、2、3、4、5或6。那k个骰子得到点数和为n的情况有：</p>
<p>(c-1,k-1)：第c个骰子投了点数1<br>(c-1,k-2)：第c个骰子投了点数2<br>(c-1,k-3)：第c个骰子投了点数3<br>….<br>(c-1,k-6)：第c个骰子投了点数6</p>
<p>在c-1个骰子的基础上，再增加一个骰子出现点数和为k的结果只有这6种情况！<br>所以：dp(c,k)=dp(c-1,k-1)+dp(c-1,k-2)+dp(c-1,k-3)+dp(c-1,k-4)+dp(c-1,k-5)+dp(c-1,k-6)(注意当k&lt;6时的处理越界问题) </p>
<p>3.有1个骰子，dp(1,1)=dp(1,2)=dp(1,3)=dp(1,4)=dp(1,5)=dp(1,6)=1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintProbability</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> sideNum = <span class="number">6</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 动态规划</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printProbabilityDP</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">int</span> maxVal = n * sideNum;</span><br><span class="line">       <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][maxVal+<span class="number">1</span>];</span><br><span class="line">       <span class="comment">//初始化dp(1, i) 1 &lt;= i &lt;= 6, 只有一个骰子，点数和为i的情况只有一种</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sideNum;i++)&#123;</span><br><span class="line">           dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 逐个增加骰子个数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// k个骰子可能的点数和是k~6*k</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> sum=i;sum&lt;=i*sideNum;sum++)&#123;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;sum&gt;k&amp;&amp;k&lt;=sideNum;k++)&#123;</span><br><span class="line">                   dp[i][sum]+=dp[i-<span class="number">1</span>][sum-k];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> total = (<span class="keyword">int</span>) Math.pow(sideNum, n);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> sum = n; sum &lt;= maxVal; sum++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"s="</span> + sum + <span class="string">": "</span> + f[n][sum] + <span class="string">"/"</span> + total);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题61--扑克牌中的顺子</title>
    <url>/likemoves.github.io/2020/05/26/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9861--%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从扑克牌中随机抽5张牌，判断是不是一个顺子，即这五张牌是不是连续的。2~10是数字本身，A为1，J为11，Q为12，K为13，而大小王可以看成任意数字。</span><br></pre></td></tr></table></figure>

<h3 id="方法1：用大小王填补间隔"><a href="#方法1：用大小王填补间隔" class="headerlink" title="方法1：用大小王填补间隔"></a>方法1：用大小王填补间隔</h3><p>正常的顺子比如23456，假如含有大小王呢？03467也能构成顺子，虽然4和6中间有一个间隔，但是因为存在一张大小王，刚好可以让它成为5而填补上4和6之间的间隔。再假设是00367也能构成顺子，3和6之间有两个间隔但是刚好有两个王可以填补。更特殊的02345, 00234, 这种没有本身间隔的牌组合，因为大小王可以作任何数字，显然也构成顺子。</p>
<p>接下来看不能构成顺子的例子，34578，以及03678或者00378，可以发现<strong>当王的个数比间隔数少的话就不能构成顺子，反之如果王的个数大于等于间隔数，就能构成顺子。</strong></p>
<p>要计算相邻两张牌的间隔，需要牌组合已经有序，因此第一步就要对五张牌排序。因此这种思路需要O(nlgn)的时间。</p>
<p>基于上述思路写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法1：排序，计算大小王的个数和总间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfZero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numOfInterval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = numbers.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(numbers);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算癞子数量</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                numOfZero++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对子，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numOfInterval += numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numOfZero &gt;= numOfInterval) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法2：顺子本身的规律"><a href="#方法2：顺子本身的规律" class="headerlink" title="方法2：顺子本身的规律"></a>方法2：顺子本身的规律</h3><p>五张牌组合成的顺子，都有哪些共性呢？如果牌中没有大小王，那么23456,  56789等这样的组合才是顺子；即五张牌中最大值和最小值的差始终是4，且任意两张牌不重复；现在假设有大小王（用0表示），02345、03467、00367都是顺子，但03678、00378不是顺子。发现大小王可多次出现，因此五张牌中0可以重复出现。除开0之外，其他牌不能重复出现且最大值与最小值的差小于5。综合以上两种情况，要想构成顺子，需要满足以下条件：</p>
<ul>
<li>除开0之外，其他任意牌不得重复出现</li>
<li>除开0之外的其他牌，最大值和最小值的差要小于5</li>
</ul>
<p>基于以上两条规则，可写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法2：除了0之外，其他数字不可重复出现；最大最小值差不得超过5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous2</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length != <span class="number">5</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">14</span>];</span><br><span class="line">        <span class="keyword">int</span> min=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">14</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> number:numbers)&#123;</span><br><span class="line">            count[number]++;</span><br><span class="line">             <span class="comment">// 对除了0之外的其他数计算最大最小值</span></span><br><span class="line">             <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count[number] &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (number &gt; max) max = number;</span><br><span class="line">                <span class="keyword">if</span> (number &lt; min) min = number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有0，最大最小值之差为4，有0还能凑成顺子的，差值小于4；大于4肯定不能凑成顺子</span></span><br><span class="line">        <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种思路无需排序，时间复杂度为是O(n)，但使用了额外空间，由于额外空间的大小固定为14，可以认为空间仍是常数级别的。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题62--圆圈中最后剩下的数字</title>
    <url>/likemoves.github.io/2020/05/27/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9862--%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0, 1, 2...,n - 1这n个数字排成一个圆圈，一开始从数字0开始，从这个圆圈里删除第m个数字；然后从被删除的数字后一位开始计数，继续删除第m个数字...重复这个过程，直到最后只剩一个数字为止。求出这个圆圈里剩下的最后一个数字。</span><br></pre></td></tr></table></figure>

<h3 id="用环形链表模拟圆圈"><a href="#用环形链表模拟圆圈" class="headerlink" title="用环形链表模拟圆圈"></a>用环形链表模拟圆圈</h3><p>比较直观的思路就是模拟游戏的过程，题目中说到圆圈而且要经常删除元素，因此容易想到用环形链表，但是Java内置的数据结构中没有环形链表，那么只好当遍历到链表末尾时转到链表头部。</p>
<p>举个简单的例子{0, 1, 2, 3, 4}和m = 3。从0开始第一个被删除的将是2，然后圆圈里剩下{0,1, 3,  4}，接下来从3开始计数，那么下一个被删除的将是0（注意这里到链表末尾所以转到了链表头），然后圆圈里剩下{1, 3,  4}从1开始计数下一个被删除的是4，现在圆圈里剩下{1, 3}，从下一个元素1开始计数，将被删除的元素是1，最后圆圈只剩下3了。</p>
<p>遍历到链表尾部需要转到链表头部，对于这个操作，可以设置一个整数p，表示链表中某元素的下标，每走一步p自增，走到链表尾部时（即p和链表长度相等），将该指针值置为0表示回到链表头部；同样如果删除的正好是链表的最后一个元素，下一个开始计数的应该是链表头部，所以这种情况下也要将p置为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastInCircle</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n 表示有多少个数字  m是删除的数据排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>||m&lt;=<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">                p++;</span><br><span class="line">                <span class="comment">// 走到链表尾部时</span></span><br><span class="line">                <span class="keyword">if</span>(p==list.size()) p=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(p);</span><br><span class="line">              <span class="comment">// 删除的正好是链表的最后一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(p==list.size()) p=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实<strong>取余操作可以模拟很多环形问题</strong>，因为n % n == 0，所以取余操作自动解决了到链表尾部时需要转到下标0的问题。所以本题只需用<code>removeIndex = （removeIndex + (m -1)） % list.size</code>就能得到本次要删除的元素的下标。</p>
<p>比如一开始链表的大小为5，运用上面的式子，要删除的元素下标是2 % 5 = 2；删除后链表大小变成4，下一个要删除的元素下标是(2 +  2) % 4 = 0;删除后链表大小变成3，下一个要删除的元素下标是(0 + 2) % 3 = 2…..跟着走一遍流程，没问题！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastInCircle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) list.add(i);</span><br><span class="line">        <span class="keyword">int</span> removeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 关键是这句</span></span><br><span class="line">            removeIndex = (removeIndex + m - <span class="number">1</span>) % list.size();</span><br><span class="line">            list.remove(removeIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h3><p>令 f(n, m) 为n个数字<code>0, 1, ...n -1</code>中删除第m个数字后，最后剩下的那个数字。</p>
<p>要删除第m个数字，因为从0开始计数，所以计数到m-1，在这n个数中，第一个被删除的是(m -1) % n，不妨设k =  (m -1) % n。删除k之后，剩下<code>0,1,...k-1,k+1,...n -1</code>下一个要从k+1开始计数。</p>
<p>既然从<code>k+1</code>开始计数，相当于把k+1放在最前面，<code>k+1,...n-1,0,1,k-1</code>由于此时打乱了数字排列的规律，该函数已不再是 f(n-1, m) 了，不妨表示为 f’(n -1, m) </p>
<p>现在把k + 1认为是0，k+2认为是1,以此类推，因为刚删除了一个元素，所以只有n-1个元素了，映射表如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0     -&gt;   k+1</span><br><span class="line">1     -&gt;   k+2</span><br><span class="line">...</span><br><span class="line">n-k-2 -&gt;   n-1</span><br><span class="line">n-k-1 -&gt;   0</span><br><span class="line">n-k   -&gt;   1</span><br><span class="line">n-2   -&gt;   k-1</span><br></pre></td></tr></table></figure>

<p>如果用x’表示重排后新序列中的元素（上表中箭头右边的数），x表示x’被当作的数字，那么有<code>x&#39; = (x + k + 1) % n</code> ，所以下式也成立</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f&apos;(n -1, m) = [f(n-1, m) + k + 1] % n</span><br></pre></td></tr></table></figure>

<p>还有，*<em>最初序列最后剩下的数字 f(n,m) 和删除一个数字后的序列最后剩下的数字时同一个，因此有 f(n,m)=f’(n-1, m) *</em></p>
<p>综合以上各式，再代入k = (m-1) % n</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n, m) = [f(n-1, m) + m] % n ,n &gt; 1</span><br></pre></td></tr></table></figure>

<p>且恒有<code>f(1, m) = 0, n = 1</code>，因为如果只有一个数（这个数是0），那么无需删除，最后一个剩下的数就是它。既然知道了 f(1, m) 根据上式就能求出 f(2, m) ，以此类推，只需一个循环就能求出 f(n, m) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastInCircle</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数学规律：约瑟夫环问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastNumInCycle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || m &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            f = (f + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题6--从尾到头打印链表</title>
    <url>/likemoves.github.io/2020/04/24/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%986--%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头打印链表每个节点的值。</span><br></pre></td></tr></table></figure>

<h3 id="解法一：使用栈"><a href="#解法一：使用栈" class="headerlink" title="解法一：使用栈"></a>解法一：使用栈</h3><p>典型的后进先出，使用栈，顺序遍历一遍链表，依次将每个值入栈。得到的就是尾节点在前，头节点在后的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(ListNode node=listNode;node!=<span class="keyword">null</span>;node=node.next)&#123;</span><br><span class="line">            stack.push(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrays=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            arrays.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p>要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; arrays=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            arrays.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">            arrays.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arrays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：头插法"><a href="#解法三：头插法" class="headerlink" title="解法三：头插法"></a>解法三：头插法</h3><p>使用头插法可以得到一个逆序的链表。<br>头结点和第一个节点的区别：<br>头结点是在头插法中使用的一个额外节点，这个节点不存储值；<br>第一个节点就是链表的第一个真正存储值的节点。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrays=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode next=<span class="keyword">null</span>;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next=listNode.next;</span><br><span class="line">            listNode.next=pre;</span><br><span class="line">            pre=listNode;</span><br><span class="line">            listNode=next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            arrays.add(pre.val);</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrays;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题63--股票的最大利润</title>
    <url>/likemoves.github.io/2020/05/27/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9863--%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设某股票的价格按照时间先后顺序存储在数组中，问买卖该股票一次可能获得的最大利润是多少？</span><br><span class="line">如一支股票在某段时间内的价格为&#123;9, 11, 8, 5, 7, 12, 16, 14&#125;那么能在价格为5的时候购入并在价格为16时卖出，能获得最大利润11</span><br></pre></td></tr></table></figure>

<p>咋一看好像只要求出数组中的最大/最小值就完事了，但是数组中的值是按照时间顺序排列的，这就是说假如数组中最小值在最大值之后，它们的差值不会是股票的最大利润。因此我们要求的是数组中<strong>排在后面的数（售出价格）与排在前面的数（购入价格）的最大差值</strong>。</p>
<p>假设当前访问的数组下标是i，<strong>只需记住当前下标之前所有元素中的最小值即可</strong>，用一个int型的变量min维护这个最小值，每次用当前数字和min作差，差值用maxDiff保存，遍历一遍数组即可得出最大的差值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxDiff</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxDiff</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min=prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxDiff=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;min) min=prices[i];</span><br><span class="line">            <span class="keyword">int</span> curDiff=prices[i] - min;</span><br><span class="line">            <span class="keyword">if</span>(curDiff&gt;maxDiff) maxDiff=curDiff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="股票问题-推荐阅读"><a href="#股票问题-推荐阅读" class="headerlink" title="股票问题 推荐阅读"></a>股票问题 推荐阅读</h3><p> <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen</a></p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题64--求1+2+3+...+n</title>
    <url>/likemoves.github.io/2020/05/28/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9864--%E6%B1%821+2+3+...+n/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">求1+2+3+...+n,要求不能使用乘除法、for、while、if、else、switch、case等关键词以及三元运算符等。</span><br></pre></td></tr></table></figure>

<h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> n+Sum_Solution(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是题目又要求不能用if语句，那就把if替换掉吧。<strong>使用逻辑与的短路特性</strong>可以构造出一个条件语句出来，逻辑与的短路特性是指：如果前面的条件已经不成立，后面的条件不会被判断了。上面的递归中当<code>n == 1</code>时就终止递归了直接返回n（也就是1）；所以只需将上面程序改一改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b=n&gt;<span class="number">0</span>&amp;&amp;(sum+=Sum_solution(n-<span class="number">1</span>)) &gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当n &gt; 0时，逻辑与两边都是true，因此递归会继续深入下去，但是当n == 1时，进行最后一次递归此时n == 0, <code>boolean b</code>由于不满足n &gt; 0的条件，所以后面的递归不会得到执行，此时直接返回了<code>sum == n == 1</code>，和if语句达到了异曲同工的作用。</p>
<h3 id="方法二：数据公式"><a href="#方法二：数据公式" class="headerlink" title="方法二：数据公式"></a>方法二：数据公式</h3><p>利用等差数列公式</p>
<p>sum=n(n+1)/2;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span>)Math.pow(n,<span class="number">2</span>)+n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>&gt;&gt; 1</code>表示右移一位，其实就是除以2。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题67--把字符串转换成整数</title>
    <url>/likemoves.github.io/2020/05/29/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9867--%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> str2Int &#123;</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">      <span class="comment">// '4'的ASCII码就比'0'的ASCII码大4，所以可以减去'0'的ASCII码将字符转数字</span></span><br><span class="line">          number = number * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>s.charAt(i)</code>取出的每一位是ASCII码，需要将其转换为数字。<strong>我们知道字符’0’ ~’9’在ASCII码表中是连续的，这意味着字符’4’就比字符’0’大4，因此任何数字字符减去’0’的ASCII码得到的值就是该数字字符对应的数字。</strong></p>
<p>可是这样的程序稳定吗？试想下面的测试用例<code>[null,&quot;&quot;, &quot;+34&quot;, &quot;-56&quot;]</code>，任意一个都不能通过测试。<strong>因此一定要考虑边界条件和错误检查。</strong></p>
<p>首先判断是否为空指针，否则一切方法调用都会引发空指针异常，然后是空字符串判断；之后对于字符串的首字符要特殊对待，首字符除了可以是数字，还可以是正负号，首字符之后的其他字符只能是数字。</p>
<p>再看细节，如果首字符是负号，那么在返回数字的时候也应该是负数。如果首字符是正号，我们知道符号可以省略不写。再次，如果字符串转换成数字后<strong>溢出</strong>，应该返回0。最后对于包括溢出在内的各种非法输入，约定返回0，可如果我们输入的就是’0’，转换的结果也是0，这种情况下根据返回值0要怎么区分到底是非法输入呢还是本身就是输入了0？这里我们准备使用一个全局的布尔变量用以区分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Str2Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> valid;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        valid=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">long</span> number=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">             <span class="comment">// 第一位是正负号就跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;str.charAt(i)==<span class="string">'+'</span>||str.charAt(i)==<span class="string">'-'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.charAt(i)==<span class="string">'-'</span>)&#123;</span><br><span class="line">                     isNegative=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(str.length()==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;               </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 中间有任何字符不是数字直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &lt; <span class="string">'0'</span> || str.charAt(i) &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="keyword">int</span> flag = isNegative ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">             <span class="comment">// '4'的ASCII码就比'0'的ASCII码大4，所以可以减去'0'的ASCII码将字符转数字</span></span><br><span class="line">            number = number * <span class="number">10</span> + flag * (str.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (!isNegative &amp;&amp; number &gt; Integer.MAX_VALUE || isNegative &amp;&amp; number &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全部字符都检查过了，说明字符串合法</span></span><br><span class="line">        valid = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)number;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题68--树中两个结点的最低公共祖先</title>
    <url>/likemoves.github.io/2020/05/30/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9868--%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一棵树的两个结点，返回它们的最低公共祖先。</span><br></pre></td></tr></table></figure>

<p>这道题说得很含糊，仅仅告诉了<em>一棵树，</em>那这棵树是二叉树吗？再具体点，它是二叉查找树吗？我们来一一讨论这这几种情况。</p>
<h3 id="如果这颗树是二叉查找树"><a href="#如果这颗树是二叉查找树" class="headerlink" title="如果这颗树是二叉查找树"></a>如果这颗树是二叉查找树</h3><p>二叉查找树的特点是：<strong>任意父节点都大于其左子树的所有结点值，且都小于其右子树的所有结点值</strong>。两个结点的公共祖先一定是大于其中较小的那个且小于其中较大的那个，而<strong>从根结点开始从上到下遇到的第一个位于两个输入结点值之间的结点就是最低的公共祖先。</strong></p>
<p>于是我们可以这么做：从根结点开始，和两个输入结点的值比较，如果当前结点比两个输入都小，那么最低公共祖先一定在当前结点的右子树中，所以下步遍历右子树；如果当前结点比两个输入都大，那么最低公共祖先一定在当前结点的左子树中，所以遍历左子树……直到找到第一个位于两个输入结点值之间的结点就是最低的公共祖先。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findLastSame</span><span class="params">(Node root, Node a, Node b)</span> </span>&#123;</span><br><span class="line">    Node cur=root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val&lt;a.val&amp;&amp;cur.val&lt;b.val)&#123;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val&gt;a.val&amp;&amp;cur.val&gt;b.val)&#123;</span><br><span class="line">            cur=cur.left</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拥有指向父结点的指针"><a href="#拥有指向父结点的指针" class="headerlink" title="拥有指向父结点的指针"></a>拥有指向父结点的指针</h3><p>如果这棵树只是一颗普通的树，但是它拥有指向父结点的指针，该如何求最低公共祖先呢。</p>
<p>这个问题就更简单了，拥有指向父结点的话，<strong>这棵树从下往上看，就是若干条链表汇集在根结点处。我们要找的就是这两个结点的第一个公共结点。</strong></p>
<p>之前刚好做过一道题<em>面试题52</em>就是求两个链表的第一个公共结点，直接把代码拿过来就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变成了两条链表的第一个公共结点问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findLastSame</span><span class="params">(Node node1, Node node2)</span> </span>&#123;</span><br><span class="line">        Node cur1=node1;</span><br><span class="line">        Node cur2=node2;</span><br><span class="line">        <span class="keyword">int</span> len1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len2=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算链表1的长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            cur1=cur1.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//计算链表2的长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            cur2=cur2.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        cur1=node1;</span><br><span class="line">        cur2=node2;</span><br><span class="line">        <span class="comment">//长链表先走若干步，和短链表的尾部对齐</span></span><br><span class="line">        <span class="keyword">if</span>(len2&gt;len1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2-len1;i++)&#123;</span><br><span class="line">                cur2=cur2.parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len2&lt;len1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1-len2;i++)&#123;</span><br><span class="line">                cur1=cur1.parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同时前进，第一个相等的结点即是</span></span><br><span class="line">        <span class="keyword">while</span>(cur1!==<span class="keyword">null</span>&amp;&amp;cur2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1==cur2) <span class="keyword">return</span> cur1;</span><br><span class="line">            cur1=cur1.parent;</span><br><span class="line">            cur2=cur2.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通树，没有指向父结点的指针"><a href="#普通树，没有指向父结点的指针" class="headerlink" title="普通树，没有指向父结点的指针"></a>普通树，没有指向父结点的指针</h3><p>这道题再加大难度，如果没有指向父结点的指针呢？是否还能转换成两个链表的第一个公共结点来解决？</p>
<p>想办法创造链表。两个输入结点如果在树中存在，那么<strong>从根结点开始向下的某条路径中必然包含这个结点</strong>，使用两个链表分别保存包含这两个结点的路径。这样就可以把问题转换成求两个链表的第一个公共结点了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输入一棵普通树的两个结点，返回它们的最低公共祖先。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastSameInTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        List&lt;Node&gt; children;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">findLastSame</span><span class="params">(Node root, Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Node&gt; path1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Node&gt; path2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        collectNode(root, a, path1);</span><br><span class="line">        collectNode(root, b, path2);</span><br><span class="line">        <span class="keyword">return</span> getLastSameNode(path1, path2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收集含有结点node的路径上的所有结点，形成一条链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">collectNode</span><span class="params">(Node root, Node node, LinkedList&lt;Node&gt; path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == node) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        path.add(root);</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            <span class="keyword">if</span> (collectNode(child, node, path)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该条路径上没找到结点node就要从路径中移除</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个链表前面的结点都是相同的，找到最后一个相同的结点就是最低公共祖先</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getLastSameNode</span><span class="params">(LinkedList&lt;Node&gt; path1, LinkedList&lt;Node&gt; path2)</span> </span>&#123;</span><br><span class="line">        Node lastSameNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!path1.isEmpty() &amp;&amp; !path2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path1.peekFirst() == path2.removeFirst()) &#123;</span><br><span class="line">                lastSameNode = path1.removeFirst();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> lastSameNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastSameNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，路径是从根结点向下的，所以两个链表前面的结点都是相同的，这样就把<strong>两个链表的第一个公共结点问题转换成了两个链表的最后一个相等的结点</strong>，这两个命题是等价的。</p>
<p>得到两条路径需要遍历树两次，每次都是O(n)的时间，而每条路径需要的空间在平均情况下是O(\lg n),最差情况下(树退化成链表)是O(n)</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题66--构建乘积数组</title>
    <url>/likemoves.github.io/2020/05/29/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9866--%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组A[0, 1,...n - 1],请构建一个数组B[0, 1,...n - 1]，其中B中的元素B[i] = A[0]*A[1]*...*A[i - 1]*A[i + 1]*...*A[n - 1]</span><br><span class="line"></span><br><span class="line">不能使用除法。</span><br></pre></td></tr></table></figure>

<p>如果可以使用除法，直接除以A[i]就可以得到B[i],但是现在要求了不能使用除法，只好另辟蹊径了。</p>
<p>一种方法是剔除A[i]进行连乘计算B[i],计算一次的时间是  O(n) ，需要计算n次所以总的时间复杂度为 O(n^2) </p>
<p>有没有 O(n) 的算法呢。</p>
<p>注意到B[i]是 <strong>除了A[i]</strong> 之外A[0]到A[n - 1]的连乘。那么可以考虑从A[i]处将乘积分成两部分。<code>C[i] = A[0]*A[1]*...*A[i - 1]，D[i] = A[i + 1]*...A[n - 2]*A[n -1]</code>;</p>
<p>而<code>C[i] = C[i -1]*A[i -1],D[i] = D[i + 1]*A[i + 1]</code></p>
<p>根据这些关系计算出C[i]和D[i]，最后求得<code>B[i] = C[i] * D[i]</code>即可。</p>
<p><img src="https://s1.ax1x.com/2020/05/29/tn65As.png" alt="tn65As.png"></p>
<p>如上图，表中每一行的第一个数就是其后每个数字连乘，没有被乘上的数字A[i]就用1表示了，反正乘积不变。显然C[0] = 1,我们可以用<code>C[i] = C[i -1]*A[i -1]</code>计算出对角线左边的三角中各个A[i]的值；显然D[n -1] = 1,再<code>D[i] = D[i + 1]*A[i + 1]</code>计算对角线右边的三角中各个A[i]的值，然后将两者相乘就能得到B[i]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len=A.length;</span><br><span class="line">        <span class="keyword">int</span> [] B=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="comment">//计算C[i]</span></span><br><span class="line">            B[i]=B[i-<span class="number">1</span>]*A[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">// 计算D[i]</span></span><br><span class="line">            temp=temp*A[j+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// B[i] = C[i] * D[i]</span></span><br><span class="line">            B[j]=B[j]*temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上图所示，可以发现：</p>
<p>　　　　B[i]的左半部分(红色部分)和B[i-1]有关（将B[i]的左半部分乘积看成C[i]，有C[i]=C[i-1]*A[i-1]），</p>
<p>　　　　B[i]的右半部分(紫色部分)与B[i+1]有关（将B[i]的右半部分乘积看成D[i]，有D[i]=D[i+1]*A[i+1]），</p>
<p>　　因此我们先从0到n-1遍历，计算每个B[i]的左半部分； 然后定义一个变量temp代表右半部分的乘积，从n-1到0遍历，令B[i]<em>=temp，而每次的temp与上次的temp关系即为temp</em>=A[i+1]。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题7--重建二叉树</title>
    <url>/likemoves.github.io/2020/04/24/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%987--%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;，则重建二叉树并返回。</span><br></pre></td></tr></table></figure>

<p>由中序遍历序列和前序或后序任一序列就能确定唯一的一棵二叉树，中序遍历序列是必须要的。</p>
<p>通过前序遍历可以找到整个二叉树的根节点，由此可以得到中序序列中根节点的位置，该节点将中序序列分为左右子树，</p>
<p><strong>前序遍历的第一个结点就是树的根结点；在中序遍历里找到这个结点，其左边的结点都是根结点的左子树，其右边的结点都是根结点的右子树。假如根结点左边有M个结点，那么在前序序列中，根结点后的M个结点也是属于根结点的左子树的。前序序列中余下的后面的结点自然属于根结点的右子树</strong>。这样就可以把中序遍历的数组从根结点处分解成左右子树（对应的有两个子数组），然后递归地对这两个子数组执行同样的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        TreeNode root = reConstructBinaryTree( in, <span class="number">0</span>, in.length - <span class="number">1</span>,pre, <span class="number">0</span>, pre.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 中序序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inStart  中序左子树开始指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inEnd   中序右子树结束指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre 前序序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preStart  前序左子树开始指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preEnd 前序左子树结束指针</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  树的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * i为根节点所在位置</span></span><br><span class="line"><span class="comment">     * 中序左子树区间[inStart,i-1] 共i-inStart个数字</span></span><br><span class="line"><span class="comment">     * 中序右子树区间[i+1,inEnd]   共inEnd-i个数字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 前序左子树区间[preStart+1,preStart+i-inStart]</span></span><br><span class="line"><span class="comment">     * 前序右子树区间[preStart+i-inStart+1,preEnd]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] in, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd,<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inStart&gt;inEnd||preStart&gt;preEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootVal=pre[preStart];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=inStart;i&lt;=inEnd;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i]==rootVal)&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(in,inStart,i-<span class="number">1</span>,pre,preStart+<span class="number">1</span>,preStart+i-inStart);</span><br><span class="line">                root.right=reConstructBinaryTree(in,<span class="number">1</span>+i,inEnd,pre,preStart+i-inStart+<span class="number">1</span>,preEnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题8--二叉树中序遍历的下一个结点</title>
    <url>/likemoves.github.io/2020/04/25/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%988--%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>要找出中序遍历的下一个结点，要分几种情况探讨。</p>
<p>1.如果当前结点的右子结点<strong>不为空</strong>，那么下一个结点就是以该右子结点为根的子树的最左子结点；</p>
<p>如果<strong>当前结点的右子结点为空</strong>，看它的<strong>父结点</strong>。此时分两种情况</p>
<p>2.如果父结点的右子结点就是当前结点，说明这个父结点在中序遍历中已经被访问过了，需要继续往上看其父结点…直到父结点的左子结点是当前结点为止，该父结点就是下一个结点。</p>
<p>3.如果在一直往上的过程中已经到达根结点，而根结点的父结点为null，这种情况说明当前结点已经是中序序列的最后一个结点了，不存在下一个结点，应该返回null.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InOrderNextNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeLinkNode left = <span class="keyword">null</span>;</span><br><span class="line">        TreeLinkNode right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// next指向父结点</span></span><br><span class="line">        TreeLinkNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeLinkNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前结点右子树不空，那么中序下一个结点是右子树的最左子结点（如果有的话）；如果右子树没有左子结点就返回右子树根结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前子结点pNode右子树为空</span></span><br><span class="line">        <span class="comment">// 返回上层的父结点，如果父结点的右子结点就是当前结点，继续返回到上层的父结点...直到父结点的左子结点等于当前结点</span></span><br><span class="line">        <span class="keyword">while</span> (pNode.pre != <span class="keyword">null</span> &amp;&amp; pNode.pre.right == pNode) &#123;</span><br><span class="line">            pNode =  pNode.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父结点的左子结点等于当前结点，说明下一个要遍历的结点就是父结点了；或者父结点为空（说明当前结点是root），还是返回父结点（null）</span></span><br><span class="line">        <span class="comment">// pNode.pre == null 或者 pNode.pre.left == pNode</span></span><br><span class="line">        <span class="keyword">return</span> pNode.pre  ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题9--两个栈实现队列</title>
    <url>/likemoves.github.io/2020/04/25/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%989--%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</span><br></pre></td></tr></table></figure>

<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><ul>
<li>stack1专门用于进入队列</li>
<li>stack2专门用于出队列</li>
<li>出列操作。stack2不为空就直接出列；为空就将stack1中所有元素压入stack2中，再弹出栈顶元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStackImpQueue</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Interger&gt; stack1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Interger&gt; stack2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//stack1专门用于进入队列</span></span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dequeue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty()&amp;&amp;stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>实现秒杀系统</title>
    <url>/likemoves.github.io/2020/05/12/%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="实现用户登录以及分布式session"><a href="#实现用户登录以及分布式session" class="headerlink" title="实现用户登录以及分布式session"></a>实现用户登录以及分布式session</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>1.用户第一次登陆，本身没有携带cookie，同时redis也没有token记录</p>
<p>2.通过数据库验证用户手机号以及密码</p>
<p>3.验证通过生成token，同时写入redis以及cookie中返回</p>
<p>4.此后用户携带cookie进行登录</p>
<p>5.从cookie中提取token，到redis中查询</p>
<p>6.如果存在直接判定登录成功，如果失败则需要重新登录</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>商品表</p>
<p>秒杀商品表</p>
<p>订单表</p>
<p>秒杀订单表</p>
<h2 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h2><p>商品列表页</p>
<p>商品详情页</p>
<p>订单详情页</p>
<h2 id="秒杀流程"><a href="#秒杀流程" class="headerlink" title="秒杀流程"></a>秒杀流程</h2><p>1.数据减库存 </p>
<p>去秒杀商品表 stock_count减一</p>
<p>2.创建订单 </p>
<p>去订单表 插入一条数据</p>
<p>3.写入秒杀订单</p>
<p>去秒杀订单表 插入一条数据</p>
<p>整个流程是一个事务 ，原子性要么全部成功要么全部失败</p>
<h2 id="接口优化"><a href="#接口优化" class="headerlink" title="接口优化"></a>接口优化</h2><h3 id="解决超卖问题"><a href="#解决超卖问题" class="headerlink" title="解决超卖问题"></a>解决超卖问题</h3><p>1.数据库加唯一索引：防止用户重复购买</p>
<p>2.SQL加库存数量判断，防止库存变成负数</p>
<h3 id="减少数据库访问"><a href="#减少数据库访问" class="headerlink" title="减少数据库访问"></a>减少数据库访问</h3><p>1.系统初始化，把商品库存数量加载到Redis</p>
<p>2.收到请求，Redis预减库存，库存不足，直接返回，否则进入3</p>
<p>3.请求入队（消息队列），立即返回排队中</p>
<p>4.请求出队，生成订单，减少库存</p>
<p>5.客户端轮询，是否秒杀成功</p>
<h2 id="rabbitMQ使用"><a href="#rabbitMQ使用" class="headerlink" title="rabbitMQ使用"></a>rabbitMQ使用</h2><h3 id="linux系统下常用指令"><a href="#linux系统下常用指令" class="headerlink" title="linux系统下常用指令"></a>linux系统下常用指令</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 启动rabbitmq服务</span><br><span class="line">sudo service rabbitmq-server start </span><br><span class="line"># 关闭rabbitmq服务</span><br><span class="line">sudo service rabbitmq-server stop</span><br><span class="line"># 重启服务</span><br><span class="line">sudo service rabbitmq-server restart</span><br><span class="line"># 查看服务运行状态</span><br><span class="line">sudo service rabbitmqctl status</span><br></pre></td></tr></table></figure>

<h3 id="四种交换机类型"><a href="#四种交换机类型" class="headerlink" title="四种交换机类型"></a>四种交换机类型</h3><h4 id="1-Direct-Exchange"><a href="#1-Direct-Exchange" class="headerlink" title="1.Direct Exchange"></a>1.Direct Exchange</h4><p>处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键  “abc”，则只有被标记为“abc”的消息才被转发，不会转发abc.def，也不会转发dog.ghi，只会转发abc。</p>
<h4 id="2-Fanout-Exchange"><a href="#2-Fanout-Exchange" class="headerlink" title="2.Fanout Exchange"></a>2.Fanout Exchange</h4><p>不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。</p>
<h4 id="3-Topic-Exchange"><a href="#3-Topic-Exchange" class="headerlink" title="3.Topic Exchange"></a>3.Topic Exchange</h4><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.</em>” 只会匹配到“abc.def”。</p>
<h4 id="4-Headers-Exchanges"><a href="#4-Headers-Exchanges" class="headerlink" title="4.Headers Exchanges"></a>4.Headers Exchanges</h4><p>不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers属性是一个键值对，可以是Hashtable，键值对的值可以是任何类型。而fanout，direct，topic 的路由键都需要要字符串形式的。</p>
<p>匹配规则x-match有下列两种类型：</p>
<p>x-match = all ：表示所有的键值对都匹配才能接受到消息</p>
<p>x-match = any ：表示只要有键值对匹配就能接受到消息</p>
<h2 id="系统特点"><a href="#系统特点" class="headerlink" title="系统特点"></a>系统特点</h2><h3 id="1-明文密码而两次md5入库"><a href="#1-明文密码而两次md5入库" class="headerlink" title="1.明文密码而两次md5入库"></a>1.明文密码而两次md5入库</h3><p>两次MD5</p>
<p>1.用户端：PASS=MD5(明文+固定Salt)  防止明文传输</p>
<p>2.服务端：PASS=MD5(用户输入+随机Salt)  </p>
<p>固定Salt是写死在程序中</p>
<p>随机Salt是在用户注册过程中 随机生成 并且存储于数据库中</p>
<h3 id="2-分布式session"><a href="#2-分布式session" class="headerlink" title="2.分布式session"></a>2.分布式session</h3><p>用户登录系统，随机产生token，并且将其存入redis缓存中，key=token，value=user对象</p>
<p>之后将token存入cookie返回浏览器，此后用户在系统中会时刻保持cookie的状态。</p>
<h3 id="3-JSR303自定义参数验证"><a href="#3-JSR303自定义参数验证" class="headerlink" title="3. JSR303自定义参数验证"></a>3. JSR303自定义参数验证</h3><p>使用JSR303自定义校验器，实现对用户账号、密码的验证，使得验证逻辑从业务代码中脱离出来。</p>
<h3 id="4-全局异常统一处理"><a href="#4-全局异常统一处理" class="headerlink" title="4. 全局异常统一处理"></a>4. 全局异常统一处理</h3><p>通过拦截所有异常，对各种异常进行相应的处理，当遇到异常就逐层上抛，一直抛到最终由一个统一的、专门负责异常处理的地方处理，这有利于对异常的维护。</p>
<h3 id="5-页面缓存-对象缓存"><a href="#5-页面缓存-对象缓存" class="headerlink" title="5. 页面缓存 + 对象缓存"></a>5. 页面缓存 + 对象缓存</h3><ol>
<li>页面缓存：通过在手动渲染得到的html页面缓存到redis</li>
<li>对象缓存：包括对用户信息、商品信息、订单信息和token等数据进行缓存，利用缓存来减少对数据库的访问，大大加快查询速度。</li>
</ol>
<h3 id="6-页面静态化"><a href="#6-页面静态化" class="headerlink" title="6. 页面静态化"></a>6. 页面静态化</h3><p>对商品详情和订单详情进行页面静态化处理，页面是存在html，动态数据是通过接口从服务端获取，实现前后端分离，静态页面无需连接数据库打开速度较动态页面会有明显提高</p>
<h3 id="7-本地标记-redis预处理-RabbitMQ异步下单-客户端轮询"><a href="#7-本地标记-redis预处理-RabbitMQ异步下单-客户端轮询" class="headerlink" title="7. 本地标记 + redis预处理 + RabbitMQ异步下单 + 客户端轮询"></a>7. 本地标记 + redis预处理 + RabbitMQ异步下单 + 客户端轮询</h3><p>描述：通过三级缓冲保护，1、本地标记  2、redis预处理  3、RabbitMQ异步下单，最后才会访问数据库，这样做是为了最大力度减少对数据库的访问。</p>
<p>实现：</p>
<ol>
<li>在秒杀阶段使用本地标记对用户秒杀过的商品做标记，若被标记过直接返回重复秒杀，未被标记才查询redis，通过本地标记来减少对redis的访问</li>
<li>抢购开始前，将商品和库存数据同步到redis中，所有的抢购操作都在redis中进行处理，通过Redis预减少库存减少数据库访问</li>
<li>为了保护系统不受高流量的冲击而导致系统崩溃的问题，使用RabbitMQ用异步队列处理下单，实际做了一层缓冲保护，做了一个窗口模型，窗口模型会实时的刷新用户秒杀的状态。</li>
<li>client端用js轮询一个接口，用来获取处理状态</li>
</ol>
<h3 id="8-解决超卖"><a href="#8-解决超卖" class="headerlink" title="8. 解决超卖"></a>8. 解决超卖</h3><p>描述：比如某商品的库存为1，此时用户1和用户2并发购买该商品，用户1提交订单后该商品的库存被修改为0，而此时用户2并不知道的情况下提交订单，该商品的库存再次被修改为-1，这就是超卖现象</p>
<p>实现：</p>
<ol>
<li>对库存更新时，先对库存判断，只有当库存大于0才能更新库存</li>
<li>对用户id和商品id建立一个唯一索引，通过这种约束避免同一用户发同时两个请求秒杀到两件相同商品</li>
<li>实现乐观锁，给商品信息表增加一个version字段，为每一条数据加上版本。每次更新的时候version+1，并且更新时候带上版本号，当提交前版本号等于更新前版本号，说明此时没有被其他线程影响到，正常更新，如果冲突了则不会进行提交更新。当库存是足够的情况下发生乐观锁冲突就进行一定次数的重试。</li>
</ol>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>秒杀</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题65--不用加减乘除做加法</title>
    <url>/likemoves.github.io/2020/05/28/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9865--%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写一个函数，求两个整数之和，要求在函数体内不得使用&quot;+&quot;、&quot;-&quot;、&quot;x&quot;、&quot;÷&quot;四则运算符号。</span><br></pre></td></tr></table></figure>

<p>不能用四则运算，自然容易想到用位运算。但如何使用位运算作加法呢？先来分析十进制是如何作加法的。比如要<code>18 + 6</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1 8</span><br><span class="line">+ 0 6</span><br><span class="line">——————</span><br><span class="line">  1 4</span><br><span class="line">+ 1 0</span><br><span class="line">——————</span><br><span class="line">  2 4</span><br><span class="line"></span><br><span class="line">1) 个位和个位相加，十位与十位相加，但不进位；</span><br><span class="line">2) 6 + 8产生一位进位得到10，1 + 0不产生进位；</span><br><span class="line">3) 不进位的和14 + 个位的进位10 = 24。</span><br><span class="line"></span><br><span class="line">没有进位了，计算停止。</span><br></pre></td></tr></table></figure>

<p>可以看到十进制作加法可以细分为以上三步。那么对于二进制的加法呢？18的二进制是10010，5的二进制是111</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  10010</span><br><span class="line">+ 00110</span><br><span class="line">————————</span><br><span class="line">  10100</span><br><span class="line">+ 00100   （还有进位，继续计算）</span><br><span class="line">————————</span><br><span class="line">  10000</span><br><span class="line">+ 01000   （没有进位，停止计算）</span><br><span class="line">————————</span><br><span class="line">  10100</span><br></pre></td></tr></table></figure>

<p>10100正好是24的十进制表示。换成二进制作加法，原理一样。关键是：<strong>如果还有进位，要不断累加，直到没有进位，此时计算才停止。</strong></p>
<p>对于二进制，<strong>不进位的的加法就是异或运算，计算进位只需将两个数相与并向左移一位（也就是进位）。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// num2 != 0 说明还有进位需要相加</span></span><br><span class="line">        <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中sum表示不进位的加法和，carry表示进位，每次迭代都将sum和carry进行不进位相加，num2等于0（即不再有进位）时，退出循环返回num1即可。</p>
<h2 id="扩展–不引用新变量交换两个变量"><a href="#扩展–不引用新变量交换两个变量" class="headerlink" title="扩展–不引用新变量交换两个变量"></a>扩展–不引用新变量交换两个变量</h2><p>一般写个swap方法，需要引入第三个变量。如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;java</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要交换的数据类型是int型的数字，如何不使用新的变量，交换两个变量的值？使用如下的运算即可完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a  = a - b;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>手写一个Lock实现类</title>
    <url>/likemoves.github.io/2020/05/09/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AALock%E5%AE%9E%E7%8E%B0%E7%B1%BB/</url>
    <content><![CDATA[<p># </p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>锁的实现需要：</p>
<p> 两个方法：lock()、unlock()</p>
<p> 两个组件：锁的持有者、等待队列</p>
<p> 一个变量：锁的状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by admin on 2020/5/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TuLingLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前枷锁状态，记录加锁次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> Thread lockHolder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程安全队列</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Thread&gt; waiters=<span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="comment">//CAS比较与交换原子算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread current=Thread.currentThread();</span><br><span class="line">        <span class="comment">///锁初始状态</span></span><br><span class="line">        <span class="keyword">int</span> c=getState();</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//同步器还没有被持有</span></span><br><span class="line">            <span class="keyword">if</span> ((waiters.size()==<span class="number">0</span>||waiters.peek()==current)&amp;&amp;compareAndSwapState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//该线程持有锁线程</span></span><br><span class="line">                setLockHolder(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (acquire())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread current=Thread.currentThread();</span><br><span class="line">        <span class="comment">//未获取到锁，进入阻塞队列</span></span><br><span class="line">        waiters.add(current);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋转等待</span></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//方法一</span></span><br><span class="line">           <span class="comment">// Thread.yield();//尽力让出cpu使用权，但不保证不使用cpu  不适用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;  等待以及唤醒需要大量上下文切换   不适用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((current==waiters.peek())&amp;&amp;acquire())&#123;</span><br><span class="line">                waiters.poll();<span class="comment">//T2从队列当中移除</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法三</span></span><br><span class="line">            <span class="comment">//阻塞当前线程</span></span><br><span class="line">            LockSupport.park(current);<span class="comment">//保存对线程的引用  队列</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是获取锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread()!=lockHolder)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"lockHolder is not current thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取锁的状态</span></span><br><span class="line">        <span class="keyword">int</span> state=getState();</span><br><span class="line">        <span class="comment">//原子操作解锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSwapState(state,<span class="number">0</span>))&#123;</span><br><span class="line">            setLockHolder(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//从阻塞队列唤醒其他线程（公平锁）</span></span><br><span class="line">            Thread first=waiters.peek();</span><br><span class="line">            <span class="keyword">if</span> (first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                LockSupport.unpark(first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapState</span><span class="params">(<span class="keyword">int</span> except,<span class="keyword">int</span> update)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>,stateOffset,except,update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe=reflectGetUnsafe();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//找到state在对象内存中的偏移量</span></span><br><span class="line">            stateOffset=unsafe.objectFieldOffset(TuLingLock.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子操作  使用反射方法获取Unsafe类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">reflectGetUnsafe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Field filed=Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            filed.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> (Unsafe)filed.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">getLockHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lockHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLockHolder</span><span class="params">(Thread lockHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockHolder = lockHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java多线程</tag>
        <tag>java锁</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/likemoves.github.io/2020/04/28/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%20-%20%E5%A6%82%E4%BD%95%E5%9C%A8100%E4%B8%AA%E4%BA%BFURL%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD%E6%9F%90URL%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9F/</url>
    <content><![CDATA[<h5 id="本文转载自：https-www-cnblogs-com-kyoner-p-11109536-html"><a href="#本文转载自：https-www-cnblogs-com-kyoner-p-11109536-html" class="headerlink" title="本文转载自：https://www.cnblogs.com/kyoner/p/11109536.html"></a>本文转载自：<a href="https://www.cnblogs.com/kyoner/p/11109536.html" target="_blank" rel="noopener">https://www.cnblogs.com/kyoner/p/11109536.html</a></h5><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个网站有 100 亿 url 存在一个黑名单中，每条 url 平均 64 字节。这个黑名单要怎么存？若此时随便输入一个 url，<strong>你如何快速判断该 url 是否在这个黑名单中</strong>？</p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>不考虑细节的话，此题就是一个简单的<strong>查找问题</strong>。对于查找问题而言，使用散列表来处理往往是一种效率比较高的方案。</p>
<h3 id="为什么不能用散列表"><a href="#为什么不能用散列表" class="headerlink" title="为什么不能用散列表"></a>为什么不能用散列表</h3><p>100 亿是一个很大的数量级，这里每条 url 平均 64 字节，全部存储的话需要 640G  的内存空间。又因为使用了散列表这种数据结构，而散列表是会出现散列冲突的。为了让散列表维持较小的装载因子，避免出现过多的散列冲突，需要使用链表法来处理，这里就要存储链表指针。因此最后的内存空间可能超过 1000G 了。</p>
<h2 id="位图（BitMap）"><a href="#位图（BitMap）" class="headerlink" title="位图（BitMap）"></a>位图（BitMap）</h2><p>首先，先来考虑一个类似但更简单的问题：现在有一个<strong>非常庞大的数据</strong>，比如有 1 千万个整数，并且整数的范围在 1 到 1 亿之间。那么如何快速查找某个整数是否在这 1 千万个整数中呢？</p>
<p>需要判断该数是否存在，也就是说这个数存在两种状态：存在（ True ）或者不存在（False）。</p>
<p>因此这里可以使用一个存储了状态的<strong>数组</strong>来处理。这个数组特点是大小为 1 亿，并且数据类型为布尔类型（  True 或者 False ）。然后将这 1 千万个整数作为数组下标，将对应的数组值设置成 True，比如，整数 233 对应下标为 233  的数组值设置为 True，也就是 array[ 233 ] = True。</p>
<p>这种操作就是<strong>位图法</strong>：就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。</p>
<p>另外，<strong>位图法</strong>有一个优势就是<strong>空间不随集合内元素个数的增加而增加</strong>。它的存储空间计算方式是找到所有元素里面最大的元素（假设为 N ），因此所占空间为：</p>
<p><img src="https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190630134724007-1865278881.jpg" alt="img"></p>
<p>因此，当 N 为 1 亿的时候需要 12MB 的存储空间。当 N 为 10 亿的时候需要 120MB 的存储空间了。当 N  的数量大到一定量级的时候，比如 N 为 2^64 这个海量级别的时候，需要消耗 2048PB  的存储空间，这个量级的BitMap，目前硬件上是支持不了的。</p>
<p><strong>位图法的所占空间随集合内最大元素的增大而增大</strong>。这就会带来一个问题，如果查找的元素数量少但其中某个元素的值很大，比如数字范围是 1 到 1000 亿，那消耗的空间不容乐观。</p>
<p>这个就是位图的一个不容忽视的<strong>缺点</strong>：<strong>空间复杂度随集合内最大元素增大而线性增大</strong>。对于开头的题目而言，使用位图进行处理，实际上内存消耗也是不少的。</p>
<p>因此，出于性能和内存占用的考虑，在这里使用<strong>布隆过滤器</strong>才是最好的解决方案：布隆过滤器是对位图的一种改进。</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器（英语：Bloom Filter）是 1970 年由 <strong>Burton Bloom</strong> 提出的。</p>
<p><strong>它实际上是一个很长的二进制矢量和一系列随机映射函数</strong>。</p>
<p>它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。</p>
<p>对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p>
<p>一开始，布隆过滤器的位数组所有位都初始化为 0。比如，数组长度为 m ，那么将长度为 m 个位数组的所有的位都初始化为 0。</p>
<p>在数组中的每一位都是二进制位。</p>
<p>布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p>
<ul>
<li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ul>
<p>举个例子，假设布隆过滤器有 3 个哈希函数：f1, f2, f3 和一个位数组 <code>arr</code>。现在要把 <code>2333</code> 插入布隆过滤器中：</p>
<ul>
<li>对值进行三次哈希计算，得到三个值 n1, n2, n3。</li>
<li>把位数组中三个元素 arr[n1], arr[n2], arr[3] 都置为 1。</li>
</ul>
<p>当要判断一个值是否在布隆过滤器中，对元素进行三次哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p>很明显，数组的容量即使再大，也是<strong>有限</strong>的。那么随着元素的增加，插入的元素就会越多，位数组中被置为 1 的位置因此也越多，这就会造成一种情况：<strong>当一个不在布隆过滤器中的元素，经过同样规则的哈希计算之后，得到的值在位数组中查询，有可能这些位置因为之前其它元素的操作先被置为 1 了</strong>。</p>
<p>如图 1 所示，假设某个元素通过映射对应下标为4，5，6这3个点。虽然这 3 个点都为 1 ，但是很明显这 3 个点是不同元素经过哈希得到的位置，因此这种情况说明这个元素虽然不在集合中，也可能对应的都是 1，这是误判率存在的原因。</p>
<p>所以，有可能一个不存在布隆过滤器中的会被误判成在布隆过滤器中。</p>
<p><strong>这就是布隆过滤器的一个缺陷</strong>：存在误判。</p>
<p>但是，如果布隆过滤器判断某个元素不在布隆过滤器中，那么这个值就一定不在布隆过滤器中。总结就是：</p>
<ul>
<li>布隆过滤器说某个元素在，可能会被误判</li>
<li>布隆过滤器说某个元素不在，那么一定不在</li>
</ul>
<p>用英文说就是：False is always false. True is maybe true。</p>
<h3 id="误判率"><a href="#误判率" class="headerlink" title="误判率"></a>误判率</h3><p>布隆过滤器可以插入元素，但不可以删除已有元素。其中的元素越多，false positive rate(误报率)越大，但是false negative (漏报)是不可能的。</p>
<h3 id="补救方法"><a href="#补救方法" class="headerlink" title="补救方法"></a>补救方法</h3><p>布隆过滤器存在一定的误识别率。常见的补救办法是在建立白名单，存储那些可能被误判的元素。 比如你苦等的offer 可能被系统丢在邮件垃圾箱（白名单）了。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>布隆过滤器的最大的用处就是，能够迅速判断一个元素是否在一个集合中。因此它有如下三个使用场景:</p>
<ul>
<li>网页爬虫对 URL 的去重，避免爬取相同的 URL 地址</li>
<li>进行垃圾邮件过滤：<strong>反垃圾邮件</strong>，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li>
<li>有的黑客为了让服务宕机，他们会构建大量不存在于缓存中的 key 向服务器发起请求，在数据量足够大的情况下，频繁的数据库查询可能导致 DB 挂掉。布隆过滤器很好的解决了缓存击穿的问题。</li>
</ul>
<h3 id="回到问题"><a href="#回到问题" class="headerlink" title="回到问题"></a>回到问题</h3><p>回到一开始的问题，如果面试官问你如何在海量数据中快速判断该 url 是否在黑名单中时，你应该回答使用布隆过滤器进行处理，然后说明一下为什么不使用 hash 和 bitmap，以及布隆过滤器的基本原理，最后你再谈谈它的使用场景那就更好了。</p>
]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java面试题</tag>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式中volatile关键字的作用</title>
    <url>/likemoves.github.io/2020/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="单例模式中volatile关键字的作用"><a href="#单例模式中volatile关键字的作用" class="headerlink" title="单例模式中volatile关键字的作用"></a>单例模式中volatile关键字的作用</h1><h2 id="背景-amp-问题"><a href="#背景-amp-问题" class="headerlink" title="背景&amp;问题"></a>背景&amp;问题</h2><p>在早期的JVM中，synchronized存在巨大的性能开销。因此，有人想出了一个“聪明”的技巧：双重检查锁定（Double-Checked Locking）。人们想通过双重检查锁定来降低同步的开销。下面是使用双重检查锁定来实现延迟初始化的示例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 4:第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123; <span class="comment">// 5:加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 6:第二次检查</span></span><br><span class="line">                instance = <span class="keyword">new</span> Instance(); <span class="comment">// 7:问题的根源出在这里</span></span><br><span class="line">            &#125; <span class="comment">// 8</span></span><br><span class="line">        &#125; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">// 10</span></span><br><span class="line">    &#125; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的Instance类变量是没有用volatile关键字修饰的，会导致这样一个问题：<br> <strong>在线程执行到第4行的时候，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</strong></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>主要的原因是重排序。<strong>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</strong><br> 第7行的代码创建了一个对象，这一行代码可以分解成3个操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copymemory = allocate();　　<span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory);　<span class="comment">// 2：初始化对象</span></span><br><span class="line">instance = memory;　　<span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>

<p>根源在于代码中的2和3之间，可能会被重排序。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Copymemory = allocate();　　<span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">instance = memory;　　<span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment">// 注意，此时对象还没有被初始化！</span></span><br><span class="line">ctorInstance(memory);　<span class="comment">// 2：初始化对象java</span></span><br></pre></td></tr></table></figure>

<p>这在单线程环境下是没有问题的，但在多线程环境下会出现问题：B线程会看到一个还没有被初始化的对象。<br> A2和A3的重排序不影响线程A的最终结果，但会导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象。</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p><strong>所以只需要做一点小的修改（把instance声明为volatile型），就可以实现线程安全的延迟初始化。</strong>因为被volatile关键字修饰的变量是被禁止重排序的。</p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>接口和抽象类的区别</title>
    <url>/likemoves.github.io/2020/03/25/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h1><p>1.接口的方法<strong>默认是public</strong>，所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。<br>2.接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。<br>3.一个类可以实现<strong>多个接口</strong>，但只能实现<strong>一个抽象类</strong>。接口自己本身可以通过extends关键字扩展多个接口。<br>4.接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。<br>5.从设计层面来说，抽象是对类的抽象，是一种<strong>模板设计</strong>，而接口是对行为的抽象，是一种<strong>行为的规范</strong></p>
<hr>
<h3 id="总结一下jdk7-jdk9Java中接口概念的变化（相关阅读）："><a href="#总结一下jdk7-jdk9Java中接口概念的变化（相关阅读）：" class="headerlink" title="总结一下jdk7~jdk9Java中接口概念的变化（相关阅读）："></a>总结一下jdk7~jdk9Java中接口概念的变化（相关阅读）：</h3><p>1.在jdk7或更早版本中，接口里面<strong>只能有</strong>常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。<br>2.jdk8的时候接口可以有<strong>默认方法（default修饰）和静态方法</strong>功能。<br>3.Jdk9在接口中引入了<strong>私有方法</strong>和<strong>私有静态方法</strong>。</p>
<hr>
<h3 id="默认方法（default修饰）冲突与技巧"><a href="#默认方法（default修饰）冲突与技巧" class="headerlink" title="默认方法（default修饰）冲突与技巧"></a>默认方法（default修饰）冲突与技巧</h3><p>a、<strong>多个接口有同名的default方法</strong><br>interfaceFirst与interfaceSecond同时定义了一个相同方法签名的default方法，此时他们的实现类必须重写该default方法<br>b、<strong>重写default方法时，如何去调用原有interface中的default方法</strong><br>在重写的default方法中，可以使用interfaceFirst.super.xxx()的方式，调用原有任意一个interface中的default方法<br>c、<strong>父亲与interface的default方法同名</strong><br>父类与interface中的default方法有相同的方法签名的方法时，子类继承的是父类的方法，而default会被忽略……</p>
]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java面试题</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库DDL语言</title>
    <url>/likemoves.github.io/2020/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93DDL%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>#1.数据库<br>查看所有数据库：SHOW DATABASES<br>切换数据库：USE 数据库名<br>创建数据库：CREATE DATABASE IF NOT EXISTS mydb1 CHARSET=utf8<br>删除数据库 DROP DATABASE IF EXISTS mydb1<br>修改数据库编码：ALTER DATABASE mydb1 CHARACTER SET utf8</p>
<p>#2.数据类型<br>int：整型<br>double：浮点型，例如double（5，2）表示最多s位，其中必须有2位小数，即最大值为999.99；<br>decimal；浮点型，在表单钱方面使用区类理，因为不会田现精度缺失问题<br>char：定长度字符串类型：char（255）<br>varchar：可变长度字符串类型；varchar（65535），zhangSan<br>text（clob）：字符串类型：<br>blob：字节类型：<br>date：日期类型，格式为：yyyy-MM-dd；<br>time：时间类型，格式为：hh:mm:ss<br>timestamp：时间戳类型；</p>
<p>#3.表<br>创建表：</p>
<figure class="highlight plain"><figcaption><span>TABLE IF NOT EXISTS 表名&#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">   列名 列类型,</span><br><span class="line">   列名 列类型,</span><br><span class="line">   列名 列类型,</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 查看当前数据库中所有表 SHOW TABLES<br> 查看指定表的创建语句 SHOW CREATE TABLE 表名<br> 查看表结构 DESC 表名<br> 删除表 DROP TABLE 表名</p>
<p> 修改表  ALTER TABLE 表名<br> 修改之添加列：</p>
<figure class="highlight plain"><figcaption><span>TABLE 表名 ADD&#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">列名 列类型，</span><br><span class="line">列名 列类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 修改之修改列类型：ALTER TABLE 表名 MODIFY 列名 列类型；<br> 修改之修改列名：ALTER TABLE 表名 CHANGE 原列名 新列名 列类型<br> 修改之删除列：ALTER TABLE 表名 DROP 列名<br> 修改表名称：ALTER TABLE 表名 RENAME TO 新表名</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java面试题</tag>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库中主键/外键/索引</title>
    <url>/likemoves.github.io/2019/08/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%B8%BB%E9%94%AE-%E5%A4%96%E9%94%AE-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="数据库中主键-外键-索引"><a href="#数据库中主键-外键-索引" class="headerlink" title="数据库中主键/外键/索引"></a>数据库中主键/外键/索引</h1><h2 id="一-什么是主键、外键："><a href="#一-什么是主键、外键：" class="headerlink" title="一. 什么是主键、外键："></a>一. 什么是主键、外键：</h2><p>关系型数据库中的一条记录中有若干个属性，若其中<code>某一个属性组</code>(注意是组)能<code>唯一标识</code>一条记录，该属性组就可以成为一个主键<br>比如<br>学生表(<code>学号</code>，姓名，性别，班级)<br>其中每个学生的学号是<code>唯一</code>的，学号就是一个主键<br>课程表(<code>课程编号</code>,课程名,学分)<br>其中课程编号是<code>唯一</code>的,课程编号就是一个主键<br>成绩表(<code>学号,课程号</code>,成绩)<br>成绩表中单一一个属性无法唯一标识一条记录，<code>学号和课程号的组合</code>才可以<code>唯一标识</code>一条记录，所以 学号和课程号的属性组是一个主键 </p>
<p>成绩表中的学号不是成绩表的主键，但它和<code>学生表中的学号</code>相对应，并且学生表中的<code>学号</code>是<code>学生表的主键</code>，则称<code>成绩表中的学号</code>是<code>学生表</code>的<code>外键</code></p>
<p>同理 成绩表中的课程号是课程表的外键 </p>
<hr>
<h3 id="定义主键和外键主要是为了维护关系数据库的完整性，总结一下："><a href="#定义主键和外键主要是为了维护关系数据库的完整性，总结一下：" class="headerlink" title="定义主键和外键主要是为了维护关系数据库的完整性，总结一下："></a>定义主键和外键主要是为了维护关系数据库的完整性，总结一下：</h3><p>1.主键是能<code>确定一条记录的唯一标识</code>，比如，一条记录包括身份正号，姓名，年龄。<br>身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。</p>
<p>2.外键用于与<code>另一张表的关联</code>。是能<code>确定</code>另一张表记录的<code>字段</code>，用于保持数据的一致性。<br>比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p>
<hr>
<h2 id="二、-主键、外键和索引的区别"><a href="#二、-主键、外键和索引的区别" class="headerlink" title="二、  主键、外键和索引的区别"></a>二、  主键、外键和索引的区别</h2><table>
<thead>
<tr>
<th></th>
<th>主键</th>
<th>外键</th>
<th>索引</th>
</tr>
</thead>
<tbody><tr>
<td>定义：</td>
<td>唯一标识一条记录，不能有重复的，不允许为空</td>
<td>表的外键是另一表的主键, 外键可以有重复的, 可以是空值</td>
<td>该字段没有重复值，但可以有一个空值</td>
</tr>
<tr>
<td>作用：</td>
<td>用来保证数据完整性</td>
<td>用来和其他表建立联系用的</td>
<td>是提高查询排序的速度</td>
</tr>
<tr>
<td>个数：</td>
<td>主键只能有一个</td>
<td>一个表可以有多个外键</td>
<td>一个表可以有多个惟一索引</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试知识点--JVM</title>
    <url>/likemoves.github.io/2020/04/21/Java%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9--JVM/</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-描述一下JVM加载Class文件的原理机制"><a href="#1-描述一下JVM加载Class文件的原理机制" class="headerlink" title="1.描述一下JVM加载Class文件的原理机制"></a>1.描述一下JVM加载Class文件的原理机制</h2><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p>
<p>类装载方式，有两种 ：</p>
<p>1.<strong>隐式装载</strong>， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</p>
<p>2.<strong>显式装载</strong>， 通过class.forname()等方法，显式加载需要的类</p>
<p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>
<p>Java的类加载器有三个，对应Java的三种类:</p>
<ol>
<li><p><strong>Bootstrap  Loader  ：启动类加载器，</strong>是虚拟机自身的一部分。负责将存放在\lib目录中的类库加载到虚拟机中。其无法被Java程序直接引用。 负责加载系统类  (指的是内置类，像是String，对应于C#中的System类和C/C++标准库中的类)</p>
</li>
<li><p><strong>ExtClassLoader</strong>  ： <strong>扩展类加载器</strong>，负责加载扩展类(就是继承类和实现类)</p>
</li>
<li><p><strong>AppClassLoader</strong>  ：<strong>应用程序类加载器</strong>，负责加载用户类路径（ClassPath）上所指定的类库(程序员自定义的类)</p>
</li>
</ol>
<p>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被<strong>加载、连接（验证、准备和解析）和初始化</strong>。</p>
<p><strong>类的加载</strong>是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。</p>
<p>当类被加载后就进入连接阶段，这一阶段包括</p>
<p><strong>验证</strong>：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p><strong>准备</strong>：为静态变量分配内存并设置默认的初始值。</p>
<p><strong>解析</strong>：将符号引用替换为直接引用。</p>
<p>最后JVM对类进行<strong>初始化</strong>，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</p>
<h2 id="2-GC-是什么-为什么要有-GC？"><a href="#2-GC-是什么-为什么要有-GC？" class="headerlink" title="2.GC 是什么? 为什么要有 GC？"></a>2.GC 是什么? 为什么要有 GC？</h2><p><strong>GC是垃圾收集的意思</strong>，内存处理是编程人员容易出现问题的地方，<strong>忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃</strong>，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一:</p>
<p>System.gc() 或Runtime.getRuntime().gc() 。</p>
<p>垃圾回收可以有效的<strong>防止内存泄露</strong>，有效的使用可使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。</p>
<h2 id="3-JVM堆的新生代，老年代，永久代"><a href="#3-JVM堆的新生代，老年代，永久代" class="headerlink" title="3.JVM堆的新生代，老年代，永久代"></a>3.JVM堆的新生代，老年代，永久代</h2><p><strong>一、新生代</strong></p>
<p>　　新生代主要用来存放新生的对象。一般占据堆空间的1/3。在新生代中，保存着大量的刚刚创建的对象，但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行MinorGC，进行垃圾回收。新生代又细分为三个区：Eden区、SurvivorFrom、ServivorTo区，三个区的默认比例为：8：1：1。</p>
<ul>
<li><strong>Eden区：</strong>Java新创建的对象绝大部分会分配在Eden区（如果对象太大，则直接分配到老年代）。当Eden区内存不够的时候，就会触发MinorGC（新生代采用的是复制算法），对新生代进行一次垃圾回收。</li>
<li><strong>SurvivorFrom区和To区：</strong>在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGc过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1，如果对象的年龄达到15，则直接分配到老年代。MinorGC完成后，SurvivorFrom区和SurvivorTo区的功能进行互换。下一次MinorGC时，会把SurvivorTo区和Eden区存活的对象放入SurvivorFrom区中，并计算对象存活的年龄。</li>
</ul>
<p><strong>二、老年代</strong></p>
<p>　　老年代主要存放应用中生命周期长的内存对象。老年代比较稳定，不会频繁的进行MajorGC。而在MaiorGC之前才会先进行一次MinorGc，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间。</p>
<p>　　在老年代中，MajorGC采用了标记—清除算法：首先扫描一次所有老年代里的对象，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长。因为要扫描再回收。MajorGC会产生内存碎片，当老年代也没有内存分配给新来的对象的时候，就会抛出OOM（Out of Memory）异常。</p>
<p><strong>三、永久代</strong></p>
<p>　　永久代指的是永久保存区域。主要存放Class和Meta（元数据）的信息。Classic在被加载的时候被放入永久区域，它和存放的实例的区域不同，在Java8中，词锋代已经被移除，取而代之的是一个称之为“元数据区”（元空间）的区域。元空间和永久代类似，都是对JVM中规范中方法的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存的限制。类的元数据放入native memory，字符串池和类的静态变量放入java堆中。这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p>
<p>采用元空间而不用永久代的原因：</p>
<ul>
<li>为了解决永久代的OOM问题，元数据和class对象存放在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代大小指定比较困难，大小容易出现永久代溢出，太大容易导致老年代溢出（堆内存不变，此消彼长）。</li>
<li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
<h2 id="4-垃圾回收机制的优点和原理，并考虑两种回收机制"><a href="#4-垃圾回收机制的优点和原理，并考虑两种回收机制" class="headerlink" title="4.垃圾回收机制的优点和原理，并考虑两种回收机制"></a><strong>4.垃圾回收机制的优点和原理，并考虑两种回收机制</strong></h2><p>1、  java的一个显著的特点就是引入了垃圾回收机制，使c++程序员最头痛的内存管理问题迎刃而解，它使得java管理员在编写程序的时候不需要考虑<strong>内存管理</strong>，因为有了垃圾回收机制；</p>
<p> 2、 java对象中不再有“作用域”的概念，只有对象的引用才有“作用域”。</p>
<p> 3、 垃圾回收机制可以有效的防治内存泄露，有效的使用可以使用的内存。</p>
<p> 4、 垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对</p>
<p>某个对象或所有对象进行垃圾回收。</p>
<p> 5、回收机制有<strong>分代复制垃圾回收</strong>和<strong>标记垃圾回收</strong>，<strong>增量垃圾回收</strong>。</p>
<h2 id="5-Java-中会存在内存泄漏吗，请简单描述"><a href="#5-Java-中会存在内存泄漏吗，请简单描述" class="headerlink" title="5.Java 中会存在内存泄漏吗，请简单描述"></a>5.Java 中会存在内存泄漏吗，请简单描述</h2><p>所谓<strong>内存泄露</strong>就是指一个不再被程序使用的对象或变量一直被占据在内存中。</p>
<p>java中的内存泄露的情况：<strong>长生命周期的对象</strong>持有<strong>短生命周期对象</strong>的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象<strong>持有</strong>它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 </p>
<p>；</p>
<h2 id="6-JVM调参"><a href="#6-JVM调参" class="headerlink" title="6.JVM调参"></a>6.JVM调参</h2><p>JVM三大性能调优参数-Xms-Xmx-Xss的含义</p>
<blockquote>
<p>-Xss：规定了每个线程虚拟机栈（堆栈）的大小<br>-Xms：堆的初始值  （扩容到最大值）<br>-Xmx：堆能达到的最大值</p>
</blockquote>
<blockquote>
<p>-XX:SurvivorRatio:Eden和Survivor的比值，默认8：1<br>-XX:NewRatio：老年代和年轻代内存大小的比例  默认2：1<br>-XX:MaxTenuring Threshold：对象从年轻代晋升到老生代经过GC次数的最大阈值</p>
</blockquote>
<h2 id="7-Java内存模型中堆和栈的区别"><a href="#7-Java内存模型中堆和栈的区别" class="headerlink" title="7.Java内存模型中堆和栈的区别"></a>7.Java内存模型中堆和栈的区别</h2><p>内存分配策略</p>
<blockquote>
<p>静态存储：编译时确定每个数据目标在运行时的存储空间需求</p>
<p>栈式存储：数据区需求在编译时未知，运行时模块入口前确定</p>
<p>堆式存储：编译时或运行时模块入口都无法确定，动态分配</p>
</blockquote>
<p>管理方式：栈自动释放，堆需要GC</p>
<p>空间大小：栈比堆小</p>
<p>碎片相关：栈产生的碎片远小于堆</p>
<p>分配方式：栈支持静态和动态分配，而堆仅支持动态分配</p>
<p>效率：栈的效率比堆高</p>
<h2 id="8-哪些对象可以作为GC-Root对象？"><a href="#8-哪些对象可以作为GC-Root对象？" class="headerlink" title="8.哪些对象可以作为GC Root对象？"></a>8.哪些对象可以作为GC Root对象？</h2><p>1）虚拟机栈中引用的对象，（栈帧中本地变量表中引用的对象）</p>
<p>就是对象A的普通成员变量是对象B；A和B都在栈帧中，都可做GC Root对象</p>
<p>2）方法区中类静态属性引用的对象；</p>
<p>就是对象A的静态成员是对象static B,而 static B在方法区中，B中引用了对象的成员变量，那么B也作为GC Root对象</p>
<p>3）方法区中常量引用的对象</p>
<p>就是对象A的成员对象是final B，final修饰的B默认就是final static B；B中引用了对象的成员变量，那么B也作为GC Root对象</p>
<p>4） 本地方法栈中JNI（native方法中）引用的对象</p>
<h2 id="9-触发Full-GC的条件"><a href="#9-触发Full-GC的条件" class="headerlink" title="9.触发Full GC的条件"></a>9.触发Full GC的条件</h2><p>老年代空间不足</p>
<p>永久代空间不足（jdk1.8之前）</p>
<p>CMS GC时出现promotion failed，concurrent mode failure</p>
<p>Minor GC晋升到老年代的平均大小大于老年代的剩余空间</p>
<p>调用System.gc() （只是通知JVM，JVM决定是否GC）</p>
<h2 id="10-垃圾收集器"><a href="#10-垃圾收集器" class="headerlink" title="10.垃圾收集器"></a>10.垃圾收集器</h2><p>CMS收集器  标记清除算法</p>
<blockquote>
<p>初始标记：stop-the-world</p>
<p>并发标记：并发追溯标记，程序不会停顿</p>
<p>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</p>
<p>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象</p>
<p>并发清理：清理垃圾对象，程序不会停顿</p>
<p>并发重置：重置CMS收集器的数据结构</p>
</blockquote>
<p>G1收集器  复制 标记 整理算法</p>
<p>特点：</p>
<ol>
<li>并行和并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
<li>将整个Java堆内存划分成多个大小相等的Region</li>
<li>年轻代和老年代不再物理隔离</li>
</ol>
<h2 id="11-Object的finalize0方法的作用是否与C-的析构函数作用相同"><a href="#11-Object的finalize0方法的作用是否与C-的析构函数作用相同" class="headerlink" title="11.Object的finalize0方法的作用是否与C++的析构函数作用相同"></a>11.Object的finalize0方法的作用是否与C++的析构函数作用相同</h2><ol>
<li>与C++的析构函数不同，析构函数调用确定，而它的是不确定的</li>
<li>将未被引用的对象放置于F-Queue队列</li>
<li>方法执行随时可能会被终止</li>
<li>给予对象最后一次重生的机会</li>
</ol>
<h2 id="12-Java中的强引用，软引用，弱引用，虚引用有什么用"><a href="#12-Java中的强引用，软引用，弱引用，虚引用有什么用" class="headerlink" title="12.Java中的强引用，软引用，弱引用，虚引用有什么用"></a>12.Java中的强引用，软引用，弱引用，虚引用有什么用</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><blockquote>
<p>最普遍的引用：Object obj=new Object）<br>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象<br>通过将对象设置为null来弱化引用，使其被回收</p>
</blockquote>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><blockquote>
<p>对象处在有用但非必须的状态<br>只有当内存空间不足时，GC会回收该引用的对象的内存<br>可以用来实现高速缓存</p>
</blockquote>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><blockquote>
<p>非必须的对象，比软引用更弱一些<br>GC时会被回<br>被回收的概率也不大，因为GC线程优先级比较低<br>适用于引用偶尔被使用且不影响垃圾收集的对象</p>
</blockquote>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><blockquote>
<p>不会决定对象的生命周期<br>任何时候都可能被垃圾收集器回收<br>跟踪对象被垃圾收集器回收的活动，起哨兵作用<br>必须和引用队列ReferenceQueue联合使用</p>
</blockquote>
<h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><blockquote>
<p>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达</p>
</blockquote>
<h2 id="13-java中子类继承父类程序执行顺序"><a href="#13-java中子类继承父类程序执行顺序" class="headerlink" title="13.java中子类继承父类程序执行顺序"></a>13.java中子类继承父类程序执行顺序</h2><p>执行顺序：</p>
<p>1、类内容（静态变量、静态初始化块） =&gt; 实例内容（变量、初始化块、构造器）</p>
<p>2、父类的（静态变量、静态初始化块）=&gt; 子类的（静态变量、静态初始化块）=&gt; 父类的（变量、初始化块、构造器）=&gt; 子类的（变量、初始化块、构造器）</p>
<h2 id="14-JMM如何解决可见性问题"><a href="#14-JMM如何解决可见性问题" class="headerlink" title="14.JMM如何解决可见性问题"></a>14.JMM如何解决可见性问题</h2><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>A操作的结果需要对B操作可见，则A与B存在happens-before关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i=<span class="number">1</span>;<span class="comment">//线程A执行</span></span><br><span class="line">j=i;<span class="comment">//线程B执行</span></span><br><span class="line"></span><br><span class="line">线程B必须在线程A之后执行，A与B存在happens-before关系</span><br></pre></td></tr></table></figure>

<h3 id="happens-before-八大原则"><a href="#happens-before-八大原则" class="headerlink" title="happens-before 八大原则"></a>happens-before 八大原则</h3><p>1.程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；<br>2.锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；<br>3.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；<br>4.传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；<br>5.线程启动规则：Thread对象的start）方法先行发生于此线程的每一个动作；<br>6.线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生；<br>7.线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive0的返回值手段检测到线程已经终止执行；<br>8.对象终结规则：一个对象的初始化完成先行发生于他的finalize0方法的开始；</p>
<p>如果两个操作不满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM可以对这两个操作进行重排序；如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。</p>
]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/likemoves.github.io/2020/05/20/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="为什么redis能这么快"><a href="#为什么redis能这么快" class="headerlink" title="为什么redis能这么快"></a>为什么redis能这么快</h2><p>100000+QPS（QPS即query per second，每秒内查询次数）</p>
<blockquote>
<p>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高<br>数据结构简单，对数据操作也简单<br>采用单线程，单线程也能处理高并发请求，想多核也可启动多实例<br>使用多路I/O复用模型，非阻塞IO</p>
</blockquote>
<h2 id="redis基本数据类型"><a href="#redis基本数据类型" class="headerlink" title="redis基本数据类型"></a>redis基本数据类型</h2><p><img src="https://img2020.cnblogs.com/blog/1250838/202004/1250838-20200414140126367-153494729.png" alt="img"></p>
<p><a href="https://blog.csdn.net/wj1314250/article/details/92794412" target="_blank" rel="noopener">https://blog.csdn.net/wj1314250/article/details/92794412</a></p>
<h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><ul>
<li><code>简介：</code> 二进制安全</li>
<li><code>可以存储的值：</code> 字符串，整数或者浮点数，还有jpg图片或者序列化对象</li>
<li><code>操作：</code> 对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作</li>
<li><code>应用场景：</code> 做简单的键值对缓存</li>
</ul>
<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><ul>
<li><code>简介：</code> 链表（双向链表）</li>
<li><code>可以存储的值：</code> 列表</li>
<li><code>操作：</code> 从两端压入或者弹出元素，对单个或者多个元素进行修改，只保留一个范围内的元素</li>
<li><code>应用场景：</code> 最新消息排行；消息队列</li>
</ul>
<h3 id="Hash（字典）"><a href="#Hash（字典）" class="headerlink" title="Hash（字典）"></a>Hash（字典）</h3><ul>
<li><code>简介：</code> 键值对集合，即编程语言中的map类型</li>
<li><code>可以存储的值：</code> 适合存储对象，并且可以像数据库中的update一样，只修改某一项的属性值</li>
<li><code>操作：</code> 添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</li>
<li><code>应用场景：</code> 存储、读取、修改用户属性</li>
</ul>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><ul>
<li><code>简介：</code> hash表实现，元素不重复</li>
<li><code>可以存储的值：</code> 无序集合</li>
<li><code>操作：</code> 添加、获取、移除单个元素，检查一个元素是否已经存在于集合中，计算交集、并集、差集从集合里面随机获取元素</li>
<li><code>应用场景：</code> 共同好友；利用唯一性，统计访问网站的所有IP</li>
</ul>
<h3 id="ZSet（有序集合）"><a href="#ZSet（有序集合）" class="headerlink" title="ZSet（有序集合）"></a>ZSet（有序集合）</h3><ul>
<li><code>简介：</code> 将 set 中的元素增加一个权重参数score，元素按score有序排列</li>
<li><code>可以存储的值：</code> 有序集合</li>
<li><code>操作：</code> 添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</li>
<li><code>应用场景：</code> 排行榜；带权重的消息队列</li>
</ul>
<h2 id="从海量Key里查询出某一个固定前缀的Key"><a href="#从海量Key里查询出某一个固定前缀的Key" class="headerlink" title="从海量Key里查询出某一个固定前缀的Key"></a>从海量Key里查询出某一个固定前缀的Key</h2><p>摸清数据规模，问清楚边界</p>
<p>使用keys对线上的业务影响</p>
<h3 id="KEYS-pattern：查找所有符合给定模式pattern的key"><a href="#KEYS-pattern：查找所有符合给定模式pattern的key" class="headerlink" title="KEYS pattern：查找所有符合给定模式pattern的key"></a>KEYS pattern：查找所有符合给定模式pattern的key</h3><blockquote>
<p>KEYS指令一次性返回所有匹配的key<br>键的数量过大会使服务卡顿</p>
</blockquote>
<h3 id="SCAN-cursor-MATCH-pattern-COUNT-count"><a href="#SCAN-cursor-MATCH-pattern-COUNT-count" class="headerlink" title="SCAN cursor [MATCH pattern]  [COUNT count]"></a>SCAN cursor [MATCH pattern]  [COUNT count]</h3><blockquote>
<p>基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程</p>
<p>以O作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历</p>
<p>不保证每次执行都返回某个给定数量的元素，支持模糊查询</p>
<p>一次返回的数量不可控，只能是大概率符合count参数</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1：6379&gt;scan 0 match k1*count </span><br><span class="line">1）"11534336"</span><br><span class="line">2） 1）"k17930789"</span><br><span class="line">	2）"k12231719"</span><br><span class="line">	3）"k19606980"</span><br><span class="line">127.0.0.1：6379&gt;scan 11534336 match k1*count 10</span><br><span class="line">|1）"30932992"</span><br><span class="line">|2）1）"k16480524"</span><br><span class="line">	2）"k12854300"</span><br><span class="line">	3）"k16301048"</span><br><span class="line">	4）"k1463101"</span><br><span class="line">	5）"k19132305"</span><br></pre></td></tr></table></figure>

<h2 id="如何通过redis实现分布式锁"><a href="#如何通过redis实现分布式锁" class="headerlink" title="如何通过redis实现分布式锁"></a>如何通过redis实现分布式锁</h2><h3 id="分布式锁需要解决的问题"><a href="#分布式锁需要解决的问题" class="headerlink" title="分布式锁需要解决的问题"></a>分布式锁需要解决的问题</h3><p>互斥性  任意时刻只能有一个客户端获取锁</p>
<p>安全性   锁只能被持有该锁的客户端删除</p>
<p>死锁     获取锁的客户端因为某些原因而宕机  该锁没有释放 造成死锁</p>
<p>容错  客户端宕机时   仍需要获取锁</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>SETNX key value：如果key不存在，则创建并赋值</p>
<blockquote>
<p>时间复杂度：O（1）<br>返回值：设置成功，返回1；设置失败，返回0。</p>
</blockquote>
<h3 id="如何解决SETNX长期有效的问题"><a href="#如何解决SETNX长期有效的问题" class="headerlink" title="如何解决SETNX长期有效的问题"></a>如何解决SETNX长期有效的问题</h3><p>EXPIRE key seconds</p>
<ul>
<li>设置key的生存时间，当key过期时（生存时间为0），会被自动删除</li>
<li>缺点：原子性得不到满足</li>
</ul>
<p>SET key value  [EX seconds]  [PX milliseconds]  [NXIXX]</p>
<blockquote>
<p>EX second：设置键的过期时间为second秒</p>
<p>PX millisecond：设置键的过期时间为millisecond 毫秒</p>
<p>NX：只在键不存在时，才对键进行设置操作</p>
<p>XX：只在键已经存在时，才对键进行设置操作</p>
<p>SET操作成功完成时，返回OK，否则返回nil</p>
</blockquote>
<h2 id="大量的key同时过期的注意事项"><a href="#大量的key同时过期的注意事项" class="headerlink" title="大量的key同时过期的注意事项"></a>大量的key同时过期的注意事项</h2><p>集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象</p>
<p><strong>解放方案：</strong>在设置key的过期时间的时候，给每个key加上随机值</p>
<h2 id="如何使用Redis做异步队列"><a href="#如何使用Redis做异步队列" class="headerlink" title="如何使用Redis做异步队列"></a>如何使用Redis做异步队列</h2><p>使用List作为队列，RPUSH生产消息，LPOP消费消息</p>
<blockquote>
<p>缺点：没有等待队列里有值就直接消费<br>弥补：可以通过在应用层引入Sleep机制去调用LPOP重试</p>
</blockquote>
<p>BLPOP key[key..J timeout：阻塞直到队列有消息或者超时</p>
<blockquote>
<p>缺点：只能供一个消费者消费</p>
</blockquote>
<p>pub/sub：主题订阅者模式</p>
<blockquote>
<p>发送者（pub）发送消息，订阅者（sub）接收消息<br>订阅者可以订阅任意数量的频道</p>
<p>缺点：消息发布是无状态的，无法保证可达</p>
</blockquote>
<h2 id="redis如何做持久化"><a href="#redis如何做持久化" class="headerlink" title="redis如何做持久化"></a>redis如何做持久化</h2><h3 id="RDB（快照）持久化"><a href="#RDB（快照）持久化" class="headerlink" title="RDB（快照）持久化"></a>RDB（快照）持久化</h3><p>保存某个时间点的全量数据快照</p>
<p>save 900 1  在900秒内若有1次写操作 则进行备份<br>save 300 10<br>save 60 10000</p>
<p>手动RDB持久化指令</p>
<blockquote>
<p>SAVE：<strong>阻塞Redis的服务器进程</strong>，直到RDB文件被创建完毕<br>BGSAVE : Fork出一个子进程来创建RDB文件，<strong>不阻塞服务器进程</strong></p>
</blockquote>
<p>自动化触发RDB持久化的方式</p>
<blockquote>
<p>根据redis.conf配置里的SAVEmn定时触发（用的是BGSAVE）<br>主从复制时，主节点自动触发<br>执行Debug Reload<br>执行Shutdown且没有开启AOF持久化</p>
</blockquote>
<p><strong>Copy-on-Write</strong></p>
<p>如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，<strong>直到某个调用者试图修改资源的内容时</strong>，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变</p>
<p>优点</p>
<blockquote>
<p>方便持久化，只有一个文件 dump.rdb<br>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证 redis 的高性能</p>
</blockquote>
<p>缺点</p>
<blockquote>
<p>内存数据的全量同步，数据量大会由于I/O而严重影响性能<br>可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据</p>
</blockquote>
<h3 id="AOF（Append-Only-File）持久化"><a href="#AOF（Append-Only-File）持久化" class="headerlink" title="AOF（Append-Only-File）持久化"></a>AOF（Append-Only-File）持久化</h3><p>保存写状态</p>
<blockquote>
<p>记录下除了查询以外的所有变更数据库状态的指令<br>以append的形式追加保存到AOF文件中（增量）</p>
</blockquote>
<p>同步选项：<br>选项     同步频率<br>no     让操作系统决定何时同步<br>always     每个写命令都同步<br>everysec     每秒同步一次</p>
<ul>
<li><code>no：</code> 并不能给服务器性能带来多大的提升，而且也会增加系统奔溃时数据丢失的数量</li>
<li><code>always：</code> 严重减低服务器性能</li>
<li><code>everysec：</code> 这个选项比较合适，可以保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响</li>
</ul>
<p>随着服务器写请求的增多，AOF文件会越来越大。Redis提供了一种将AOF重写的特性auto-aof-rewrite，能够去除AOF文件中的冗余写命令</p>
<p>日志重写<strong>解决AOF文件大小不断增大的问题</strong>，原理如下：</p>
<blockquote>
<p>调用fork），创建一个子进程<br>子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件<br>主进程持续将新的变动同时写到内存和原来的AOF里<br>主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动<br>使用新的AOF文件替换掉旧的AOF文件</p>
</blockquote>
<p>RDB和AOF的优缺点</p>
<blockquote>
<p>RDB优点：全量数据快照，文件小，恢复快<br>RDB缺点：无法保存最近一次快照之后的数据</p>
<p>AOF优点：可读性高，适合保存增量数据，数据不易丢失<br>AOF缺点：文件体积大，恢复时间长</p>
</blockquote>
<h3 id="Redis数据的恢复"><a href="#Redis数据的恢复" class="headerlink" title="Redis数据的恢复"></a>Redis数据的恢复</h3><p>RDB和AOF文件共存情况下的恢复流程</p>
<p>1.Redis启动会检测AOF文件是否存在</p>
<p>2.如果存在，则直接加载AOF文件，进行数据恢复</p>
<p>3.如果不存在，检测RDB文件</p>
<p>4.存在，则加载RDB，进行数据恢复</p>
<p>5.不存在，数据恢复失败</p>
<h3 id="RDB-AOF混合持久化方式"><a href="#RDB-AOF混合持久化方式" class="headerlink" title="RDB-AOF混合持久化方式"></a>RDB-AOF混合持久化方式</h3><p>AOF在进行文件重写(aof文件里可能有太多没用指令，所以aof会定期根据内存的最新数据生成aof文件)</p>
<p>时将重写这一刻之前的内存rdb快照文件的内容和增量的AOF修改内存数据的命令日志文件存在一起，</p>
<p>都写入新的aof文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，</p>
<p>原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。</p>
<p>混合持久化文件结构：</p>
<p><img src="https://img-blog.csdnimg.cn/20190614173622476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lobF9qeHk=,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>当我们开启了混合持久化时，启动redis依然优先加载aof文件，aof文件加载可能有两种情况如下：</p>
<p>aof文件开头是rdb的格式, 先加载 rdb内容再加载剩余的 aof。</p>
<p>aof文件开头不是rdb的格式，直接以aof格式加载整个文件。</p>
<h2 id="Redis主从同步"><a href="#Redis主从同步" class="headerlink" title="Redis主从同步"></a>Redis主从同步</h2><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，不过通过redis的主从复制机制就可以避免这种单点故障，主（Master）从（Slave）</p>
<ol>
<li>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</li>
<li>主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。</li>
<li>只有一个主redis，可以有多个从redis。</li>
<li>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</li>
<li>一个redis可以即是主又是从</li>
</ol>
<p>全同步过程</p>
<blockquote>
<p>Slave发送sync命令到Master<br>Master启动一个后台进程，将Redis中的数据快照保存到文件中<br>Master将保存数据快照期间接收到的写命令缓存起来<br>Master完成写文件操作后，将该文件发送给Slave<br>Slave使用新的AOF文件替换掉旧的AOF文件<br>Master将这期间收集的增量写命令发送给Salve端</p>
</blockquote>
<p>增量同步过程</p>
<blockquote>
<p>Master接收到用户的操作指令，判断是否需要传播到Slave<br>Master将操作记录追加到AOF文件<br>Master将操作传播到其他Slave：1、对齐主从库；2、往响应缓存写入指令<br>将缓存中的数据发送给Slave</p>
</blockquote>
<h2 id="Redis-Sentinel哨兵机制"><a href="#Redis-Sentinel哨兵机制" class="headerlink" title="Redis Sentinel哨兵机制"></a>Redis Sentinel哨兵机制</h2><p>Redis主从复制的缺点：没有办法对master进行动态选举，需要使用Sentinel机制完成动态选举</p>
<p>Sentinel(哨兵)进程是用于<strong>监控redis集群中Master主服务器工作的状态</strong></p>
<p> 在Master主服务器发生故障的时候，可以实现Master和Slave服务器的切换，保证系统的高可用（HA）</p>
<h3 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用</h3><ol>
<li><p><strong>监控(Monitoring):</strong> 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。</p>
</li>
<li><p><strong>提醒(Notification)</strong>： 当被监控的某个Redis节点出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。</p>
</li>
<li><p><strong>自动故障迁移(Automatic failover)</strong>：当<strong>一个Master不能正常工作</strong>时，哨兵(sentinel) 会开始<strong>一次自动故障迁移操作</strong>。</p>
<p>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master；</p>
<p>当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。</p>
<p>Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。</p>
</li>
</ol>
<h2 id="缓存穿透、缓存击穿、缓存失效"><a href="#缓存穿透、缓存击穿、缓存失效" class="headerlink" title="缓存穿透、缓存击穿、缓存失效"></a>缓存穿透、缓存击穿、缓存失效</h2><h3 id="缓存数据的步骤"><a href="#缓存数据的步骤" class="headerlink" title="缓存数据的步骤"></a>缓存数据的步骤</h3><p>1、 查询缓存，如果没有数据，则查询数据库</p>
<p>2、 查询数据库，如果数据不为空，将结果写入缓存</p>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="什么叫缓存穿透？"><a href="#什么叫缓存穿透？" class="headerlink" title="什么叫缓存穿透？"></a>什么叫缓存穿透？</h4><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。（<strong>布隆表达式</strong>）</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="什么叫缓存雪崩？"><a href="#什么叫缓存雪崩？" class="headerlink" title="什么叫缓存雪崩？"></a>什么叫缓存雪崩？</h4><p>当缓存服务器重启或者<strong>大量缓存集中在某一个时间段失效</strong>，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。</p>
<h4 id="如何解决？-1"><a href="#如何解决？-1" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>2：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<p>3：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期（此点为补充）</p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><h4 id="什么叫缓存击穿？"><a href="#什么叫缓存击穿？" class="headerlink" title="什么叫缓存击穿？"></a>什么叫缓存击穿？</h4><p>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常<strong>“热点”</strong>的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，<strong>这个和缓存雪崩的区别在于这里针对某一key缓存，后者则是很多key。</strong></p>
<p>缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<h4 id="如何解决？-2"><a href="#如何解决？-2" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>1.<strong>使用redis的setnx互斥锁先进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(redis.sexnx()==<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="comment">//查询数据库</span></span><br><span class="line">	<span class="comment">//加入线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Redis数据一致性"><a href="#Redis数据一致性" class="headerlink" title="Redis数据一致性"></a>Redis数据一致性</h2><p><strong>所谓的redis数据一致性即当数据库数据进行修改或者保存、删除之后，redis中的数据也应该进行相应变化，不然用户再次查询的时候很可能查询出已经删除过的脏数据。</strong></p>
<p>例如：保存了一个新用户之后，就应该同时在redis缓存中也插入该条数据，更新了某条数据在缓存中也应该同步更新，而redis默认的做法是：当你不去设置的时候redis中存放的一值是你之前存放的数据，只有在重启服务器的时候数据才会同步，显然这是非常不可取的，如果是这样的话岂不是每时每刻都要重启服务器，那将是多么大的灾难！<br>参考文档 ：<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-consistence.md</a></p>
]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java面试题</tag>
        <tag>中间件</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer面试题38--字符串的排列</title>
    <url>/likemoves.github.io/2020/05/09/%E5%89%91%E6%8C%87offer%E9%9D%A2%E8%AF%95%E9%A2%9838--%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</span><br></pre></td></tr></table></figure>

<p>注意这道题求得是<strong>全排列</strong>。求若干字符组成的序列的所有排列可能，可以将字符序列分解成两部分：</p>
<ul>
<li>第一个字符</li>
<li>第一个字符之后的字符序列</li>
</ul>
<p>这样就把一个大问题分解成了小问题，然后对小问题继续采用相同的策略即可！</p>
<p>因为所有字符都可能处于第一个位置，我们可以把第一个字符和其后的所有字符<strong>交换位置</strong>，这样就保证了所有字符都会位于第一个字符处；交换后固定第一个字符，然后对于其后的字符序列，继续分成两部分：第一个字符和其后的字符序列……这是一个递归过程！</p>
<p>第一个字符和其后的所有字符依次交换位置可以用一个for循环完成，对于循环中的每一次交换：在交换位置后要对除第一个字符外的字符序列进行递归。<strong>这里一定要注意，第一个字符首先要和自己交换一下。</strong>一次递归调用结束后，需要将之前的交换复原，以保证下次交换依然是和第一个字符交换。比如abcd，第一个字符和第二个字符交换后变成bacd，此后固定b对acd递归，递归结束后，需要将bacd复原成abcd，以便下次a和c交换位置变成cbad……</p>
<p>实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        collect(str.toCharArray(),<span class="number">0</span>,list);</span><br><span class="line">        <span class="comment">//保证字典序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> begin, ArrayList&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin==chars.length)&#123;</span><br><span class="line">            String s=String.valueof(chars);</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(s))&#123;</span><br><span class="line">                list.add(s);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;chars.length;i++)&#123;</span><br><span class="line">            swap(chars,i,begin);</span><br><span class="line">            collect(chars, begin + <span class="number">1</span>, list);</span><br><span class="line">            swap(chars,i,begin);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">char</span> temp = chars[j];</span><br><span class="line">         chars[j] = chars[i];</span><br><span class="line">         chars[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Permutation a = <span class="keyword">new</span> Permutation();</span><br><span class="line">        System.out.println(a.permutation(<span class="string">"gba"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串的组合"><a href="#字符串的组合" class="headerlink" title="字符串的组合"></a>字符串的组合</h2><p>如果要求字符的所有组合呢？比如abc，所有组合情况是<code>[a, b, c, ab, ac, bc, abc]</code>，包含选择1个、2个、3个字符进行组合的情况，即$\sum{C_3^1 + C_3^2 + C_3^ 3}$。这可以用一个for循环完成。所以关键是如何求得在n个字符里选取m个字符总共的情况数，即如何求C(n, m)</p>
<p>n个字符里选m个字符，有两种情况：</p>
<ul>
<li>第一个字符在组合中，则需要从剩下的n-1个字符中再选m-1个字符；</li>
<li>第一个字符不在组合中，则需要从剩下的n-1个字符中选择m个字符。</li>
</ul>
<p>上面表达的意思用数学公式表示就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">公式C(n, m) = C(n-1, m-1)+ C(n-1, m)</span><br></pre></td></tr></table></figure>

<p>基于这个公式，就可实现如下递归程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求字符的所有排列,允许组合中有重复元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combination</span> </span>&#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 其实就是求C(n, m) 其中n == str.length; m == num</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 字符序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num 选几个字符进行组合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> C(n, m)的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">combinationAccordingToNum</span><span class="params">(String str, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">         List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span> || num &gt; str.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">         collect(str, sb, num, list);</span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求所有组合情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">combination</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集字符个数为i的组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= str.length(); i++) &#123;</span><br><span class="line">            collect(str, sb, i, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归部分代码</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(String str, StringBuilder sb, <span class="keyword">int</span> number, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 两个if顺序不可交换，否则C(n, n)不会存入到list中：即collect("", sb, 0)时，要先判断num==0存入后，再判断str.length ==0决定不再递归</span></span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!list.contains(sb.toString()))</span><br><span class="line">            	list.add(sb.toString());</span><br><span class="line">            	<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 当str为""时候直接返回，不然下一句charAt(0)就会越界</span></span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="comment">// 公式C(n, m) = C(n-1, m-1)+ C(n-1, m)</span></span><br><span class="line">        <span class="comment">// 第一个字符是组合中的第一个字符，在剩下的n-1个字符中选m-1个字符</span></span><br><span class="line">        sb.append(str.charAt(<span class="number">0</span>)); <span class="comment">// 第一个字符选中</span></span><br><span class="line">        collect(str.substring(<span class="number">1</span>), sb, number - <span class="number">1</span>, list);</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>); <span class="comment">// 取消选中第一个字符</span></span><br><span class="line">        <span class="comment">// 第一个字符不是组合中的第一个字符，在剩下的n-1个字符中选m个字符</span></span><br><span class="line">        collect(str.substring(<span class="number">1</span>), sb, number, list); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排列的应用–八皇后问题"><a href="#排列的应用–八皇后问题" class="headerlink" title="排列的应用–八皇后问题"></a>排列的应用–八皇后问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8X8的国际棋盘上，有8个皇后，使其不能相互攻击，即它们不能在同一行、同一列、且同一条对角</span><br></pre></td></tr></table></figure>

<p>三个条件都要满足，我们可以一一来满足，思路如下：</p>
<ol>
<li>保证不同行：使用一个数组表示不同行的皇后，八个皇后则int[] queens = new int[8]，其中queens[i]表示位于第i行的皇后，这保证了皇后们不位于同一行；</li>
<li>保证不同列：为queens[i]赋值各不相同的数值，queens[i] = j表示位于i行的皇后也位于j列，每个i赋予了不同的j值保证了不同行的皇后也不位于不同列</li>
<li>保证不在同一条对角线：如果在同一条对角线，说明矩形的行数等于列数，即当j &gt; i时: <code>j - i == queens[j] -queens[i]</code>（第j行的皇后在第i行的皇后右下方）；或者<code>j - i == queens[i] -queens[j]</code>(第j行的皇后在第i行的皇后左下方)</li>
</ol>
<p>先来满足前两条，很简单只需要初始化一个像下面这样的数组即可，即刚开始将皇后们置于棋盘的对角线上，这当然不是个符合条件的解。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightQueens</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 这又是一个全排列的扩展问题，先求出所有的排列可能，从中排除不符合要求的摆放方法即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; possibilitiesOfQueensPlaced() &#123;</span><br><span class="line">          <span class="comment">// 大小为8的数组，且数值各不相同，任意排列都保证了不同行不同列</span></span><br><span class="line">         <span class="keyword">int</span> [] queens=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">         List&lt;<span class="keyword">int</span>[]&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         </span><br><span class="line">         PermutationExt p = <span class="keyword">new</span> PermutationExt();</span><br><span class="line">          <span class="comment">// 得到全排列</span></span><br><span class="line">         List&lt;<span class="keyword">int</span>[]&gt; all = p.permutation(queens);</span><br><span class="line">         <span class="comment">//筛选</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span>[] arr:all)&#123;</span><br><span class="line">             <span class="keyword">if</span>(!isLocatedSameDiagonal(arr))</span><br><span class="line">                 list.add(arr)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> list;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *检查任意两个皇后是否在同一条对角线上</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLocatedSameDiagonal</span><span class="params">(<span class="keyword">int</span>[] queens)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queens.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;queens.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i==queens[j]-queens[i]||j-i==queens[i]-queens[j])&#123;</span><br><span class="line">                    <span class="keyword">return</span> ture;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EightQueens queens = <span class="keyword">new</span> EightQueens();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; l = queens.possibilitiesOfQueensPlaced();</span><br><span class="line">        System.out.println(<span class="string">"共有"</span> + l.size() + <span class="string">"种放置方法"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : l) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个经典的问题，可以记住<strong>答案是92</strong>。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出理解Synchronized关键字</title>
    <url>/likemoves.github.io/2020/05/18/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3Synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>修饰实例方法，对当前实例对象加锁</p>
<p>修饰静态方法，对当前类对象加锁</p>
<p>修饰代码块，指定一个加锁的对象，给对象加锁</p>
<p><strong>其实就是锁方法、锁代码块和锁对象</strong></p>
<h2 id="JAVA对象构成"><a href="#JAVA对象构成" class="headerlink" title="JAVA对象构成"></a>JAVA对象构成</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><ul>
<li><strong>Mark Word（标记字段）</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化</li>
<li><strong>Klass Point（类型指针）</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
</ul>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>这部分主要是存放类的数据信息，父类的信息，实例的数据信息</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<h2 id="synchronized的特性"><a href="#synchronized的特性" class="headerlink" title="synchronized的特性"></a>synchronized的特性</h2><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>CPU会为了优化我们的代码，会对我们程序进行重排序。不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的，还有就是有数据依赖的也是不能重排序的。</p>
<p>就比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = a;</span><br></pre></td></tr></table></figure>

<p>这两段是怎么都不能重排序的，b的值依赖a的值，a如果不先赋值，那就为空了。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>JMM（Java内存模型），JMM并不是实际存在的，而是一套规范，这个规范描述了很多java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节，Java内存模型是对共享数据的可见性、有序性、和原子性的规则和保障。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>确保同一时间只有一个线程能拿到锁，能够进入代码块。</p>
<h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>synchronized锁对象的时候有个monitor中的计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了。</p>
<p>可以避免一些死锁的情况，也可以让我们更好封装我们的代码。</p>
<h3 id="不可中断性"><a href="#不可中断性" class="headerlink" title="不可中断性"></a>不可中断性</h3><p>不可中断就是指，一个线程获取锁之后，另外一个线程处于阻塞或者等待状态，前一个不释放，后一个也一直会阻塞或者等待，不可以被中断。</p>
<p>值得一提的是，Lock的tryLock方法是可以被中断的。</p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>在对象头中，会引用一个monitor对象</p>
<ul>
<li>当我们进入一个方法时，会执行monitorenter，会获取当前对象的一个所有权这个时候monitor进入数为1，当前的这个线程就是这个monitor的owner。</li>
<li>如果你已经是这个monitor的owner了，你再次进入，就会把进入数+1.</li>
<li>同理，当他执行完<strong>monitorexit</strong>，对应的进入数就-1，直到为0，才可以被其他线程持有。</li>
</ul>
<p>所有的互斥，就是看你能否获得monitor的所有权，一旦你成为owner就是获得者。</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>方法有一个特殊标志位没，<strong>ACC_SYNCHRONIZED</strong>。</p>
<p>同步方法的时候，一旦执行到这个方法，就会先判断是否有标志位，然后，ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit。</p>
<p>所以归根究底，还是monitor对象的争夺。</p>
<h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><p>monitor监视器源码是C++写的，在虚拟机的ObjectMonitor.hpp文件中。</p>
<p>他的数据结构长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = NULL;</span><br><span class="line">  _count        = 0;</span><br><span class="line">  _waiters      = 0,</span><br><span class="line">  _recursions   = 0;  // 线程重入次数</span><br><span class="line">  _object       = NULL;  // 存储Monitor对象</span><br><span class="line">  _owner        = NULL;  // 持有当前线程的owner</span><br><span class="line">  _WaitSet      = NULL;  // wait状态的线程列表</span><br><span class="line">  _WaitSetLock  = 0 ;</span><br><span class="line">  _Responsible  = NULL ;</span><br><span class="line">  _succ         = NULL ;</span><br><span class="line">  _cxq          = NULL ;  // 单向列表</span><br><span class="line">  FreeNext      = NULL ;</span><br><span class="line">  _EntryList    = NULL ;  // 处于等待锁状态block状态的线程列表</span><br><span class="line">  _SpinFreq     = 0 ;</span><br><span class="line">  _SpinClock    = 0 ;</span><br><span class="line">  OwnerIsThread = 0 ;</span><br><span class="line">  _previous_owner_tid = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized底层的源码就是引入了ObjectMonitor，</p>
<h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>Linux系统的体系结构，分为用户空间（应用程序的活动空间）和内核。</p>
<p>我们所有的程序都在用户空间运行，进入用户运行状态也就是（用户态），但是很多操作可能涉及内核运行，比我I/O，我们就会进入内核运行状态（内核态）。</p>
<p>简单概括下流程：</p>
<ol>
<li>用户态把一些数据放到寄存器，或者创建对应的堆栈，表明需要操作系统提供的服务。</li>
<li>用户态执行系统调用（系统调用是操作系统的最小功能单位）。</li>
<li>CPU切换到内核态，跳到对应的内存指定的位置执行指令。</li>
<li>系统调用处理器去读取我们先前放到内存的数据参数，执行程序的请求。</li>
<li>调用完成，操作系统重置CPU为用户态返回结果，并执行下个指令。</li>
</ol>
<p>JDK1.6之前synchronized是重量级锁，没错，但是他的本质，是ObjectMonitor调用的过程，以及Linux内核的复杂运行机制决定的，大量的系统资源消耗，效率低。</p>
<h2 id="synchronized的优化"><a href="#synchronized的优化" class="headerlink" title="synchronized的优化"></a>synchronized的优化</h2><h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是<strong>单向的</strong>，也就是说<strong>只能从低到高升级</strong>，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段。</p>
<p>升级方向：</p>
<p><strong>无锁—&gt;偏向锁—&gt;轻量级锁—&gt;重量级锁</strong></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段。</p>
<p>在大多数情况下，锁不仅不存在多线程竞争，而且<strong>总是由同一线程多次获得</strong>，因此为了<strong>减少同一线程获取锁</strong>(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。</p>
<p>偏向锁的核心思想：如果一个线程获得了锁，那么锁就进入偏向模式，此时<strong>Mark Word 的结构也变为偏向锁结构</strong>，当这个线程<strong>再次请求锁时</strong>，无需再做任何同步操作，即获取锁的过程，这个过程是采用了<strong>CAS乐观锁</strong>操作的，每次同一线程进入，虚拟机就不进行任何同步的操作了，对标志位+1就好了，<strong>不同线程过来，CAS会失败</strong>，也就意味着获取锁失败。这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。</p>
<p>对于<strong>没有锁竞争的场合</strong>，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>如果这个对象是无锁的，jvm就会在当前线程的<strong>栈帧</strong>中建立一个叫<strong>锁记录（Lock Record）</strong>的空间，用来存储锁<strong>对象的Mark Word 拷贝</strong>，然后把<strong>Lock Record中的owner指向当前对象</strong>。</p>
<p>JVM接下来会利用<strong>CAS</strong>尝试把对象<strong>原本的Mark Word</strong> <strong>更新</strong>会Lock Record的指针，<strong>成功</strong>就说明<strong>加锁</strong>成功，改变锁标志位，执行相关同步操作。</p>
<p>如果<strong>失败</strong>了，就会判断当前<strong>对象的Mark Word</strong>是否<strong>指向</strong>了当前线程的<strong>栈帧</strong>，<strong>是</strong>则表示当前的线程已经<strong>持有了这个对象的锁</strong>，<strong>否则</strong>说明被<strong>其他线程</strong>持有了，<strong>继续锁升级</strong>，修改锁的状态，之后等待的线程也<strong>阻塞</strong>。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>Linux系统的用户态和内核态的切换很耗资源，其实就是线程的等待唤起过程</p>
<p>自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个<strong>空循环</strong>(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果<strong>还不能获得锁</strong>，那就会将线程在操作<strong>系统层面挂起</strong>，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为<strong>重量级锁</strong>了。</p>
<h2 id="等待唤醒机制与synchronize"><a href="#等待唤醒机制与synchronize" class="headerlink" title="等待唤醒机制与synchronize"></a>等待唤醒机制与synchronize</h2><p>所谓等待唤醒机制本篇主要指的是<strong>notify/notifyAll和wait</strong>方法</p>
<p>在使用这3个方法时，必须<strong>处于synchronized代码块</strong>或者<strong>synchronized方法</strong>中，否则就会抛出IllegalMonitorStateException异常，这是因为<strong>调用这几个方法前</strong>必须<strong>拿到当前对象的监视器monitor对象</strong>，也就是说notify/notifyAll和wait方法<strong>依赖于monitor对象</strong></p>
<p>我们知道monitor <strong>存在</strong>于对象头的Mark Word 中(存储monitor引用指针)，<strong>而synchronized关键字可以获取 monitor</strong>  ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p>
<h2 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h2><p>总结</p>
<blockquote>
<p>synchronized是关键字，ReentrantLock是类<br>ReentrantLock可以对获取锁的等待时间进行设置，避免死锁<br>ReentrantLock可以获取各种锁的信息<br>ReentrantLock可以灵活地实现多路通知<br><strong>机制：sync操作对象头Mark Word，lock调用Unsafe类的park0方法</strong></p>
</blockquote>
<p>参考文档</p>
<p>1.<a href="https://www.cnblogs.com/mingyao123/p/7424911.html" target="_blank" rel="noopener">https://www.cnblogs.com/mingyao123/p/7424911.html</a></p>
<p>2.<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453142528&amp;idx=1&amp;sn=34b26e408e1f8adcd8d8257522705171&amp;chksm=8cf2de83bb855795e5920ac80400f04c86a0dbe8bdf47735764d319a0136f48706c0586ba172&amp;scene=0&amp;xtrack=1&amp;key=65adb617e7a2a4ebf965d3d1bde075fccc49a07aeaeaa5457a4fc71cbff9c35fb80aa339b484b6831ebebbbdcadd1880493221f2eb0720e1708c40db5380ff6ddac858c9a909f466c6da459b9b705a30&amp;ascene=1&amp;uin=NTU1MzY1MTM1&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AdNjAh%2F07hJZq8tIyDQZZSY%3D&amp;" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453142528&amp;idx=1&amp;sn=34b26e408e1f8adcd8d8257522705171&amp;chksm=8cf2de83bb855795e5920ac80400f04c86a0dbe8bdf47735764d319a0136f48706c0586ba172&amp;scene=0&amp;xtrack=1&amp;key=65adb617e7a2a4ebf965d3d1bde075fccc49a07aeaeaa5457a4fc71cbff9c35fb80aa339b484b6831ebebbbdcadd1880493221f2eb0720e1708c40db5380ff6ddac858c9a909f466c6da459b9b705a30&amp;ascene=1&amp;uin=NTU1MzY1MTM1&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AdNjAh%2F07hJZq8tIyDQZZSY%3D&amp;</a></p>
]]></content>
      <categories>
        <category>java面试题</category>
      </categories>
      <tags>
        <tag>java面试题</tag>
        <tag>java</tag>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/likemoves.github.io/2020/04/27/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p>消息队列可以简单理解为：<strong>把要传输的数据放在队列中</strong>。</p>
<p>把数据放到消息队列叫做<strong>生产者</strong></p>
<p>从消息队列里边取数据叫做<strong>消费者</strong></p>
<h2 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p><img src="https://pic3.zhimg.com/80/v2-8b6b8046286c88206fa144136f803af3_1440w.jpg" alt="img"></p>
<p>系统A将userId写到消息队列中，系统C和系统D从消息队列中拿数据。<strong>这样有什么好处</strong>？</p>
<ul>
<li>系统A<strong>只负责</strong>把数据写到队列中，谁想要或不想要这个数据(消息)，<strong>系统A一点都不关心</strong>。</li>
<li>即便现在系统D不想要userId这个数据了，系统B又突然想要userId这个数据了，都跟系统A无关，系统A一点代码都不用改。</li>
<li>系统D拿userId不再经过系统A，而是从消息队列里边拿。<strong>系统D即便挂了或者请求超时，都跟系统A无关，只跟消息队列有关</strong>。</li>
</ul>
<p>这样一来，系统A与系统B、C、D都<strong>解耦</strong>了。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p><img src="https://pic3.zhimg.com/80/v2-a391345118fc2545b232411efea7b80d_1440w.jpg" alt="img"></p>
<p>系统A执行完了以后，将userId写到消息队列中，然后就直接返回了(至于其他的操作，则异步处理)。本来整个请求需要用950ms(同步)现在将调用其他系统接口异步化，只需要100ms(异步)</p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p><img src="https://pic2.zhimg.com/80/v2-bfe84bf8578c4e8e47fe527106b6b426_1440w.jpg" alt="img"></p>
<p>系统B和系统C<strong>根据自己的能够处理的请求数去消息队列中拿数据</strong>，这样即便有每秒有8000个请求，那只是把请求放在消息队列中，去拿消息队列的消息<strong>由系统自己去控制</strong>，这样就不会把整个系统给搞崩。</p>
<h2 id="消息队列缺点"><a href="#消息队列缺点" class="headerlink" title="消息队列缺点"></a>消息队列缺点</h2><h3 id="系统复杂性"><a href="#系统复杂性" class="headerlink" title="系统复杂性"></a>系统复杂性</h3><p>需要维护中间件，以及考虑消费的各种问题，包括<strong>重复消费</strong>、<strong>消息丢失</strong>、<strong>消息的顺序消费</strong></p>
<h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>在分布式系统下，如何保证消息队列中的数据一致性</p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><h2 id="消息队列问题以及解决方案"><a href="#消息队列问题以及解决方案" class="headerlink" title="消息队列问题以及解决方案"></a>消息队列问题以及解决方案</h2><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>消息队列的使用，我们都是有<strong>重试机制</strong>的，就是说我下游的某个业务发生异常了，我会抛出异常并且要求你<strong>重新发一次</strong>。但是不止一个业务在监听消息，如果消息重发，可能导致多个业务重新执行。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzjaiaLbo3bKFDic8zvesZQQY3OXibPgQman2bSZJ4VIxOKtGpwPjzOdcBcXndfvSfGLuRAGY2fQrdlQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>就好比上面的这样，我们的<strong>积分系统处理失败</strong>了，他这个系统肯定要求你<strong>重新发送</strong>一次这个消息对吧，积分的系统重新接收并且处理成功了，但是别人的活动，优惠券等等服务<strong>也监听了这个消息</strong>呀，那不就可能出现活动系统给他加积分加两次，优惠券扣两次这种情况么？</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>使用幂等接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">幂等是一个数学与计算机学概念，常见于抽象代数中。</span><br><span class="line">在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</span><br><span class="line">幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</span><br><span class="line">例如，“setTrue()”函数就是一个幂等函数,**无论多次执行，其结果都是一样的.**更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</span><br></pre></td></tr></table></figure>

<p>通俗了讲就是你<strong>同样的参数调用我这个接口，调用多少次结果都是一个</strong></p>
<p>一般<strong>幂等</strong>，会<strong>分场景去考虑</strong>，看是<strong>强校验</strong>还是<strong>弱校验</strong>，比如跟金钱相关的场景，就做强校验，不是很重要的场景做弱校验。</p>
<p><strong>强校验</strong></p>
<p>比如监听到用户支付成功的消息，你监听到了去加GMV是不是要调用加钱的接口，那加钱接口下面再调用一个加流水的接口，<strong>两个放在一个事务，成功一起成功失败一起失败</strong>。</p>
<p>每次消息过来都要拿着<strong>订单号+业务场景这样的唯一标识</strong>（比是天猫双十一活动）去流水表查，看看有没有这条流水，有就直接return不要走下面的流程了，没有就执行后面的逻辑。</p>
<p>之所以用<strong>流水表</strong>，是因为涉及到金钱这样的活动，有啥问题后面也可以去流水表<strong>对账</strong>，还有就是帮助开发人员定位问题。</p>
<p><strong>弱校验</strong></p>
<p>一些不重要的场景，比如发短信，就把这个id+场景唯一标识作为<strong>Redis</strong>的key，放到缓存里面失效时间看你场景，<strong>一定时间内</strong>的这个消息就去Redis判断。</p>
<p>用KV就算消息丢了可能这样的场景也没关系，反正丢条<strong>无关痛痒</strong>的通知短信</p>
<h3 id="消费顺序"><a href="#消费顺序" class="headerlink" title="消费顺序"></a>消费顺序</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>一般都是<strong>同个业务场景下不同几个操作的消息同时过去</strong>，本身顺序是对的，但是你发出去的时候同时发出去了，消费的时候却乱掉了，这样就有问题了。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>的<strong>RocketMQ</strong>里面的一个简单实现</p>
<p><strong>Tip</strong>：为啥用<strong>RocketMQ</strong>举例呢，这玩意是阿里开源的，我问了下身边的朋友很多公司都有使用，所以读者大概率是这个的话我就用这个举例吧，具体的细节我后面会在<strong>RocketMQ</strong>和<strong>Kafka</strong>各自章节说到。</p>
<p>生产者消费者一般需要保证顺序消息的话，可能就是一个业务场景下的，比如订单的创建、支付、发货、收货。</p>
<p>那这些东西是不是一个订单号呢？一个订单的肯定是一个订单号的说</p>
<p><strong>一个topic下有多个队列</strong>，为了保证发送有序，<strong>RocketMQ</strong>提供了<strong>MessageQueueSelector</strong>队列选择机制，他有三种实现:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uChmeeX1FpzjaiaLbo3bKFDic8zvesZQQYqNXMwicnafsv3oSedFeWxvQXxd7iaK1nYwHCVu2ria6iaJsBbqHhl7hZqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>我们可使用<strong>Hash取模法</strong>，让同一个订单发送到同一个队列中，再使用同步发送，只有同个订单的创建消息发送成功，再发送支付消息。这样，我们保证了发送有序。</p>
<p><strong>RocketMQ</strong>的topic内的队列机制,可以保证存储满足<strong>FIFO</strong>（First Input First Output 简单说就是指先进先出）,剩下的只需要消费者顺序消费即可。</p>
<p><strong>RocketMQ</strong>仅保证顺序发送，顺序消费由消费者业务保证</p>
<p>这里很好理解，一个订单你发送的时候放到一个队列里面去，你同意的订单号Hash一下是不是还是一样的结果，那肯定是一个消费者消费，那顺序是不是就保证了？</p>
<p>真正的顺序消费不同的中间件都有自己的不同实现我这里就举个例子，大家思路理解下。</p>
<p><strong>Tip</strong>：我写到这点的时候人才群里也有人问我，一个队列有序出去，一个消费者消费不就好了，我想说的是<strong>消费者是多线程</strong>的，你消息是有序的给他的，你能保证他是有序的处理的？还是一个消费成功了再发下一个<strong>稳妥</strong>。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>事务<strong>事务就是一系列操作，要么同时成功，要么同时失败。</strong>然后会从事务的 <strong>ACID</strong> 特性<strong>（原子性、一致性、隔离性、持久性）展开叙述</strong>。</p>
<p>我接触和了解到的分布式事务大概分为：</p>
<ul>
<li>2pc（两段式提交）</li>
<li>3pc（三段式提交）</li>
<li>TCC（Try、Confirm、Cancel）</li>
<li>最大努力通知</li>
<li>XA</li>
<li>本地消息表（ebay研发出的）</li>
<li>半消息/最终一致性（RocketMQ）</li>
</ul>
<p>这里我就介绍下最简单的<strong>2pc（两段式）</strong>，以及大家以后可能比较常用的<strong>半消息事务</strong>也就是<strong>最终一致性</strong>，目的是让大家理解下分布式事务里面<strong>消息中间件的作用</strong>，别的事务都大同小异，都有很多优点。</p>
<p>当然也都有<strong>种种弊端</strong>：</p>
<p>例如<strong>长时间锁定数据库资源</strong>，导致系统的<strong>响应不快</strong>，<strong>并发上不去</strong>。</p>
<p>网络抖动出现<strong>脑裂</strong>情况，导致事物参与者，不能很好地执行协调者的指令，导致<strong>数据不一致</strong>。</p>
<p><strong>单点故障</strong>：例如事物协调者，在某一时刻宕机，虽然可以通过选举机制产生新的Leader，但是这过程中，必然出现问题，而TCC，只有强悍的技术团队，才能支持开发，<strong>成本太高</strong>。</p>
<p>不多BB了，我们开始介绍这个两个事物吧。</p>
<p><strong>2pc（两段式提交）</strong> :</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzjaiaLbo3bKFDic8zvesZQQYzeRTVOMHUU1zjE9ObAdR8nmaL9RGpVM6KarWONOKQsQ7bLOibKcY1icg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p><strong>2pc（两段式提交）</strong>可以说是分布式事务的最开始的样子了，像极了<strong>媒婆</strong>，就是通过消息中间件协调多个系统，在两个系统操作事务的时候都锁定资源但是不提交事务，等两者都准备好了，告诉消息中间件，然后再分别提交事务。</p>
<p><strong>但是我不知道大家看到问题所在没有？</strong></p>
<p>是的你可能已经发现了，如果A系统事务提交成功了，但是B系统在提交的时候网络波动或者各种原因提交失败了，其实还是会失败的。</p>
<p><strong>最终一致性</strong>：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzjaiaLbo3bKFDic8zvesZQQYGzqjLEEExfaHBB0EkbQvEvIIaiaaAdMtdr12KgEfc0ktpqHMQibnau4g/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>整个流程中，我们能保证是：</p>
<ul>
<li>业务主动方本地事务提交失败，业务被动方不会收到消息的投递。</li>
<li>只要业务主动方本地事务执行成功，那么消息服务一定会投递消息给下游的业务被动方，并最终保证业务被动方一定能成功消费该消息（消费成功或失败，即最终一定会有一个最终态）。</li>
</ul>
<p>不过呢技术就是这样，<strong>各种极端的情况我们都需要考虑</strong>，也很难有完美的方案，所以才会有这么多的方案<strong>三段式</strong>、<strong>TCC</strong>、<strong>最大努力通知</strong>等等分布式事务方案，大家只需要知道为啥要做，做了有啥好处，有啥坏处，在实际开发的时候都注意下就好好了，<strong>系统都是根据业务场景设计出来的，离开业务的技术没有意义，离开技术的业务没有底气</strong>。</p>
<p>还是那句话：<strong>没有最完美的系统，只有最适合的系统。</strong></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>1.<a href="https://www.zhihu.com/question/54152397/answer/657234090" target="_blank" rel="noopener">https://www.zhihu.com/question/54152397/answer/657234090</a>  消息队列是什么</p>
<p>2.<a href="https://github.com/AobingJava/JavaFamily/blob/master/docs/mq/%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.md" target="_blank" rel="noopener">https://github.com/AobingJava/JavaFamily/blob/master/docs/mq/%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.md</a>  重复消费、顺序消费、分布式事务</p>
<p>3.<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453140952&amp;idx=1&amp;sn=e24f5a38531effd7964599ab9ba408d6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&amp;mid=2453140952&amp;idx=1&amp;sn=e24f5a38531effd7964599ab9ba408d6&amp;scene=21#wechat_redirect</a>  消息队列基础</p>
]]></content>
      <categories>
        <category>web后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL面试知识</title>
    <url>/likemoves.github.io/2020/05/28/MySQL%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/27/tEt6UA.png" alt="tEt6UA.png"></p>
<p>客户端请求 —&gt; 连接器（验证用户身份，给予权限）  —&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作） —&gt; 分析器（对SQL进行词法分析和语法分析操作）  —&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  —&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） —&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<h2 id="InnoDB-和MYISAM-的区别"><a href="#InnoDB-和MYISAM-的区别" class="headerlink" title="InnoDB 和MYISAM 的区别"></a>InnoDB 和MYISAM 的区别</h2><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">MyISAM</th>
<th align="left">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主外键</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">事务</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">行表锁</td>
<td align="left">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td align="left">行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td align="left">缓存</td>
<td align="left">只缓存索引，不缓存真实数据</td>
<td align="left">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td align="left">表空间</td>
<td align="left">小</td>
<td align="left">大</td>
</tr>
<tr>
<td align="left">关注点</td>
<td align="left">性能</td>
<td align="left">事务</td>
</tr>
<tr>
<td align="left">默认安装</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li><strong>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</strong></li>
</ol>
<p>举例：一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>索引的本质是：数据结构**</p>
<p>索引的<strong>目的</strong>在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</p>
<p>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></p>
<p>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>创建索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexname <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>));</span><br></pre></td></tr></table></figure>

<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<p>修改表结构(添加索引)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> tableName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName(columnName)</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable</span><br></pre></td></tr></table></figure>

<p>查看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name\G             <span class="comment">--可以通过添加 \G 来格式化输出信息。</span></span><br></pre></td></tr></table></figure>

<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><strong>提高数据检索效率，降低数据库IO成本</strong></li>
<li><strong>降低数据排序的成本，降低CPU的消耗</strong></li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li>
</ul>
<h2 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h2><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>一棵m阶的B-Tree有如下特性：</p>
<ol>
<li>每个节点最多有m个孩子</li>
<li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li>
<li>若根节点不是叶子节点，则至少有2个孩子</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<h3 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h3><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p>
<p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p>
<p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p>
<p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p>
<h3 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h3><p><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中<strong>同时存放索引和数据</strong></p>
<h4 id="辅助（非主键）索引："><a href="#辅助（非主键）索引：" class="headerlink" title="辅助（非主键）索引："></a>辅助（非主键）索引：</h4><p>辅助索引中叶子节点的数据区存放的是<strong>该数据的主键</strong>，这意味着会产生”回表查询”</p>
<p>第一次查询根据辅助索引查到数据主键信息，第二次查询根据主键在主索引上再进行对应的检索操作</p>
<h4 id="InnoDB-索引结构需要注意的点"><a href="#InnoDB-索引结构需要注意的点" class="headerlink" title="InnoDB 索引结构需要注意的点"></a>InnoDB 索引结构需要注意的点</h4><ol>
<li>数据文件本身就是索引文件</li>
<li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<p>如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p>
<p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
<h3 id="为什么Mysql索引要用B-树不是B树？"><a href="#为什么Mysql索引要用B-树不是B树？" class="headerlink" title="为什么Mysql索引要用B+树不是B树？"></a>为什么Mysql索引要用B+树不是B树？</h3><p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h3 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h3><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重IO负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<h3 id="主键索引和唯一索引的区别"><a href="#主键索引和唯一索引的区别" class="headerlink" title="主键索引和唯一索引的区别"></a>主键索引和唯一索引的区别</h3><ol>
<li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li>
<li>主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。</li>
<li>唯一性索引列允许空值， 而主键列不允许为空值。</li>
<li>主键可以被其他表引用为外键，而唯一索引不能。</li>
<li>一个表最多只能创建一个主键，但是可以创建多个唯一索引。</li>
<li>主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。</li>
<li>在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。</li>
</ol>
<h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h2><p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p>
<p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p>
<p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p>
<p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p>
<p>InnoDB 的 MVCC，是通过在每行记录后面保存<strong>两个隐藏的列</strong>来实现。这两个列，一个保存了<strong>行的创建时间</strong>，一个保存<strong>行的过期时间（删除时间）</strong>。当然存储的并不是真实的时间，而是<strong>系统版本号</strong>（system version number）。每开始一个新的事务，系统版本号都会<strong>自动递增</strong>。事务开始时刻的系统版本号会作为事务的版本号，<strong>用来和查询到的每行记录的版本号进行比较</strong>。</p>
<p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p>
<ul>
<li><p>SELECT</p>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<p>只有符合上述两个条件的才会被查询出来</p>
</li>
<li><ul>
<li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ul>
</li>
<li><p>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
</li>
<li><p>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>是一个日志文件用来记录一连串事务</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。</p>
<p>InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p>
<p><strong>事务日志可以帮助提高事务效率：</strong></p>
<ul>
<li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li>
<li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li>
</ul>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li><p><strong>redo log（重做日志</strong>） 实现持久化和原子性</p>
<p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。</p>
<ol>
<li><p>事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，</p>
</li>
<li><p>在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。</p>
</li>
<li><p>当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。</p>
</li>
</ol>
<p>此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p>
<p>在系统启动的时候，就已经为redo log分配了一块<strong>连续的存储空间</strong>，以<strong>顺序追加</strong>的方式记录Redo Log，通过顺序IO来改善性能。所有的<strong>事务共享redo log的存储空间</strong>，它们的Redo Log按语句的执行顺序，<strong>依次交替</strong>的记录在一起。</p>
</li>
<li><p><strong>undo log（回滚日志）</strong> 实现一致性</p>
<p>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。<strong>undo log记录了数据在每个操作前的状态</strong>，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p>
<p>Undo记录的是<strong>已部分完成并且写入硬盘的未完成的事务</strong>，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</p>
</li>
</ul>
<p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p>
<h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p>
<p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>
<p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p>
<p>MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p>
<ul>
<li>应用程序：定义了事务的边界，指定需要做哪些事务；</li>
<li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li>
<li>事务管理器：协调参与了全局事务中的各个事务。</li>
</ul>
<p>分布式事务采用两段式提交（two-phase commit）的方式：</p>
<ul>
<li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li>
<li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li>
</ul>
<h2 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h2><h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul>
<li><p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li><p>存储定位对MySQL的影响</p>
</li>
<li><ul>
<li>系统各种配置及规则数据</li>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
<li>不适合放进MySQL的数据</li>
<li>需要放进缓存的数据</li>
</ul>
</li>
<li><p>Schema设计对系统的性能影响</p>
</li>
<li><ul>
<li>尽量减少对数据库访问的请求</li>
<li>尽量减少无用数据的查询请求</li>
</ul>
</li>
<li><p>硬件环境对系统性能的影响</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li>
</ul>
<h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul>
<li>查询语句写的烂</li>
<li>索引失效（单值、复合）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<h5 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h5><ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
</ul>
<h4 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h4><p><strong>永远小标驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">slect * from A where id in (select id from B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id=B.id</span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀 </p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
</li>
<li><ul>
<li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li>
</ul>
</li>
<li><p>优化策略</p>
</li>
<li><ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_lencth_for_sort_data参数的设置</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
</ul>
<h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li><p>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p>
<p>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</p>
</li>
<li><p>尽量避免NULL：通常情况下最好指定列为NOT NULL</p>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul>
<li><p>slave 会从 master 读取 binlog 来进行数据同步</p>
</li>
<li><p>三个步骤</p>
</li>
<li><ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li>
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ol>
</li>
</ul>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个 slave只有一个 master</li>
<li>每个 salve只能有一个唯一的服务器 ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul>
<li>延时</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>
<p><strong>举例：</strong></p>
<p>电话字段可以分为固定电话和手机电话，所以电话这个字段不满足第一范式</p>
</li>
<li><p>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>
<p><strong>举例</strong>：</p>
<table>
<thead>
<tr>
<th>本人身份证号</th>
<th>关系人身份证号</th>
<th>关系人职务</th>
<th>与本人关系</th>
</tr>
</thead>
<tbody><tr>
<td>大头儿子</td>
<td>小头爸爸</td>
<td>经理</td>
<td>父亲</td>
</tr>
</tbody></table>
<p>关系人职务字段只与关系人身份证号有关，即<strong>非关键字段</strong>对<strong>任一候选关键字段</strong>的<strong>部分函数依赖</strong>，不符合第二范式，应该为：</p>
</li>
</ul>
<p>  “社会关系表”</p>
<table>
<thead>
<tr>
<th>本人身份证号</th>
<th>关系人身份证号</th>
<th>与本人关系</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>   “关系人职务表”</p>
<table>
<thead>
<tr>
<th>关系人身份证号</th>
<th>关系人职务</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</p>
<p><strong>举例：</strong></p>
<table>
<thead>
<tr>
<th>专业编号</th>
<th>所属系编号</th>
<th>系地址</th>
<th>系电话</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>专业编号决定了所属系编号，所属系编号不决定专业编号，所属系编号决定了系电话。</p>
<p>应改为：</p>
<table>
<thead>
<tr>
<th>专业编号</th>
<th>所属系编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>系编号</th>
<th>系地址</th>
<th>系电话</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<p>参考文档：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247488461&amp;idx=1&amp;sn=f4025de8fd645ccda9b5640facf4dc96&amp;chksm=ebd752ccdca0dbda056910521cba0313de65a09e080b4f039d88563f367be123e40ec6e24cae&amp;scene=126&amp;sessionid=1590541202&amp;key=b77fef048ebb9fec3248b792c64aec4613190a4d4da9a45b2e3aa078820c98cea3564702f1cbaf85b824d95b55a765b268e49ea95d7b9395070591d6ee37fc17c9b66268edf9b4577841d35b2d901c01&amp;ascene=1&amp;uin=NTU1MzY1MTM1&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AZUpzDt%2FnCmEuvKeJK4cKPU%3D&amp;pass_ticket=8b1LmSKwoOEO13rAzLHqTRcn9CkC%2F8aqh3nzwPvBG31HYLKtQ4WH9OUkQSo2vOWe" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247488461&amp;idx=1&amp;sn=f4025de8fd645ccda9b5640facf4dc96&amp;chksm=ebd752ccdca0dbda056910521cba0313de65a09e080b4f039d88563f367be123e40ec6e24cae&amp;scene=126&amp;sessionid=1590541202&amp;key=b77fef048ebb9fec3248b792c64aec4613190a4d4da9a45b2e3aa078820c98cea3564702f1cbaf85b824d95b55a765b268e49ea95d7b9395070591d6ee37fc17c9b66268edf9b4577841d35b2d901c01&amp;ascene=1&amp;uin=NTU1MzY1MTM1&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AZUpzDt%2FnCmEuvKeJK4cKPU%3D&amp;pass_ticket=8b1LmSKwoOEO13rAzLHqTRcn9CkC%2F8aqh3nzwPvBG31HYLKtQ4WH9OUkQSo2vOWe</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java面试题</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
