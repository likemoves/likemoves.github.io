<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/likemoves.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/likemoves.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/likemoves.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/likemoves.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/likemoves.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/likemoves.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/likemoves.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java面试题,数据库,MySQL,">










<meta name="description" content="MySQL架构 连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能">
<meta name="keywords" content="java面试题,数据库,MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL面试知识">
<meta property="og:url" content="http://yoursite.com/2020/05/28/MySQL面试知识/index.html">
<meta property="og:site_name" content="如烟Ryans">
<meta property="og:description" content="MySQL架构 连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://s1.ax1x.com/2020/05/27/tEt6UA.png">
<meta property="og:updated_time" content="2020-05-30T03:15:02.243Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL面试知识">
<meta name="twitter:description" content="MySQL架构 连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 服务层：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/05/27/tEt6UA.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/likemoves.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/28/MySQL面试知识/">





  <title>MySQL面试知识 | 如烟Ryans</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/likemoves.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">如烟Ryans</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/likemoves.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/likemoves.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/likemoves.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/likemoves.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/likemoves.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/likemoves.github.io/2020/05/28/MySQL面试知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="如烟Ryans">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/likemoves.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="如烟Ryans">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MySQL面试知识</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-28T19:13:59+08:00">
                2020-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/likemoves.github.io/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h2><ul>
<li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li>
<li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等</li>
<li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li>
<li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/27/tEt6UA.png" alt="tEt6UA.png"></p>
<p>客户端请求 —&gt; 连接器（验证用户身份，给予权限）  —&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作） —&gt; 分析器（对SQL进行词法分析和语法分析操作）  —&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法）  —&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） —&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p>
<h2 id="InnoDB-和MYISAM-的区别"><a href="#InnoDB-和MYISAM-的区别" class="headerlink" title="InnoDB 和MYISAM 的区别"></a>InnoDB 和MYISAM 的区别</h2><table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">MyISAM</th>
<th align="left">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="left">主外键</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">事务</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">行表锁</td>
<td align="left">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td align="left">行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td align="left">缓存</td>
<td align="left">只缓存索引，不缓存真实数据</td>
<td align="left">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td align="left">表空间</td>
<td align="left">小</td>
<td align="left">大</td>
</tr>
<tr>
<td align="left">关注点</td>
<td align="left">性能</td>
<td align="left">事务</td>
</tr>
<tr>
<td align="left">默认安装</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li>
<li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li>
<li><strong>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</strong></li>
</ol>
<p>举例：一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p>
<p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p>
<p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>索引的本质是：数据结构**</p>
<p>索引的<strong>目的</strong>在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</p>
<p>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></p>
<p>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，符合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>创建索引:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexname <span class="keyword">ON</span> mytable(username(<span class="keyword">length</span>));</span><br></pre></td></tr></table></figure>

<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p>
<p>修改表结构(添加索引)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> tableName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName(columnName)</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable</span><br></pre></td></tr></table></figure>

<p>查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name\G             <span class="comment">--可以通过添加 \G 来格式化输出信息。</span></span><br></pre></td></tr></table></figure>

<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><strong>提高数据检索效率，降低数据库IO成本</strong></li>
<li><strong>降低数据排序的成本，降低CPU的消耗</strong></li>
</ul>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul>
<li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li>
<li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li>
</ul>
<h2 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h2><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>一棵m阶的B-Tree有如下特性：</p>
<ol>
<li>每个节点最多有m个孩子</li>
<li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li>
<li>若根节点不是叶子节点，则至少有2个孩子</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li>
<li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki(i=1,…n)为关键字，且关键字升序排序</li>
<li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ol>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>非叶子节点只存储键值信息；</li>
<li>所有叶子节点之间都有一个链指针；</li>
<li>数据记录都存放在叶子节点中</li>
</ol>
<h3 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h3><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”非聚簇索引”。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p>
<p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p>
<p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p>
<p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p>
<h3 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h3><p><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为“聚簇索引”，一个表只能有一个聚簇索引。</p>
<h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中<strong>同时存放索引和数据</strong></p>
<h4 id="辅助（非主键）索引："><a href="#辅助（非主键）索引：" class="headerlink" title="辅助（非主键）索引："></a>辅助（非主键）索引：</h4><p>辅助索引中叶子节点的数据区存放的是<strong>该数据的主键</strong>，这意味着会产生”回表查询”</p>
<p>第一次查询根据辅助索引查到数据主键信息，第二次查询根据主键在主索引上再进行对应的检索操作</p>
<h4 id="InnoDB-索引结构需要注意的点"><a href="#InnoDB-索引结构需要注意的点" class="headerlink" title="InnoDB 索引结构需要注意的点"></a>InnoDB 索引结构需要注意的点</h4><ol>
<li>数据文件本身就是索引文件</li>
<li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li>
<li>聚集索引中叶节点包含了完整的数据记录</li>
<li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li>
</ol>
<p>如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p>
<p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p>
<h3 id="为什么Mysql索引要用B-树不是B树？"><a href="#为什么Mysql索引要用B-树不是B树？" class="headerlink" title="为什么Mysql索引要用B+树不是B树？"></a>为什么Mysql索引要用B+树不是B树？</h3><p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段</li>
<li>查询中与其他表关联的字段，外键关系建立索引</li>
<li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li>
<li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li>
<li>查询中统计或分组字段</li>
</ol>
<h3 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h3><ol>
<li>表记录太少</li>
<li>经常增删改的表</li>
<li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li>
<li>频繁更新的字段不适合创建索引（会加重IO负担）</li>
<li>where条件里用不到的字段不创建索引</li>
</ol>
<h3 id="主键索引和唯一索引的区别"><a href="#主键索引和唯一索引的区别" class="headerlink" title="主键索引和唯一索引的区别"></a>主键索引和唯一索引的区别</h3><ol>
<li>主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。</li>
<li>主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。</li>
<li>唯一性索引列允许空值， 而主键列不允许为空值。</li>
<li>主键可以被其他表引用为外键，而唯一索引不能。</li>
<li>一个表最多只能创建一个主键，但是可以创建多个唯一索引。</li>
<li>主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。</li>
<li>在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。</li>
</ol>
<h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h2><p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p>
<p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p>
<p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p>
<p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p>
<p>InnoDB 的 MVCC，是通过在每行记录后面保存<strong>两个隐藏的列</strong>来实现。这两个列，一个保存了<strong>行的创建时间</strong>，一个保存<strong>行的过期时间（删除时间）</strong>。当然存储的并不是真实的时间，而是<strong>系统版本号</strong>（system version number）。每开始一个新的事务，系统版本号都会<strong>自动递增</strong>。事务开始时刻的系统版本号会作为事务的版本号，<strong>用来和查询到的每行记录的版本号进行比较</strong>。</p>
<p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p>
<ul>
<li><p>SELECT</p>
<p>InnoDB会根据以下两个条件检查每行记录：</p>
<p>只有符合上述两个条件的才会被查询出来</p>
</li>
<li><ul>
<li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li>
</ul>
</li>
<li><p>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
</li>
<li><p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p>
</li>
<li><p>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p>
<p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p>
<h2 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>是一个日志文件用来记录一连串事务</p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。</p>
<p>InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p>
<p><strong>事务日志可以帮助提高事务效率：</strong></p>
<ul>
<li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li>
<li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li>
</ul>
<h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ul>
<li><p><strong>redo log（重做日志</strong>） 实现持久化和原子性</p>
<p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。</p>
<ol>
<li><p>事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，</p>
</li>
<li><p>在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。</p>
</li>
<li><p>当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。</p>
</li>
</ol>
<p>此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p>
<p>在系统启动的时候，就已经为redo log分配了一块<strong>连续的存储空间</strong>，以<strong>顺序追加</strong>的方式记录Redo Log，通过顺序IO来改善性能。所有的<strong>事务共享redo log的存储空间</strong>，它们的Redo Log按语句的执行顺序，<strong>依次交替</strong>的记录在一起。</p>
</li>
<li><p><strong>undo log（回滚日志）</strong> 实现一致性</p>
<p>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。<strong>undo log记录了数据在每个操作前的状态</strong>，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p>
<p>Undo记录的是<strong>已部分完成并且写入硬盘的未完成的事务</strong>，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</p>
</li>
</ul>
<p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p>
<h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p>
<p>MySQL 从 5.0.3  InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p>
<p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p>
<p>MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p>
<ul>
<li>应用程序：定义了事务的边界，指定需要做哪些事务；</li>
<li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li>
<li>事务管理器：协调参与了全局事务中的各个事务。</li>
</ul>
<p>分布式事务采用两段式提交（two-phase commit）的方式：</p>
<ul>
<li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li>
<li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li>
</ul>
<h2 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h2><h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul>
<li><p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li><p>存储定位对MySQL的影响</p>
</li>
<li><ul>
<li>系统各种配置及规则数据</li>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
<li>不适合放进MySQL的数据</li>
<li>需要放进缓存的数据</li>
</ul>
</li>
<li><p>Schema设计对系统的性能影响</p>
</li>
<li><ul>
<li>尽量减少对数据库访问的请求</li>
<li>尽量减少无用数据的查询请求</li>
</ul>
</li>
<li><p>硬件环境对系统性能的影响</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h4><ul>
<li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li>
<li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li>
</ul>
<h4 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h4><ul>
<li>查询语句写的烂</li>
<li>索引失效（单值、复合）</li>
<li>关联查询太多join（设计缺陷或不得已的需求）</li>
<li>服务器调优及各个参数设置（缓冲、线程数等）</li>
</ul>
<h4 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h4><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<h5 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h5><ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
</ul>
<h4 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h4><p><strong>永远小标驱动大表（小的数据集驱动大的数据集）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slect * from A where id in (select id from B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id=B.id</span><br></pre></td></tr></table></figure>

<p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p>
<p>注意：A表与B表的ID字段应建立索引。</p>
<p><strong>order by关键字优化</strong></p>
<ul>
<li><p>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</p>
</li>
<li><p>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</p>
</li>
<li><p>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</p>
</li>
<li><p>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀 </p>
</li>
<li><p>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序</p>
</li>
<li><ul>
<li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li>
<li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li>
</ul>
</li>
<li><p>优化策略</p>
</li>
<li><ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_lencth_for_sort_data参数的设置</li>
</ul>
</li>
</ul>
<p><strong>GROUP BY关键字优化</strong></p>
<ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
</ul>
<h4 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h4><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li><p>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p>
<p>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</p>
</li>
<li><p>尽量避免NULL：通常情况下最好指定列为NOT NULL</p>
</li>
</ul>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul>
<li><p>slave 会从 master 读取 binlog 来进行数据同步</p>
</li>
<li><p>三个步骤</p>
</li>
<li><ol>
<li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li>
<li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li>
</ol>
</li>
</ul>
<h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul>
<li>每个 slave只有一个 master</li>
<li>每个 salve只能有一个唯一的服务器 ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul>
<li>延时</li>
</ul>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul>
<li><p>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p>
<p><strong>举例：</strong></p>
<p>电话字段可以分为固定电话和手机电话，所以电话这个字段不满足第一范式</p>
</li>
<li><p>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p>
<p><strong>举例</strong>：</p>
<table>
<thead>
<tr>
<th>本人身份证号</th>
<th>关系人身份证号</th>
<th>关系人职务</th>
<th>与本人关系</th>
</tr>
</thead>
<tbody><tr>
<td>大头儿子</td>
<td>小头爸爸</td>
<td>经理</td>
<td>父亲</td>
</tr>
</tbody></table>
<p>关系人职务字段只与关系人身份证号有关，即<strong>非关键字段</strong>对<strong>任一候选关键字段</strong>的<strong>部分函数依赖</strong>，不符合第二范式，应该为：</p>
</li>
</ul>
<p>  “社会关系表”</p>
<table>
<thead>
<tr>
<th>本人身份证号</th>
<th>关系人身份证号</th>
<th>与本人关系</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>   “关系人职务表”</p>
<table>
<thead>
<tr>
<th>关系人身份证号</th>
<th>关系人职务</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：关键字段 → 非关键字段 x → 非关键字段y</p>
<p><strong>举例：</strong></p>
<table>
<thead>
<tr>
<th>专业编号</th>
<th>所属系编号</th>
<th>系地址</th>
<th>系电话</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>专业编号决定了所属系编号，所属系编号不决定专业编号，所属系编号决定了系电话。</p>
<p>应改为：</p>
<table>
<thead>
<tr>
<th>专业编号</th>
<th>所属系编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>系编号</th>
<th>系地址</th>
<th>系电话</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<p>参考文档：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247488461&amp;idx=1&amp;sn=f4025de8fd645ccda9b5640facf4dc96&amp;chksm=ebd752ccdca0dbda056910521cba0313de65a09e080b4f039d88563f367be123e40ec6e24cae&amp;scene=126&amp;sessionid=1590541202&amp;key=b77fef048ebb9fec3248b792c64aec4613190a4d4da9a45b2e3aa078820c98cea3564702f1cbaf85b824d95b55a765b268e49ea95d7b9395070591d6ee37fc17c9b66268edf9b4577841d35b2d901c01&amp;ascene=1&amp;uin=NTU1MzY1MTM1&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AZUpzDt%2FnCmEuvKeJK4cKPU%3D&amp;pass_ticket=8b1LmSKwoOEO13rAzLHqTRcn9CkC%2F8aqh3nzwPvBG31HYLKtQ4WH9OUkQSo2vOWe" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247488461&amp;idx=1&amp;sn=f4025de8fd645ccda9b5640facf4dc96&amp;chksm=ebd752ccdca0dbda056910521cba0313de65a09e080b4f039d88563f367be123e40ec6e24cae&amp;scene=126&amp;sessionid=1590541202&amp;key=b77fef048ebb9fec3248b792c64aec4613190a4d4da9a45b2e3aa078820c98cea3564702f1cbaf85b824d95b55a765b268e49ea95d7b9395070591d6ee37fc17c9b66268edf9b4577841d35b2d901c01&amp;ascene=1&amp;uin=NTU1MzY1MTM1&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AZUpzDt%2FnCmEuvKeJK4cKPU%3D&amp;pass_ticket=8b1LmSKwoOEO13rAzLHqTRcn9CkC%2F8aqh3nzwPvBG31HYLKtQ4WH9OUkQSo2vOWe</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/likemoves.github.io/tags/java面试题/" rel="tag"># java面试题</a>
          
            <a href="/likemoves.github.io/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/likemoves.github.io/tags/MySQL/" rel="tag"># MySQL</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/likemoves.github.io/2020/05/28/剑指offer面试题65--不用加减乘除做加法/" rel="next" title="剑指offer面试题65--不用加减乘除做加法">
                <i class="fa fa-chevron-left"></i> 剑指offer面试题65--不用加减乘除做加法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/likemoves.github.io/2020/05/29/剑指offer面试题66--构建乘积数组/" rel="prev" title="剑指offer面试题66--构建乘积数组">
                剑指offer面试题66--构建乘积数组 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">如烟Ryans</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/likemoves.github.io/archives/">
              
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/likemoves.github.io/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/likemoves.github.io/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL架构"><span class="nav-number">1.</span> <span class="nav-text">MySQL架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-和MYISAM-的区别"><span class="nav-number">2.</span> <span class="nav-text">InnoDB 和MYISAM 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引"><span class="nav-number">3.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本语法"><span class="nav-number">3.2.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优势"><span class="nav-number">3.3.</span> <span class="nav-text">优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#劣势"><span class="nav-number">3.4.</span> <span class="nav-text">劣势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL索引结构"><span class="nav-number">4.</span> <span class="nav-text">MySQL索引结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Tree索引"><span class="nav-number">4.1.</span> <span class="nav-text">B+Tree索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Tree"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">B-Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Tree-1"><span class="nav-number">4.1.0.2.</span> <span class="nav-text">B+Tree</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM主键索引与辅助索引的结构"><span class="nav-number">4.2.</span> <span class="nav-text">MyISAM主键索引与辅助索引的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB主键索引与辅助索引的结构"><span class="nav-number">4.3.</span> <span class="nav-text">InnoDB主键索引与辅助索引的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主键索引"><span class="nav-number">4.3.1.</span> <span class="nav-text">主键索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#辅助（非主键）索引："><span class="nav-number">4.3.2.</span> <span class="nav-text">辅助（非主键）索引：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB-索引结构需要注意的点"><span class="nav-number">4.3.3.</span> <span class="nav-text">InnoDB 索引结构需要注意的点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash索引"><span class="nav-number">4.4.</span> <span class="nav-text">Hash索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么Mysql索引要用B-树不是B树？"><span class="nav-number">4.5.</span> <span class="nav-text">为什么Mysql索引要用B+树不是B树？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哪些情况需要创建索引"><span class="nav-number">4.6.</span> <span class="nav-text">哪些情况需要创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哪些情况不需要创建索引"><span class="nav-number">4.7.</span> <span class="nav-text">哪些情况不需要创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主键索引和唯一索引的区别"><span class="nav-number">4.8.</span> <span class="nav-text">主键索引和唯一索引的区别</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#MVCC-多版本并发控制"><span class="nav-number">5.</span> <span class="nav-text">MVCC 多版本并发控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务日志"><span class="nav-number">6.</span> <span class="nav-text">事务日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#是什么"><span class="nav-number">6.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么"><span class="nav-number">6.2.</span> <span class="nav-text">为什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么用"><span class="nav-number">6.3.</span> <span class="nav-text">怎么用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL对分布式事务的支持"><span class="nav-number">6.4.</span> <span class="nav-text">MySQL对分布式事务的支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL调优"><span class="nav-number">7.</span> <span class="nav-text">MySQL调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#影响mysql的性能因素"><span class="nav-number">7.1.</span> <span class="nav-text">影响mysql的性能因素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能分析"><span class="nav-number">7.2.</span> <span class="nav-text">性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL常见瓶颈"><span class="nav-number">7.2.1.</span> <span class="nav-text">MySQL常见瓶颈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能下降SQL慢-执行时间长-等待时间长-原因分析"><span class="nav-number">7.2.2.</span> <span class="nav-text">性能下降SQL慢 执行时间长 等待时间长 原因分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL常见性能分析手段"><span class="nav-number">7.2.3.</span> <span class="nav-text">MySQL常见性能分析手段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#性能优化"><span class="nav-number">7.3.</span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引优化"><span class="nav-number">7.3.1.</span> <span class="nav-text">索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一般性建议"><span class="nav-number">7.3.1.1.</span> <span class="nav-text">一般性建议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL语句优化"><span class="nav-number">7.3.2.</span> <span class="nav-text">SQL语句优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据类型优化"><span class="nav-number">7.3.3.</span> <span class="nav-text">数据类型优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主从复制"><span class="nav-number">8.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#复制的基本原理"><span class="nav-number">8.1.</span> <span class="nav-text">复制的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制的基本原则"><span class="nav-number">8.2.</span> <span class="nav-text">复制的基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制的最大问题"><span class="nav-number">8.3.</span> <span class="nav-text">复制的最大问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题"><span class="nav-number">9.</span> <span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说一说三个范式"><span class="nav-number">9.1.</span> <span class="nav-text">说一说三个范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#百万级别或以上的数据如何删除"><span class="nav-number">9.2.</span> <span class="nav-text">百万级别或以上的数据如何删除</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">如烟Ryans</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/likemoves.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/likemoves.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/likemoves.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/likemoves.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/likemoves.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/likemoves.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/likemoves.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/likemoves.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/likemoves.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/likemoves.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/likemoves.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/likemoves.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/likemoves.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
